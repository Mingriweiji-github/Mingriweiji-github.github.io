{"meta":{"title":"Mingriweiji-github","subtitle":"","description":"","author":"KM","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Runloop","slug":"Runloop","date":"2020-03-11T13:16:28.012Z","updated":"2020-03-11T13:20:25.510Z","comments":true,"path":"2020/03/11/Runloop/","link":"","permalink":"http://yoursite.com/2020/03/11/Runloop/","excerpt":"","text":"Runloop‌ 1.讲讲 RunLoop，项目中有用到吗？‌ 事件循环，在程序运行中循环做一些事情 没有消息mach_msg()切换用户态到内核态线程休眠，有消息内核态切换到用户态 ‌ runloop相关：‌ GCD、AutoreleasePool Timer、performSelector 事件响应、收拾识别、网络请求 ‌ runloop的应用：‌ 线程包活 解决timer滑动停止问题，监听卡顿 性能优化 ‌ 2.runloop的状态和runloop内部实现逻辑？exit: ⌘↩ 1&#x2F;* Run Loop Observer Activities *&#x2F;2typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;3 kCFRunLoopEntry &#x3D; (1UL &lt;&lt; 0), &#x2F;&#x2F; 即将进入Loop4 kCFRunLoopBeforeTimers &#x3D; (1UL &lt;&lt; 1), &#x2F;&#x2F;即将处理Timer5 kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2), &#x2F;&#x2F;即将处理Source6 kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5), &#x2F;&#x2F;即将进入休眠7 kCFRunLoopAfterWaiting &#x3D; (1UL &lt;&lt; 6), &#x2F;&#x2F;刚从休眠中唤醒8 kCFRunLoopExit &#x3D; (1UL &lt;&lt; 7), &#x2F;&#x2F;即将退出Loop9 kCFRunLoopAllActivities &#x3D; 0x0FFFFFFFU10&#125;; ‌ source0 : 触摸事件、performSelectorOnThread: source1: 基于Port的线程间通讯，捕获到的系统事件 timers: NSTimer + performSelector:afterDelay: observers: 监听runloop的状态/autoreleasePool的创建和释放、UI的刷新 runloop运行逻辑Enter a caption for this image (optional) ‌ 23.runloop和线程的关系？‌ 一一对应 保存在一个全局字典中，线程是key, runloop是value 子线程默认没有runloop，在第一次获取runloop时才会创建。 runloop在线程结束时销毁 ‌ 24.timer 与 runloop 的关系？‌ 程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？ ‌ 25.runloop 是怎么响应用户操作的， 具体流程是什么样的？‌ 26.说说runLoop的几种状态 ‌ 27.runloop的mode作用是什么？‌ CFRunLoopModeRef代表RunLoop的运行模式 一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer RunLoop启动时只能选择其中一个Mode，作为currentMode 如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入 不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响 如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出 ‌ 28.KVO实现原理?哪些情况下使用kvo会崩溃，怎么防护崩溃? ‌ 29.如何手动关闭KVO?如何手动自己实现KVO说说思路 ‌ 30.通过KVC修改属性会触发KVO么","categories":[],"tags":[]},{"title":"多线程","slug":"多线程","date":"2020-03-11T12:34:15.299Z","updated":"2020-03-11T12:34:15.299Z","comments":true,"path":"2020/03/11/多线程/","link":"","permalink":"http://yoursite.com/2020/03/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"1、你理解的多线程？并发和串行，同步和异步 同步和异步的区别是否开辟新的线程，同步只能在当前线程执行任务，异步可以再新的线程执行任务 串行和并发的区别是任务执行的顺序，串行任务只能顺序执行，并发可以多个任务同时执行。 ‌ 2、iOS多线程有哪些？常用哪个？ NSThread、GCD/NSOperationQueue 常用GCD/NSOperation pthread NSThread GCD NSoperationEnter a caption for this image (optional) image.pngEnter a caption for this image (optional) GCD 的队列类型有哪些？OperationQueue 和 GCD 的区别？ GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择； 在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)； NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行； 我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样子能比GCD更加有效地掌控我们执行的后台任务； 在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码； 我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。 总的来说，Operation queue 提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。 从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。 如何用gcd实现以下功能？ 异步并发执行任务1、任务2 等任务1、任务2都执行完毕后，再回到主线程执行任务3 线程安全是什么？如何处理线程安全的问题？ 我们一般通过线程同步方案如加锁的方式来实现线程的安全 iOS锁的原理 | 深入浅出iOS系统内核-同步机制 os_unfair_lock：iOS10开始os_unfair_lock来替代OSSpinLock, 等待锁的线程会进入休眠不占用CPU资源， 这个os_unfair_lock解决了优先级翻转问题。 OSSpinLock: 自旋锁，线程忙等一直占用CUP资源，不安全因为可能出现优先级翻转的可能 dispatch_semaphore：信号量为1的semaphore也可以看做是锁 pthread_mutex：mutex是互斥锁，等待锁的线程处于休眠状态，pthread_mutex是递归锁，可以递归调用。 使用GCD的串行队列也可以实现锁的功能 NSLock是对metex互斥锁的封装，NSRecurisiveLock也是对metex的递归封装，API和NSLock一直。 NSCondition NSConditionLock @synchorized也是mutex的递归封装，@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作。 自旋锁和互斥锁如何选择？自旋锁OSSpinLock：当线程获取锁，其他等待锁的线程会忙等一直占用CPU,自旋锁有优先级翻转的可能性，所以苹果已经弃用自旋锁OSSpinLock改用os_unfair_lock. 互斥锁mutext：阻塞线程并休眠，其他线程才能正常访问，用互斥的方式来保证线程的安全。 递归锁：顾名思义，可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。 什么情况使用自旋锁比较划算？ 预计线程等待锁的时间很短 加锁的代码（临界区）经常被调用，但竞争情况很少发生 CPU资源不紧张 多核处理器 什么情况使用互斥锁比较划算？ 预计线程等待锁的时间较长 单核处理器 临界区有IO操作 临界区代码复杂或者循环量大 临界区竞争非常激烈 追问二：使用以上锁需要注意哪些？ 追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！ iOS线程同步方案性能比较性能从高到低排序: 1os_unfair_lock ‌ 1OSSpinLock ‌ 1dispatch_semaphore ‌ 1pthread_mutex ‌ 1dispatch_queue(DISPATCH_QUEUE_SERIAL) ‌ 1NSLock ‌ 1NSCondition ‌ 1pthread_mutex(recursive) ‌ 1NSRecursiveLock ‌ 1NSConditionLock ‌ 1@synchronized ‌ 如何实现多度单写？1、**pthread_rwlock**读写锁-等待锁的线程进入休眠 pthread_rwlockEnter a caption for this image (optional) ‌ 2、dispatch_barrier_async 这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的 如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果 dispatch_barrier_asyncEnter a caption for this image (optional)","categories":[],"tags":[]},{"title":"Swift备忘录","slug":"Swift备忘录","date":"2019-12-07T04:48:29.505Z","updated":"2019-12-07T06:45:51.535Z","comments":true,"path":"2019/12/07/Swift备忘录/","link":"","permalink":"http://yoursite.com/2019/12/07/Swift%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"toc = true SwiftTip","text":"toc = true SwiftTip ##1、@autoclosure作用：将表达式自动封装成一个闭包 ()-&gt;Void ####1.2 ??的底层实现是用的enum ####1.3 “闭包和循环引用” weak解决循环引用的正确写法： 12var name: ()-&gt;() = &#123;34[weak self] in56if let strongSelf = self &#123;78print(\"The name is (strongSelf.name)\")910&#125;1112&#125; 2、值类型和引用类型的选择 数组和字典设计为值类型最大的考虑是为了线程安全. 另一个优点，那就是非常高效，因为 “一旦赋值就不太会变化” 这种使用情景在 Cocoa 框架中是占有绝大多数的，这有效减少了内存的分配和回收。 但是在少数情况下，我们显然也可能会在数组或者字典中存储非常多的东西，并且还要对其中的内容进行添加或者删除。” 在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好， 对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary 3、@escaping的作用？12class func animate(withDuration duration: TimeInterval, animations: @escaping () -&amp;gt; Void, completion: ((Bool) -&gt; Void)? = nil) 4、defer的使用注意点defer的作用域以前很单纯地认为 defer 是在函数退出的时候调用，并没有注意其实是当前 scope 退出的时候调用这个事实，造成了这个错误。在 if，guard，for，try 这些语句中使用 defer 时，应该要特别注意这一点。 5、@discardableResult6、ResultResult&lt;T, E: Error&gt; 和 Result 7、Lazy的使用12let data = 1...334let result = data.lazy.map &#123; (i: Int) -&gt; Int in56print(\"准备处理(i)\")78return i * 2910&#125;1112print(\"准备访问结果\")1314for i in result &#123;1516print(\"处理后的结果:(i)\")1718&#125;1920print(\"done\") 打印结果： 准备访问结果 准备处理1 处理后的结果:2 准备处理2 处理后的结果:4 准备处理3 处理后的结果:6 done 8、Swift反射机制Mirror “通过 Mirror 初始化得到的结果中包含的元素的描述都被集合在 children 属性下，如果你有心可以到 Swift 标准库中查找它的定义，它实际上是一个 Child 的集合，而 Child 则是一对键值的多元组： 示例112struct Car &#123;34let logo: String56var wheel: Int78let door: Int910&#125;1112let baoM = Car(logo: \"BMW\", wheel: 4, door: 2)1314let mirror = Mirror(reflecting: baoM)1516print(\"类型:(String(describing: mirror.displayStyle))\")1718///1、通过Mirror的children获取属性信息1920print(\"属性个数:(mirror.children.count)\")2122mirror.children.map &#123; (child) -&gt; Any in2324print(\"label: (String(describing: child.label)), value: (child.value)\")2526&#125;2728///2、通过Refletion的dump(Any)方法获取属性信息2930dump(baoM) 示例2 获取property12let homeProperty = Mirror(reflecting: self)34homeProperty.children.map &#123;56LOG.D(\"home property:($0)\")78&#125; 9、iOS初始化核心原则 iOS 的初始化最核心两条的规则： • 必须至少有一个指定初始化器，在指定初始化器里保证所有非可选类型属性都得到正确的初始化（有值） • 便利初始化器必须调用其他初始化器，使得最后肯定会调用指定初始化器 在Swift中千万不要用String的count方法计算文本长度。否则当文本中有emoji时，会计算出错。应当转成NSString再去求length。 10、Swift备忘录001 Array for-in使用 1.for in获取索引 index1let array = [\"Apple\", \"Google\", \"Amazon\"]2 for item in array &#123;3 print(\"company name is :(item)\")4 &#125;5 ///配合array.enumerated()使用6 for (index, item) in array.enumerated() &#123;7 print(\"index:(index), item:(item)\")8 &#125; 2.array.firstIndex(of:)获取index1///配合array.firstIndex(of:)使用2 let googleIndex = array.firstIndex(of: \"Google\")3 print(\"googleIndex is : (googleIndex ?? 0)\")4///配合array.firstIndex(where:)使用5 if let index = array.firstIndex(where: &#123; $0.hasPrefix(\"A\") &#125;) &#123;6 print(\"array.firstIndex is (index)\")7 &#125;8 if let item = array.first(where: &#123; $0.hasPrefix(\"A\")&#125;&#123;9 print(\"array.first is :(item)\")10 &#125; Swift备忘录002 Array.forEach()2.1forEach()和函数式编程结合使用1let array = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"]2 ///使用forEach3 array.map &#123; Int($0)! &#125;.forEach &#123; num in4 print(num)5 &#125;6 //不使用forEach7 let map = array.map &#123; Int($0)! &#125;8 map.forEach &#123;9 print($0)10 &#125; 2.2forEach()遍历optional集合会自动过滤nil1let optionalString: [String]? = nil2 //使用forEach强制解包option，会过滤3 optionalString?.forEach &#123; str in4 print(\"str is (str)\")5 &#125;6 ///使用for-in强制解包optional，会crash7 for str in optionalString! &#123;8 print(\"str is (str)\")9 &#125; Swift备忘录003 Array index3.1","categories":[],"tags":[]},{"title":"Swift函数式编程","slug":"Swift函数式编程","date":"2019-12-06T01:36:47.815Z","updated":"2019-12-07T06:45:58.692Z","comments":true,"path":"2019/12/06/Swift函数式编程/","link":"","permalink":"http://yoursite.com/2019/12/06/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"Functional Programming in Swift函数式编程介绍。版本：Swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。","text":"Functional Programming in Swift函数式编程介绍。版本：Swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。 不变性和副作用无论您首先学习哪种编程语言，您可能要学习的最初概念之一就是变量代表数据或状态。如果您退一步考虑一下这个想法，变量似乎很奇怪。 术语“变量”表示随程序运行而变化的数量。从数学角度考虑数量问题，您已将时间作为软件行为的关键参数。通过更改变量，可以创建可变状态。 为了进行演示，请将以下代码添加到playground： 1var thing = 32//some stuff3thing = 445func superHero() &#123;6 print(\"I'm batman\")7 thing = 58&#125;910print(\"original state = \\(thing)\")11superHero()12print(\"mutated state = \\(thing)\") 神圣的神秘变化！为什么现在是5？这种变化称为副作用。函数superHero（）更改了一个甚至没有定义自己的变量。 单独或在简单系统中，可变状态不一定是问题。将许多对象连接在一起时（例如在大型的面向对象的系统中）会出现问题。可变状态会使人难以理解变量具有什么值以及该值随时间的变化而产生头痛。 例如，在为多线程系统编写代码时，如果两个或多个线程同时访问同一变量，则它们可能会无序地修改或访问它。这会导致意外的行为。这种意外行为包括竞态条件，死锁和许多其他问题。 试想一下，如果您可以编写状态永远不变的代码。并发系统中发生的所有问题都将消失。像这样工作的系统具有不变的状态，这意味着不允许状态在程序过程中进行更改。 使用不可变数据的主要好处是，使用不可变数据的代码单元没有副作用。代码中的函数不会更改其自身之外的元素，并且在发生函数调用时不会出现怪异的效果。您的程序可以正常运行，因为没有副作用，您可以轻松重现其预期的效果。 本教程从较高的层次介绍了FP，因此在实际情况下考虑这些概念会很有帮助。在这种情况下，假设您正在为游乐园构建应用程序，并且该游乐园的后端服务器通过REST API提供了行程数据。 创建Model1enum RideCategory: String &#123;2 case family3 case kids4 case thrill5 case scary6 case relaxing7 case water8&#125;910typealias Minutes = Double11struct Ride &#123;12 let name: String13 let categories: Set&lt;RideCategory&gt;14 let waitTime: Minutes15&#125; Create some data using that model1let parkRides = [2 Ride(name: \"R45\",3 categories: [.family, .thrill, .water],4 waitTime: 45.0),5 Ride(name: \"R10\", categories: [.family], waitTime: 10.0),6 Ride(name: \"R15\", categories: [.kids], waitTime: 15.0),7 Ride(name: \"R30\", categories: [.scary], waitTime: 30.0),8 Ride(name: \"R60\",9 categories: [.family, .thrill],10 waitTime: 60.0),11 Ride(name: \"R15-2\", categories: [.family, .kids], waitTime: 15.0),12 Ride(name: \"R25\", categories: [.family, .water], waitTime: 25.0),13 Ride(name: \"R0\",14 categories: [.family, .relaxing],15 waitTime: 0.0)16 ] FP: Filter Map ReduceMost languages that support FP will have the functions filter, map &amp; reduce. Map Map是将输入Collection中的每个Element转换为新Element。 使用map遍历一个集合，并对集合中的每个元素应用相同的操作。 map函数返回一个数组，其中包含对每个元素的映射或转换函数的结果。 Map on array:1let arrayOfInt = [1,2,3,4,5] 如果我们要对每个元素乘上10呢？我们以前可能要这样 1var newArr: [Int] = []2for value in arrayOfInt &#123;3 newArr.append(value * 10)4&#125;5print(newArr) 现在有map()后我们可以这样： 1let mapArr = arrayOfInt.map &#123; $0 * 10 &#125;2print(mapArr) Working of map: The map function has a single argument which is a closure (a function) that it calls as it loops over the collection. This closure takes the element from the collection as an argument and returns a result. The map function returns these results in an array. Map on Dictionary1let book = [\"A\": 100, \"B\": 80, \"C\": 90]2let mapedBook = book.map &#123; (key, value) in3 key.capitalized4&#125;5print(mapedBook) //[\"C\", \"B\", \"A\"] Map on Set1let lengthInmeter: Set = [1,3,5]2let km = lengthInmeter.map &#123; meter in meter * 1000 &#125;3print(km) // [1000, 5000, 3000] Map同时获取array.Index??1let nums = [1,2,3,4,5]2let newNums = nums.enumerated().map &#123; (index, num) in3 return num * 104&#125;5print(\"newNums:\\(newNums)\") FilterFilter函数的作用是过滤集合，返回符合条件的集合。 Filter on Array1let filterArray = [2,4,6,1,5,7]2let newFilterArray = filterArray.filter &#123; num -&gt; Bool in3 num % 2 == 04&#125;5print(newFilterArray) Filter on Dictionary1let book = [\"A\": 100, \"B\": 80, \"C\": 90]2let bookFilter = book.filter &#123; (key, value) in3 value &gt; 804&#125;5print(bookFilter) 简化 1let book = [\"A\": 100, \"B\": 80, \"C\": 90]2let bookFilter = book.filter &#123;3 $1 &gt; 804&#125; $0是key $1是value Filter on Set1let setNums = [4.9,5.5,8.6]2let newSet = setNums.filter &#123;3 $0 &gt; 5.04&#125;5print(newSet) 重要：返回类型是数组 Reduce Use reduce to combine all items in a collection to create a single new value. 使用reduce可以合并集合中的所有元素来创建一个新的value Apple文档声明reduce() 1func reduce&lt;Result&gt;(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -&gt; Result) rethrows -&gt; Result reduce函数有两个参数： 第一个参数 initial value用来存储初始值或者结果（每次迭代器的结果） 第二个是带有两个参数的闭包，Result是初始值或迭代器的结果，Element是集合中的下一个元素。 Reduce on Array1let numbers = [1,2,3,4,5,6]2let sum = numbers.reduce(0) &#123; x, y in3 x + y4&#125;5print(sum) 简化版本：使用$0代表result 1let reducedSum = numbers.reduce(0) &#123; $0 + $1 &#125;2print(reducedSum)3///等价4let reducedSum = numbers.reduce(0, +)5print(reducedSum) 乘法 1let produceNum = numbers.reduce(1) &#123; x, y in2 x * y3&#125;4print(produceNum)5///等价6let produceNum = numbers.reduce(1, *)7print(produceNum) Reduce + 连接字符串1let charactors = [\"abc\",\"def\",\"hijk\"]2let newCharactor = charactors.reduce(\"\", +)3print(newCharactor) // abcdefhijk Reduce on Dictionary12let dict = [\"A\": 20, \"B\": 100]34// Reduce on value5let reducedNum = dict.reduce(5) &#123; result, dic in6 return result + dic.value7&#125;8print(\"reduc on value is \\(reducedNum)\") 9// reduc on value is 1251011// Reduce on key12let reducedName = dict.reduce(\"Charactor are \") &#123; (result, dic) in13 return result + dic.key + \" \"14&#125;15print(\"reduce on key is &lt;\\(reducedName)&gt;\") 16//reduce on key is &lt;Charactor are A B &gt; 简化 12let reducedNameOnDic = dict.reduce(\"Charater are \") &#123; $0 + $1.key + \" \"&#125; Reduce on Set1// Reduce on Set2let lengthMeters = [3.4,1.6]3let reducedMeters = lengthMeters.reduce(0.0) &#123;4 $0 + $15&#125;6print(\"reduced meters :\\(reducedMeters)\") // 5.0 FlatMapFlatmap is used to flatten a collection of collections . But before flattening the collection, we can apply map to each elements. Apple docs says: Returns an array containing the concatenated results of calling the given transformation with each element of this sequence. Flatmap用于展平集合的集合。 但是在展平集合之前，我们可以将map应用于每个集合元素。 1let charaters = [\"abc\",\"def\",\"ghi\"]2let newCharaters = charaters.flatMap &#123; $0 &#125;3print(newCharaters)4//[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"]56let codes = [[\"abc\",\"def\",\"ghi\"], [\"jkl\",\"mno\",\"pqr\"],[\"stu\",\"vwx\",\"yz\"] ]7let newCodes = codes.flatMap &#123;$0.map &#123; $0 &#125; &#125;8print(newCodes)9// [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\"] nil1let nilArray = [2,3,nil]2print(nilArray.flatMap &#123; $0 &#125;) // [2,3]3// warning: 'flatMap' is deprecated: Please use compactMap(_:) for the case where closure returns an optional value4print(nilArray.compactMap &#123; $0 &#125;) // [2,3]","categories":[],"tags":[]}]}