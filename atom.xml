<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>明日危机</title>
  
  <subtitle>iOS &amp; Swifter</subtitle>
  <link href="https://mingriweiji-github.github.io/atom.xml" rel="self"/>
  
  <link href="https://mingriweiji-github.github.io/"/>
  <updated>2020-07-04T02:44:09.283Z</updated>
  <id>https://mingriweiji-github.github.io/</id>
  
  <author>
    <name>KM</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(一)Flutter初体验</title>
    <link href="https://mingriweiji-github.github.io/2020/06/30/(%E4%B8%80)Flutter%E5%B8%83%E5%B1%80/"/>
    <id>https://mingriweiji-github.github.io/2020/06/30/(%E4%B8%80)Flutter%E5%B8%83%E5%B1%80/</id>
    <published>2020-06-30T15:13:45.000Z</published>
    <updated>2020-07-04T02:44:09.283Z</updated>
    
    
    <summary type="html">Flutter布局
2020.6.29日更新
2020.5.29日更新
实现布局如下


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72


/// Line 3
new Container(
  margin: const Edge</summary>
    
    
    
    <category term="Flutter" scheme="https://mingriweiji-github.github.io/categories/Flutter/"/>
    
    
    <category term="Flutter专题" scheme="https://mingriweiji-github.github.io/tags/Flutter%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>(八)URLProtocol源码</title>
    <link href="https://mingriweiji-github.github.io/2020/06/30/(%E5%85%AB)URLProtocol%E6%BA%90%E7%A0%81/"/>
    <id>https://mingriweiji-github.github.io/2020/06/30/(%E5%85%AB)URLProtocol%E6%BA%90%E7%A0%81/</id>
    <published>2020-06-30T15:13:45.000Z</published>
    <updated>2020-06-29T15:17:22.000Z</updated>
    
    
    <summary type="html">URLProtocol源码简析
swift标准库URLProtocol地址

一 、 URLProtocol初始化
1.1通过URLRequest初始化protocol
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27


open class URLProtocol : NSObject {

    private static var _registeredProtocolClasses = [AnyClass]()
    private static var _classesLock = N</summary>
    
    
    
    <category term="源码" scheme="https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Swift专题" scheme="https://mingriweiji-github.github.io/tags/Swift%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>(七)Alamfire源码</title>
    <link href="https://mingriweiji-github.github.io/2020/06/30/(%E4%B8%83)Alamfire%E6%BA%90%E7%A0%81/"/>
    <id>https://mingriweiji-github.github.io/2020/06/30/(%E4%B8%83)Alamfire%E6%BA%90%E7%A0%81/</id>
    <published>2020-06-30T02:13:45.000Z</published>
    <updated>2020-06-29T15:16:06.000Z</updated>
    
    
    <summary type="html">Alamfire Github地址
1、Request分析
Request准守的Protocol
 * Equatable
   
   
 * Hashable
   
   
 * CustomStringConvertible
   
   
 * Downloadable
   
   
 * UploadableConvertible
   
   

Equatable
1
2
3
4
5


extension Request: Equatable {
    public static func ==(lhs: Request, rhs: Request) -&gt; Bool {
</summary>
    
    
    
    <category term="源码" scheme="https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Swift专题" scheme="https://mingriweiji-github.github.io/tags/Swift%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>(六)Kingfisher源码</title>
    <link href="https://mingriweiji-github.github.io/2020/06/30/(%E5%85%AD)Kingfisher%E6%BA%90%E7%A0%81/"/>
    <id>https://mingriweiji-github.github.io/2020/06/30/(%E5%85%AD)Kingfisher%E6%BA%90%E7%A0%81/</id>
    <published>2020-06-30T01:13:45.000Z</published>
    <updated>2020-06-29T15:16:03.000Z</updated>
    
    
    <summary type="html">Kingfisher源码
Kingfisher3架构
kf命名空间
 * 类 Kingfisher 是一个范型类，类型是 Base 
 * 协议 KingfisherCompatible，声明属性 kf，类型是范型 CompatibleType 。并要求遵守协议的一方，实现该属性的 get 方法。
 * 协议扩展中，协议自身实现了属性。这样就不必在每个遵守该协议的类里实现该属性了。
 * 协议里的 kf 是一个 Kingfisher 类的实例，调用的方法是 Kingfisher 类的方法。
 * 根据类型的不同，调用不同类型里的方法。如：对应 Image/ImageView / Button </summary>
    
    
    
    <category term="源码" scheme="https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Swift专题" scheme="https://mingriweiji-github.github.io/tags/Swift%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>(五)Swift内存布局初探</title>
    <link href="https://mingriweiji-github.github.io/2020/06/25/(%E4%BA%94)Swift%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%88%9D%E6%8E%A2/"/>
    <id>https://mingriweiji-github.github.io/2020/06/25/(%E4%BA%94)Swift%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%88%9D%E6%8E%A2/</id>
    <published>2020-06-25T03:13:45.000Z</published>
    <updated>2020-06-29T11:50:00.000Z</updated>
    
    
    <summary type="html">Swift内存布局初探
enum
问题实际分配内存为何是25？

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20


///带有关联值的枚举
enum TestEnum {
    case t1(Int, Int, Int)
    case t2(Int, Int)
    case t3(Int)
    case t4(Bool)
}
print(MemoryLayout&lt;TestEnum&gt;.alignment)//Int类型内存对齐：8
print(MemoryLayout&lt;TestEnum&gt;.size)//实际大小:24 + 1</summary>
    
    
    
    <category term="Swift" scheme="https://mingriweiji-github.github.io/categories/Swift/"/>
    
    
    <category term="Swift专题" scheme="https://mingriweiji-github.github.io/tags/Swift%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://mingriweiji-github.github.io/2020/06/18/(%E4%B9%9D)Swift%20%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://mingriweiji-github.github.io/2020/06/18/(%E4%B9%9D)Swift%20%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-06-17T16:09:33.000Z</published>
    <updated>2020-06-17T16:09:33.000Z</updated>
    
    
    <summary type="html">Swift5 字符串String
Swift version 5.2

Xcode11

1


let str = &quot;WhelloKitty&quot;


字符串截取前n个字符
1
2
3
4
5


let subStr1 = String(str.dropFirst())
print(subStr1) // helloKitty
let subStr2 = String(str.dropFirst(6))
print(subStr2) // Kitty



字符串截取?前的一部分
1
2
3
4
5
6
7


if let index = path.firstIndex(of: &quot;?&quot;) {</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>(四)Swift标准库源码</title>
    <link href="https://mingriweiji-github.github.io/2020/04/18/(%E5%9B%9B)Swift%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81/"/>
    <id>https://mingriweiji-github.github.io/2020/04/18/(%E5%9B%9B)Swift%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81/</id>
    <published>2020-04-18T02:13:45.000Z</published>
    <updated>2020-06-29T11:49:30.000Z</updated>
    
    
    <summary type="html">Swift标准库源码
 * Swift.org
 * Github开源地址  *  1、下载后的路径使用BBEdit查看所有标准库：stdlib/public/core/
    *  2、网页查看：https://github.com/apple/swift/tree/master/stdlib/public/core
   
   

如何阅读 Swift 标准库中的源码 | Swift源码地址
00关键词
 * Array解读 | FFIB-LeetCode | ContiguousArray | ContiguousArray喵神解读
   
   
 * Sequence解读 | C</summary>
    
    
    
    <category term="Swift" scheme="https://mingriweiji-github.github.io/categories/Swift/"/>
    
    
    <category term="Swift专题" scheme="https://mingriweiji-github.github.io/tags/Swift%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>(三)Swift集合源码</title>
    <link href="https://mingriweiji-github.github.io/2020/04/18/(%E4%B8%89)Swift%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    <id>https://mingriweiji-github.github.io/2020/04/18/(%E4%B8%89)Swift%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/</id>
    <published>2020-04-18T00:08:23.000Z</published>
    <updated>2020-06-29T11:47:35.000Z</updated>
    
    
    <summary type="html">Swift Collections
使用篇
1、Array
数组Array的两种for循环
只遍历value

1
2
3


for item in array {
  print(item)
}


快速枚举数组，用元祖(index, value)接收

1
2
3


for (index, value) in array.enumerated() {
  print(index, value)
}


array.enumerated() + map 快速枚举

1
2
3
4
5


let nums = [1,2,3,4,5]
let newNums = nums.enumerat</summary>
    
    
    
    <category term="Swift" scheme="https://mingriweiji-github.github.io/categories/Swift/"/>
    
    
    <category term="Swift专题" scheme="https://mingriweiji-github.github.io/tags/Swift%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>(二)Swift函数式编程</title>
    <link href="https://mingriweiji-github.github.io/2020/02/20/(%E4%BA%8C)Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://mingriweiji-github.github.io/2020/02/20/(%E4%BA%8C)Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2020-02-20T02:13:45.000Z</published>
    <updated>2020-06-29T11:47:40.000Z</updated>
    
    
    <summary type="html">Functional Programming in Swift
函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10

在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。

不变性和副作用
无论您首先学习哪种编程语言，您可能要学习的最初概念之一就是变量代表数据或状态。如果您退一步考虑一下这个想法，变量似乎很奇怪。

术语“变量”表示随程序运行而变化的数量。从数学角度考虑数量问题，您已将时间作为软件行为的关键参数。通过更改变量，可以创建可变状态。

为了进行演示，请将以下代码添加到playgrou</summary>
    
    
    
    <category term="Swift" scheme="https://mingriweiji-github.github.io/categories/Swift/"/>
    
    
    <category term="Swift专题" scheme="https://mingriweiji-github.github.io/tags/Swift%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>(一)Swift备忘录</title>
    <link href="https://mingriweiji-github.github.io/2020/02/18/(%E4%B8%80)Swift%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>https://mingriweiji-github.github.io/2020/02/18/(%E4%B8%80)Swift%E5%A4%87%E5%BF%98%E5%BD%95/</id>
    <published>2020-02-18T02:13:45.000Z</published>
    <updated>2020-06-29T11:46:09.000Z</updated>
    
    
    <summary type="html">SwiftTip
 * Flip the image: 翻转图片
 * Retrive the paths: 检索，重新获得

问题记录
 * 柯里化 什么意思
   
   
 * POP 与 OOP的区别
   
   
 * Any 与AnyObject 区别
   
   
 * rethrows 和 throws 有什么区别呢？
   
   
 * break return continue fallthough 在语句中的含义（switch、while、for）
   
   
 * 关键字
    * public open final
    * static class
 </summary>
    
    
    
    <category term="Swift" scheme="https://mingriweiji-github.github.io/categories/Swift/"/>
    
    
    <category term="Swift专题" scheme="https://mingriweiji-github.github.io/tags/Swift%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LookinLoader安装使用</title>
    <link href="https://mingriweiji-github.github.io/2020/01/20/LookinLoader%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://mingriweiji-github.github.io/2020/01/20/LookinLoader%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</id>
    <published>2020-01-20T02:13:45.000Z</published>
    <updated>2020-05-01T12:45:25.000Z</updated>
    
    
    <summary type="html">Lookin查看自己的App
 * 1、Lookin下载
   
   
 * 2、pod添加：pod &#39;LookinServer&#39;, :configurations =&gt; [&#39;Debug&#39;]
   
   
 * 3、pod install
   
   
 * 4、打开mac上安装的Lookin
   
   

配合LookinLoader查看第三方App
官方：正常情况下，你无法将 LookinServer 嵌入到别人的 iOS App 里，因此你也就无法使用 Lookin 查看别人的 App。但我们也注意到有些第三方开发者通过某些方式实现了向别人的 App 中注入 Framework</summary>
    
    
    
    
    <category term="iOS" scheme="https://mingriweiji-github.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Dyld源码阅读</title>
    <link href="https://mingriweiji-github.github.io/2020/01/15/Dyld%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://mingriweiji-github.github.io/2020/01/15/Dyld%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2020-01-15T02:13:45.000Z</published>
    <updated>2020-05-01T12:47:36.000Z</updated>
    
    
    <summary type="html">Dyld源码阅读
 * Version：dyld-551.4
 * Lauange：C++
 * load()调用路径：3566行  * load()-&gt;loadPhase0()-&gt;loadPhase1()-&gt;loadPhase2()-&gt;loadPhase4()-&gt;loadPhase5()打开或检查已经存在的动态库：dyld3::findInSharedCacheImage-&gt;loadPhase5load()-&gt;loadPhase5open()-&gt;loadPhase6()-&gt;加载3种Mach-O文件
   
   

1、动态库路径
iOS越狱手机

 * 在Mac\iOS中，是使用了/usr</summary>
    
    
    
    <category term="源码" scheme="https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="iOS" scheme="https://mingriweiji-github.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS越狱初体验</title>
    <link href="https://mingriweiji-github.github.io/2020/01/15/iOS%E8%B6%8A%E7%8B%B1%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://mingriweiji-github.github.io/2020/01/15/iOS%E8%B6%8A%E7%8B%B1%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2020-01-15T02:13:45.000Z</published>
    <updated>2020-05-01T12:44:13.000Z</updated>
    
    
    <summary type="html">iOS越狱初体验
iOS越狱能做到什么？
 * 查看 第三方APP UI 排版方式、布局实现技术
 * 获取三方App内部资源 .assets/.plist/icon…
 * 修改APP 功能重新打包 (EX: 去广告)
 * 反编译推测原始工程代码内容
 * dump 出 .h 头文件 / keycahin / db

越狱环境
macOS 版本：10.15 Catalina
iOS 版本：iPhone 5s (iOS 9.0.1/ *完美越狱****必要**)
Cydia: Open SSH

逆向工程大致流程：
 1. 解密并导出应用程序、class-dump导出头文件
 2. 从当面界</summary>
    
    
    
    <category term="源码" scheme="https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="iOS" scheme="https://mingriweiji-github.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>算法实战</title>
    <link href="https://mingriweiji-github.github.io/2019/06/22/2020%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98100%E9%81%93/"/>
    <id>https://mingriweiji-github.github.io/2019/06/22/2020%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98100%E9%81%93/</id>
    <published>2019-06-21T19:18:15.000Z</published>
    <updated>2020-06-29T11:54:54.000Z</updated>
    
    
    <summary type="html">为什么学算法？
为什么要学习算法？
 * 算法是内功，决定你武功的高度
 * 算法能让你更好更快理解一门语言系统的设计理念
 * 算法能让你触类旁通
 * momo算法题：接雨水 反转链表II 旋转矩阵

主要算法
 * 基础技巧：分治、二分、贪心
 * 排序算法：快速排序、归并排序、计数排序
 * 搜索算法：回溯算法、递归、深度优先遍历，BFS广度优先遍历，二叉搜索树等
 * 图论：最短路径、最小生成树
 * 动态规划：背包问题、最长子序列

数据结构
 * 数组与链表：单 / 双向链表
 * 栈与队列
 * 哈希表
 * 堆：最大堆 ／ 最小堆
 * 树与图：最近公共祖先、并查集
 * 字</summary>
    
    
    
    <category term="算法" scheme="https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://mingriweiji-github.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础</title>
    <link href="https://mingriweiji-github.github.io/2019/06/22/2020%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://mingriweiji-github.github.io/2019/06/22/2020%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2019-06-21T18:18:15.000Z</published>
    <updated>2020-06-29T11:53:57.000Z</updated>
    
    
    <summary type="html">算法基础
为什么要学习算法？
 * 算法是内功，决定你武功的高度
   
   
 * 算法能让你更好更快理解一门语言系统的设计理念
   
   
 * 算法能让你触类旁通
   
   

1 、数组



1
2
3
4
5
6
7
8
9
10
11
12
13
14


func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
     var p1 = m - 1, p2 = n - 1
     var cur = m + n - 1
     while (p2 &gt;= 0) {
        </summary>
    
    
    
    <category term="算法" scheme="https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://mingriweiji-github.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构思想</title>
    <link href="https://mingriweiji-github.github.io/2019/06/22/2020%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://mingriweiji-github.github.io/2019/06/22/2020%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2019-06-21T17:18:15.000Z</published>
    <updated>2020-05-01T12:39:01.000Z</updated>
    
    
    <summary type="html">第一篇数据结构
数组和链表





思考题： 1.如何分别用链表和数组实现LRU缓冲淘汰策略？
1）什么是缓存？

 * 缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。

什么是C CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存</summary>
    
    
    
    <category term="算法" scheme="https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="java" scheme="https://mingriweiji-github.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>红黑树前世今生</title>
    <link href="https://mingriweiji-github.github.io/2019/06/08/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>https://mingriweiji-github.github.io/2019/06/08/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2019-06-08T02:13:45.000Z</published>
    <updated>2020-05-01T13:42:10.000Z</updated>
    
    
    <summary type="html">红黑树前世今生
关键词：二叉搜索树、前驱节点、后继节点、B树、红黑树

什么是B树
前世
B树是一种相对于来说特殊二叉搜索树，多用于数据库和文件搜索系统中。

n阶B树的性质
B树是一种平衡的多路搜索树，拥有平衡二叉树的一些特性，与平衡二叉树的最大区别在于每个节点不再是只能存储一个元素，而且每个节点可以拥有多个子节点而像二叉平衡树只能拥有两个。

 1. B树每个节点最多可以存储超过2个元素，可以拥有超过2个子节点
 2. B树每个子节点的子树高度一致
 3. B树和二叉搜索树一样，左子树&lt;根节点&lt;右子树
 4. 根节点元素个数: 1≤ X ≤ n - 1
 5. 非根节点元素个数: n/2 </summary>
    
    
    
    <category term="算法" scheme="https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="java" scheme="https://mingriweiji-github.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>二叉树今生</title>
    <link href="https://mingriweiji-github.github.io/2019/06/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>https://mingriweiji-github.github.io/2019/06/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2019-06-06T02:13:45.000Z</published>
    <updated>2020-05-01T12:39:39.000Z</updated>
    
    
    <summary type="html">二叉树今生
为什么会有二叉树这种数据结构？

思考一个问题：如果一个集合中有42亿个元素，让你从这42亿个元素中搜索某一个元素，你需要多少次操作？

如果使用数组链表的话最多可能需要42亿次比较，而如果使用二叉树我们只需要32次比较即可，这就是二叉树存在的价值。Java中的HashSet使用的就是二叉树

前驱与后继
前驱节点
 1. 若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode）
    
    
 2. 若一个节点没有左子树，那么判断该节点和其父节点的关系 
    
    2.1 若该节点是其父节点的右边孩子，</summary>
    
    
    
    <category term="算法" scheme="https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="java" scheme="https://mingriweiji-github.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>iOS汇编基础</title>
    <link href="https://mingriweiji-github.github.io/2018/12/02/iOS%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    <id>https://mingriweiji-github.github.io/2018/12/02/iOS%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</id>
    <published>2018-12-02T03:15:40.000Z</published>
    <updated>2020-05-01T12:34:27.000Z</updated>
    
    
    <summary type="html">iOS汇编基础
x86_64汇编
X84中原有8个32位通用寄存器%eax，%ebx，%ecx，%edx，%esi，%edi，%ebp，%esp,

X86_64中分别被扩展为64位，并且多了8个寄存器。因此X86_64的寄存器如下：

 * rax, eax, ax, ah, al;
 * rbx, ebx, bx, bh, bl;
 * rcx, ecx, cx, ch, cl;
 * rdx, edx, dx, dh, dl;
 * rsi, esi, si;
 * rdi, edi, di;
 * rbp, ebp;
 * rsp, esp;
 * r8-r15;

GCC中对这些寄存</summary>
    
    
    
    <category term="逆向" scheme="https://mingriweiji-github.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="iOS" scheme="https://mingriweiji-github.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS图像优化技巧</title>
    <link href="https://mingriweiji-github.github.io/2018/12/01/iOS%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <id>https://mingriweiji-github.github.io/2018/12/01/iOS%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</id>
    <published>2018-12-01T03:15:40.000Z</published>
    <updated>2020-05-01T12:41:59.000Z</updated>
    
    
    <summary type="html">iOS图像优化技巧
 * 1、如何处理大尺寸图片？
   
   
 * 2、如何处理瀑布流图片占用大量内存的问题？
   
   
 * 3、如何处理多张图片上传和下载问题？
   
   

1、处理大尺寸图片
那么，什么时候对图像进行渲染优化才有意义呢？

当它明显大于 UIImageView 显示尺寸的时候

想要完整渲染这张宽高为 12,000 px 的图片，需要高达 20 MB 的空间。对于当今的硬件来说，你可能不会在意这么少兆字节的占用。但那只是它压缩后的尺寸。要展示它，UIImageView 首先需要把 JPEG 数据解码成位图（bitmap），如果要在一个 UIImageVi</summary>
    
    
    
    <category term="图像" scheme="https://mingriweiji-github.github.io/categories/%E5%9B%BE%E5%83%8F/"/>
    
    
    <category term="iOS" scheme="https://mingriweiji-github.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
