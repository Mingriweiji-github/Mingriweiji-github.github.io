<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        多线程 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> iOS &amp; Swifter </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/" />
        </div>
        <div class="name">
            <i>KM</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、你理解的多线程？并发和串行，同步和异步"><span class="toc-text">1、你理解的多线程？并发和串行，同步和异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、iOS多线程有哪些？常用哪个？"><span class="toc-text">2、iOS多线程有哪些？常用哪个？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCD-的队列类型有哪些？"><span class="toc-text">GCD 的队列类型有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OperationQueue-和-GCD-的区别？"><span class="toc-text">OperationQueue 和 GCD 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何用gcd实现以下功能？"><span class="toc-text">如何用gcd实现以下功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全是什么？如何处理线程安全的问题？"><span class="toc-text">线程安全是什么？如何处理线程安全的问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自旋锁和互斥锁如何选择？"><span class="toc-text">自旋锁和互斥锁如何选择？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS线程同步方案性能比较"><span class="toc-text">iOS线程同步方案性能比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何实现多度单写？"><span class="toc-text">如何实现多度单写？</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> iOS &amp; Swifter </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        多线程
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-03-11 20:34:15</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h2 id="1、你理解的多线程？并发和串行，同步和异步"><a href="#1、你理解的多线程？并发和串行，同步和异步" class="headerlink" title="1、你理解的多线程？并发和串行，同步和异步"></a>1、<strong>你理解的多线程？并发和串行，同步和异步</strong></h2><ul>
<li>同步和异步的区别: 是否开辟新的线程，同步只能在当前线程执行任务，异步可以再新的线程执行任务</li>
<li>串行和并发的区别是任务执行的顺序，串行任务只能顺序执行，并发可以多个任务同时执行。</li>
</ul>
<h2 id="2、iOS多线程有哪些？常用哪个？"><a href="#2、iOS多线程有哪些？常用哪个？" class="headerlink" title="2、iOS多线程有哪些？常用哪个？"></a>2、iOS多线程有哪些？常用哪个？</h2><ul>
<li>NSThread、GCD/NSOperationQueue</li>
<li>常用GCD/NSOperation</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c93945fd31377?w=1534&h=764&f=png&s=169325" alt="img"></p>
<p>pthread NSThread GCD NSoperationEnter a caption for this image (optional)</p>
<h2 id="GCD-的队列类型有哪些？"><a href="#GCD-的队列类型有哪些？" class="headerlink" title="GCD 的队列类型有哪些？"></a><strong>GCD 的队列类型有哪些？</strong></h2><h2 id="OperationQueue-和-GCD-的区别？"><a href="#OperationQueue-和-GCD-的区别？" class="headerlink" title="OperationQueue 和 GCD 的区别？"></a><strong>OperationQueue 和 GCD 的区别？</strong></h2><ol>
<li>GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择；</li>
<li>在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)；</li>
<li>NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行；</li>
<li>我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样子能比GCD更加有效地掌控我们执行的后台任务；</li>
<li>在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码；</li>
<li>我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。</li>
</ol>
<p><strong>总的来说，Operation queue 提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。</strong></p>
<p><strong>从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。</strong></p>
<h2 id="如何用gcd实现以下功能？"><a href="#如何用gcd实现以下功能？" class="headerlink" title="如何用gcd实现以下功能？"></a><strong>如何用gcd实现以下功能？</strong></h2><ul>
<li><strong>异步并发执行任务1、任务2</strong> </li>
<li><strong>等任务1、任务2都执行完毕后，再回到主线程执行任务3</strong></li>
</ul>
<h2 id="线程安全是什么？如何处理线程安全的问题？"><a href="#线程安全是什么？如何处理线程安全的问题？" class="headerlink" title="线程安全是什么？如何处理线程安全的问题？"></a><strong>线程安全是什么？如何处理线程安全的问题？</strong></h2><blockquote>
<p>我们一般通过线程同步方案如加锁的方式来实现线程的安全</p>
<p><a href="https://bestswifter.com/ios-lock/" target="_blank" rel="noopener">iOS锁的原理</a> |   <a href="https://www.jianshu.com/p/e56c3d28e77d" target="_blank" rel="noopener">深入浅出iOS系统内核-同步机制</a></p>
</blockquote>
<ul>
<li><strong>os_unfair_lock：iOS10开始os_unfair_lock来替代OSSpinLock, 等待锁的线程会进入休眠不占用CPU资源， 这个os_unfair_lock解决了优先级翻转问题。</strong></li>
<li><strong>OSSpinLock: 自旋锁，线程忙等一直占用CUP资源，不安全因为可能出现优先级翻转的可能</strong></li>
<li><strong>dispatch_semaphore：信号量为1的semaphore也可以看做是锁</strong></li>
<li><strong>pthread_mutex：mutex是互斥锁，等待锁的线程处于休眠状态，pthread_mutex是递归锁，可以递归调用。</strong></li>
<li><strong>使用GCD的串行队列也可以实现锁的功能</strong></li>
<li><strong>NSLock是对metex互斥锁的封装，NSRecurisiveLock也是对metex的递归封装，API和NSLock一直。</strong></li>
<li>NSCondition</li>
<li>NSConditionLock</li>
<li><strong>@synchorized也是mutex的递归封装，@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作。</strong></li>
</ul>
<h2 id="自旋锁和互斥锁如何选择？"><a href="#自旋锁和互斥锁如何选择？" class="headerlink" title="自旋锁和互斥锁如何选择？"></a><strong>自旋锁和互斥锁如何选择？</strong></h2><p><strong>自旋锁OSSpinLock：当线程获取锁，其他等待锁的线程会忙等一直占用CPU,自旋锁有优先级翻转的可能性，所以苹果已经弃用自旋锁OSSpinLock改用os_unfair_lock.</strong></p>
<p><strong>互斥锁mutext：阻塞线程并休眠，其他线程才能正常访问，用互斥的方式来保证线程的安全。</strong></p>
<p><strong>递归锁：顾名思义，可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。</strong></p>
<ul>
<li><strong>什么情况使用自旋锁比较划算？</strong> <ul>
<li>预计线程等待锁的时间很短 </li>
<li>加锁的代码（临界区）经常被调用，但竞争情况很少发生 </li>
<li>CPU资源不紧张 多核处理器</li>
</ul>
</li>
<li><strong>什么情况使用互斥锁比较划算？</strong> <ul>
<li>预计线程等待锁的时间较长 </li>
<li>单核处理器 临界区有IO操作 </li>
<li>临界区代码复杂或者循环量大 </li>
<li>临界区竞争非常激烈 </li>
</ul>
</li>
</ul>
<ul>
<li><strong>追问二：使用以上锁需要注意哪些？</strong> </li>
<li><strong>追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！</strong></li>
</ul>
<h2 id="iOS线程同步方案性能比较"><a href="#iOS线程同步方案性能比较" class="headerlink" title="iOS线程同步方案性能比较"></a>iOS线程同步方案<strong>性能</strong>比较</h2><p><strong>性能从高到低排序:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">os_unfair_lock</span></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">OSSpinLock</span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">dispatch_semaphore</span></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">pthread_mutex</span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">dispatch_queue(DISPATCH_QUEUE_SERIAL)</span></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSLock</span></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSCondition</span></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">pthread_mutex(recursive)</span></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSRecursiveLock</span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">NSConditionLock</span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@synchronized</span></pre></td></tr></table></figure>


<h2 id="如何实现多度单写？"><a href="#如何实现多度单写？" class="headerlink" title="如何实现多度单写？"></a><code>如何实现多度单写？</code></h2><p><strong>1、</strong><code>pthread_rwlock</code><strong>读写锁-等待锁的线程进入休眠</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/6/170ab7a1980f8f16?w=830&h=956&f=png&s=318721" alt="img"></p>
<p>pthread_rwlockEnter a caption for this image (optional)</p>
<p>‌</p>
<p><strong>2、dispatch_barrier_async</strong></p>
<ul>
<li>这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的 </li>
<li>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/6/170ab7b55ae20eaf?w=1966&h=674&f=png&s=176023" alt="img"></p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud" target="_blank" rel="noopener">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = ""
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
