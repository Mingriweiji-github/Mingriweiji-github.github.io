{"meta":{"title":"明日危机","subtitle":"iOS & Swifter","description":"","author":"KM","url":"https://mingriweiji-github.github.io","root":"/"},"pages":[{"title":"about","date":"2020-05-01T08:52:07.000Z","updated":"2020-05-01T08:52:30.740Z","comments":true,"path":"about/index.html","permalink":"https://mingriweiji-github.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-01T08:50:09.000Z","updated":"2020-05-01T08:51:09.306Z","comments":true,"path":"categories/index.html","permalink":"https://mingriweiji-github.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-01T11:19:11.000Z","updated":"2020-05-01T11:25:43.087Z","comments":true,"path":"tags/index.html","permalink":"https://mingriweiji-github.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Flutter布局","slug":"Flutter布局","date":"2020-05-28T23:52:36.004Z","updated":"2020-05-28T23:52:47.289Z","comments":true,"path":"2020/05/29/Flutter布局/","link":"","permalink":"https://mingriweiji-github.github.io/2020/05/29/Flutter%E5%B8%83%E5%B1%80/","excerpt":"","text":"Flutter布局实现布局如下 /// Line 3 new Container( margin: const EdgeInsets.fromLTRB(6.0, 24.0, 6.0, 30.0), child: new RoundInnerSquareBox( child: new Container( padding: const EdgeInsets.fromLTRB(24.0, 28.0, 24.0, 12.0), width: double.infinity, child: new Column( mainAxisAlignment: MainAxisAlignment.start, crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget>[ new Text( \"Unit 1 Lesson 3 About animal\", style: new TextStyle( fontSize: 20.0, fontFamily: \"Round\", color: Colors.white, ), ), new Container( margin: const EdgeInsets.only(top: 5.0, bottom: 13.0), child: new Image.asset( \"assets/images/publish_work_line.png\"), ), new Wrap( alignment: WrapAlignment.start, children: &lt;Widget>[ new WorkTotalItem( title: \"课文跟读 11\", ), new WorkTotalItem( title: \"课文跟读 22\", ), new WorkTotalItem( title: \"课文跟读 33\", ), new WorkTotalItem( title: \"课文跟读 44\", ), ], ), new Container( margin: const EdgeInsets.only(left: 178.0), child: new Stack( children: &lt;Widget>[ new Image.asset( \"assets/images/publish_work_sign.png\"), new Positioned( left: 4.0, top: 4.0, child: new Text( \"预习\", style: new TextStyle( fontSize: 14.0, color: Colors.white), ), ) ], ), ), new Container( alignment: Alignment.topRight, child: new Text( \"明天12:00截止\", style: new TextStyle( fontSize: 12.0, color: const Color(0xFFFFC1C1)), ), ), ], ), ), ), ),","categories":[],"tags":[]},{"title":"Swift标准库源码","slug":"Swift标准库源码","date":"2020-04-18T02:13:45.000Z","updated":"2020-05-01T12:54:08.124Z","comments":true,"path":"2020/04/18/Swift标准库源码/","link":"","permalink":"https://mingriweiji-github.github.io/2020/04/18/Swift%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81/","excerpt":"","text":"Swift标准库源码 Swift.org Github开源地址 1、下载后的路径使用BBEdit查看所有标准库：stdlib/public/core/ 2、网页查看：https://github.com/apple/swift/tree/master/stdlib/public/core 如何阅读 Swift 标准库中的源码 | Swift源码地址00关键词 Array解读 | FFIB-LeetCode | ContiguousArray | ContiguousArray喵神解读 Sequence解读 | Collection解读 | optional解读 | map源码解读 | ASM FOR ARM64 | Character源码 | String源码 | 如何判断字符串为空？ | 替换特殊字符 Algorithm源码min()public func min&lt;T: Comparable>(_ x: T, _ y: T) -> T { // In case `x == y` we pick `x`. // `(min(x, y), max(x, y))` should return `(x, y)` in case `x == y`. return y &lt; x ? y : x } public func min&lt;T: Comparable>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T { var minValue = min(min(x, y), z) // In case `value == minValue`, we pick `minValue`. See min(_:_:). for value in rest where value &lt; minValue { minValue = value } return minValue } max()public func max&lt;T: Comparable>(_ x: T, _ y: T) -> T { // In case `x == y`, we pick `y`. See min(_:_:). return y >= x ? y : x } public func max&lt;T: Comparable>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T { var maxValue = max(max(x, y), z) // In case `value == maxValue`, we pick `value`. See min(_:_:). for value in rest where value >= maxValue { maxValue = value } return maxValue } EnumeratedSequencepublic struct EnumeratedSequence&lt;Base: Sequence> { internal var _base: Base internal init(_base: Base) { self._base = _base } } extension EnumeratedSequence { /// var iterator = [\"foo\", \"bar\"].enumerated().makeIterator() /// iterator.next() // (0, \"foo\") /// iterator.next() // (1, \"bar\") /// iterator.next() // nil /// To create an instance, call `enumerated().makeIterator()` on a sequence or collection. public struct Iterator { internal var _base: Base.Iterator internal var _count: Int internal init(_base: Base.Iterator) { self._base = _base self._count = 0 } } } extension EnumeratedSequence.Iterator: IteratorProtocol, Sequence { /// The type of element returned by `next()`. public typealias Element = (offset: Int, element: Base.Element) public mutating func next() -> Element? { guard let b = _base.next() else { return nil } let result = (offset: _count, element: b) _count += 1 return result } } extension EnumeratedSequence: Sequence { /// Returns an iterator over the elements of this sequence. public __consuming func makeIterator() -> Iterator { return Iterator(_base: _base.makeIterator()) } } Sequence源码IteratorProtocolpublic protocol IteratorProtocol { associatedtype Element mutating func next() -> Element? } “序列和迭代器非常相似，你可能会问，为什么它们会被分为不同的类型？为什么不能直接把 IteratorProtocol 的功能包含到 Sequence 中呢？” func fibsIterator() -> AnyIterator&lt;Int> { var state = (0, 1) return AnyIterator { let upcomingNumber = state.0 state = (state.1, state.0 + state.1) return upcomingNumber } } Sequencepublic protocol Sequence { associatedtype Element associatedtype Iterator: IteratorProtocol where Iterator.Element == Element __consuming func makeIterator() -> Iterator var underestimatedCount: Int { get } func _customContainsEquatableElement( _ element: Element ) -> Bool? __consuming func _copyToContiguousArray() -> ContiguousArray&lt;Element> __consuming func _copyContents( initializing ptr: UnsafeMutableBufferPointer&lt;Element> ) -> (Iterator,UnsafeMutableBufferPointer&lt;Element>.Index) func withContiguousStorageIfAvailable&lt;R>( _ body: (UnsafeBufferPointer&lt;Element>) throws -> R ) rethrows -> R? } Sequence实现map()extension Sequence { @inlinable public func map&lt;T>( _ transform: (Element) throws -> T ) rethrows -> [T] { let initialCapacity = underestimatedCount var result = ContiguousArray&lt;T>() result.reserveCapacity(initialCapacity) var iterator = self.makeIterator() // Add elements up to the initial capacity without checking for regrowth. for _ in 0..&lt;initialCapacity { result.append(try transform(iterator.next()!)) } // Add remaining elements, if any. while let element = iterator.next() { result.append(try transform(element)) } return Array(result) } } filter()extension Sequence { @inlinable public __consuming func filter( _ isIncluded: (Element) throws -> Bool ) rethrows -> [Element] { return try _filter(isIncluded) } @_transparent public func _filter( _ isIncluded: (Element) throws -> Bool ) rethrows -> [Element] { var result = ContiguousArray&lt;Element>() var iterator = self.makeIterator() while let element = iterator.next() { if try isIncluded(element) { result.append(element) } } return Array(result) } } forEach()extension Sequence { @_semantics(\"sequence.forEach\") @inlinable public func forEach( _ body: (Element) throws -> Void ) rethrows { for element in self { try body(element) } } } split()extension Sequence where Element: Equatable { @inlinable public __consuming func split( separator: Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true ) -> [ArraySlice&lt;Element>] { return split( maxSplits: maxSplits, omittingEmptySubsequences: omittingEmptySubsequences, whereSeparator: { $0 == separator }) } } IteratorSequence()public struct IteratorSequence&lt;Base: IteratorProtocol> { @usableFromInline internal var _base: Base /// Creates an instance whose iterator is a copy of `base`. @inlinable public init(_ base: Base) { _base = base } } extension IteratorSequence: IteratorProtocol, Sequence { /// Advances to the next element and returns it, or `nil` if no next element /// exists. /// /// Once `nil` has been returned, all subsequent calls return `nil`. /// /// - Precondition: `next()` has not been applied to a copy of `self` /// since the copy was made. @inlinable public mutating func next() -> Base.Element? { return _base.next() } } SequenceAlgorithms源码enumerated()extension Sequence { @inlinable // protocol-only public func enumerated() -> EnumeratedSequence&lt;Self> { return EnumeratedSequence(_base: self) } min()extension Sequence { public func min( by areInIncreasingOrder: (Element, Element) throws -> Bool ) rethrows -> Element? { var it = makeIterator() guard var result = it.next() else { return nil } while let e = it.next() { if try areInIncreasingOrder(e, result) { result = e } } return result } } max()extension Sequence { public func max( by areInIncreasingOrder: (Element, Element) throws -> Bool ) rethrows -> Element? { var it = makeIterator() guard var result = it.next() else { return nil } while let e = it.next() { if try areInIncreasingOrder(result, e) { result = e } } return result } } contains()extension Sequence { @inlinable public func contains( where predicate: (Element) throws -> Bool ) rethrows -> Bool { for e in self { if try predicate(e) { return true } } return false } @inlinable public func allSatisfy( _ predicate: (Element) throws -> Bool ) rethrows -> Bool { return try !contains { try !predicate($0) } } } extension Sequence where Element: Equatable { @inlinable public func contains(_ element: Element) -> Bool { if let result = _customContainsEquatableElement(element) { return result } else { return self.contains { $0 == element } } } } reduce()函数extension Sequence { @inlinable public func reduce&lt;Result>( _ initialResult: Result, _ nextPartialResult: (_ partialResult: Result, Element) throws -> Result ) rethrows -> Result { var accumulator = initialResult for element in self { accumulator = try nextPartialResult(accumulator, element) } return accumulator } @inlinable public func reduce&lt;Result>( into initialResult: __owned Result, _ updateAccumulatingResult: (_ partialResult: inout Result, Element) throws -> () ) rethrows -> Result { var accumulator = initialResult for element in self { try updateAccumulatingResult(&amp;accumulator, element) } return accumulator } } reversed()extension Sequence { @inlinable public __consuming func reversed() -> [Element] { var result = Array(self) let count = result.count for i in 0..&lt;count/2 { result.swapAt(i, count - ((i + 1) as Int)) } return result } } flatMap()extension Sequence { @inlinable public func flatMap&lt;SegmentOfResult: Sequence>( _ transform: (Element) throws -> SegmentOfResult ) rethrows -> [SegmentOfResult.Element] { var result: [SegmentOfResult.Element] = [] for element in self { result.append(contentsOf: try transform(element)) } return result } } 03 zip源码zip使用let words = [\"one\", \"two\", \"three\", \"four\"] let numbers = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"] // 1.1、Array(zip())生成元组 let arr = Array(zip(words, numbers)) //1.2、zip+map生成元组 let a = zip(words, numbers).map { $0 } print(a)//\"[(\"one\", \"1\"), (\"two\", \"2\"), (\"three\", \"3\"), (\"four\", \"4\")]\\n\" //2、将两个数组合并成一个新数组 let b = [words, numbers].flatMap { $0 } print(b)//\"[\"one\", \"two\", \"three\", \"four\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\"]\\n\" let c = zip(words, numbers).flatMap { [$0, $1] } print(c) // \"[\"one\", \"1\", \"two\", \"2\", \"three\", \"3\", \"four\", \"4\"]\\n\" //3、将两个数组生成字典 let dic = Dictionary(uniqueKeysWithValues: zip(words, numbers)) print(dic)//[\"two\": \"2\", \"four\": \"4\", \"one\": \"1\", \"three\": \"3\"] zip源码public func zip&lt;Sequence1, Sequence2>( _ sequence1: Sequence1, _ sequence2: Sequence2 ) -> Zip2Sequence&lt;Sequence1, Sequence2> { return Zip2Sequence(sequence1, sequence2) } @frozen // generic-performance public struct Zip2Sequence&lt;Sequence1: Sequence, Sequence2: Sequence> { @usableFromInline // generic-performance internal let _sequence1: Sequence1 @usableFromInline // generic-performance internal let _sequence2: Sequence2 @inlinable // generic-performance internal init(_ sequence1: Sequence1, _ sequence2: Sequence2) { (_sequence1, _sequence2) = (sequence1, sequence2) } } extension Zip2Sequence { /// An iterator for `Zip2Sequence`. @frozen // generic-performance public struct Iterator { @usableFromInline // generic-performance internal var _baseStream1: Sequence1.Iterator @usableFromInline // generic-performance internal var _baseStream2: Sequence2.Iterator @usableFromInline // generic-performance internal var _reachedEnd: Bool = false @inlinable // generic-performance internal init( _ iterator1: Sequence1.Iterator, _ iterator2: Sequence2.Iterator ) { (_baseStream1, _baseStream2) = (iterator1, iterator2) } } } extension Zip2Sequence.Iterator: IteratorProtocol { public typealias Element = (Sequence1.Element, Sequence2.Element) @inlinable // generic-performance public mutating func next() -> Element? { if _reachedEnd { return nil } guard let element1 = _baseStream1.next(), let element2 = _baseStream2.next() else { _reachedEnd = true return nil } return (element1, element2) } } extension Zip2Sequence: Sequence { public typealias Element = (Sequence1.Element, Sequence2.Element) /// Returns an iterator over the elements of this sequence. @inlinable // generic-performance public __consuming func makeIterator() -> Iterator { return Iterator( _sequence1.makeIterator(), _sequence2.makeIterator()) } @inlinable // generic-performance public var underestimatedCount: Int { return Swift.min( _sequence1.underestimatedCount, _sequence2.underestimatedCount ) } 04050607080910集合协议Sequence: 如果让你设计Sequence类型，你会为它添加那些约束呢？如果你没有特别丰富的经验，最好的办法，还是去看看Swift官方的Sequence实现吧。还是那句话，源码之前，了无秘密。 Sequence是一个值类型当我们走近源代码之前，先来思考一个问题。一个最纯粹的“序列”，究竟意味着什么呢？通过前面两节内容我们知道，序列本身可以是有限的，也可以是无限的；可以是支持多次遍历的，也可以是只能遍历一次的。把这些约束摆在眼前，其实答案就很明显了： 序列的遍历只能单步向前； 序列表现的语义，是某种形式的值，它支持的各种访问操作应该是只读的； 如何以标准库的视角设计一个类型接下来，我们思考第二个问题。把序列作为一个标准库的组件进行设计的时候，我们应该从哪些方面来考虑呢？其实，这个问题可以进一步放大成：设计一个容器类型应该从哪些方面进行考虑呢？实际上，得益于编程语言自身的发展，关于标准库中容器类的设计，已经被人们总结出了一些规律。围绕着容器类，一共有三个大的概念，分别是： Container - 容器类型本身，它提供了元素的存储，并为各种不同容器（数组、链表、字典、树等等）的访问提供了一致的接口； Iterator - 与容器搭配工作的Iterator，它为用各种不同的形式遍历容器（向前、向后、随机访问）提供了一致的接口。通常，每一个Container都有它“御用”的Iterator，因为Iterator的各种实现需要对Container的内部构造了如指掌； Algorithm - 当Container和Iterator有了一致的接口之后，也就意味着对各种不同形式数据结构的访问都有了一致的访问方法，于是，我们就可以基于这些接口，来开发出重用度极高的通用算法，这些算法只基于通用接口描述的核心语义，而不与任何具体的数据结构相关； 基于上面这三个大的概念，我们可以进一步细化它们各自应该考虑的约束，也就是应该提供哪些接口： 对于Container而言，我们应该回答下面几个“它应该”的问题： 暴露哪些和容器自身有关的类型； 如何初始化； 支持哪些赋值方式； 提供哪些和尺寸有关的接口； 有哪些直接访问元素的方法； 可以获取哪些形式的Iterator； 支持哪些形式的比较； 提供哪些以只读方式访问元素的接口； 提供哪些增、删、改元素的接口； 对于Iterator而言，我们应该回答下面几个“它应该”的问题： 暴露哪些和Iterator自身有关的类型； 提供哪些在Container中移动位置的接口； 提供哪些访问Container数据成员的接口； Sequence.swift完整源码-20200418//===----------------------------------------------------------------------===// // // This source file is part of the Swift.org open source project // // Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors // Licensed under Apache License v2.0 with Runtime Library Exception // // See https://swift.org/LICENSE.txt for license information // See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors // //===----------------------------------------------------------------------===// /// A type that supplies the values of a sequence one at a time. /// /// The `IteratorProtocol` protocol is tightly linked with the `Sequence` /// protocol. Sequences provide access to their elements by creating an /// iterator, which keeps track of its iteration process and returns one /// element at a time as it advances through the sequence. /// /// Whenever you use a `for`-`in` loop with an array, set, or any other /// collection or sequence, you're using that type's iterator. Swift uses a /// sequence's or collection's iterator internally to enable the `for`-`in` /// loop language construct. /// /// Using a sequence's iterator directly gives you access to the same elements /// in the same order as iterating over that sequence using a `for`-`in` loop. /// For example, you might typically use a `for`-`in` loop to print each of /// the elements in an array. /// /// let animals = [\"Antelope\", \"Butterfly\", \"Camel\", \"Dolphin\"] /// for animal in animals { /// print(animal) /// } /// // Prints \"Antelope\" /// // Prints \"Butterfly\" /// // Prints \"Camel\" /// // Prints \"Dolphin\" /// /// Behind the scenes, Swift uses the `animals` array's iterator to loop over /// the contents of the array. /// /// var animalIterator = animals.makeIterator() /// while let animal = animalIterator.next() { /// print(animal) /// } /// // Prints \"Antelope\" /// // Prints \"Butterfly\" /// // Prints \"Camel\" /// // Prints \"Dolphin\" /// /// The call to `animals.makeIterator()` returns an instance of the array's /// iterator. Next, the `while` loop calls the iterator's `next()` method /// repeatedly, binding each element that is returned to `animal` and exiting /// when the `next()` method returns `nil`. /// /// Using Iterators Directly /// ======================== /// /// You rarely need to use iterators directly, because a `for`-`in` loop is the /// more idiomatic approach to traversing a sequence in Swift. Some /// algorithms, however, may call for direct iterator use. /// /// One example is the `reduce1(_:)` method. Similar to the `reduce(_:_:)` /// method defined in the standard library, which takes an initial value and a /// combining closure, `reduce1(_:)` uses the first element of the sequence as /// the initial value. /// /// Here's an implementation of the `reduce1(_:)` method. The sequence's /// iterator is used directly to retrieve the initial value before looping /// over the rest of the sequence. /// /// extension Sequence { /// func reduce1( /// _ nextPartialResult: (Element, Element) -> Element /// ) -> Element? /// { /// var i = makeIterator() /// guard var accumulated = i.next() else { /// return nil /// } /// /// while let element = i.next() { /// accumulated = nextPartialResult(accumulated, element) /// } /// return accumulated /// } /// } /// /// The `reduce1(_:)` method makes certain kinds of sequence operations /// simpler. Here's how to find the longest string in a sequence, using the /// `animals` array introduced earlier as an example: /// /// let longestAnimal = animals.reduce1 { current, element in /// if current.count > element.count { /// return current /// } else { /// return element /// } /// } /// print(longestAnimal) /// // Prints \"Butterfly\" /// /// Using Multiple Iterators /// ======================== /// /// Whenever you use multiple iterators (or `for`-`in` loops) over a single /// sequence, be sure you know that the specific sequence supports repeated /// iteration, either because you know its concrete type or because the /// sequence is also constrained to the `Collection` protocol. /// /// Obtain each separate iterator from separate calls to the sequence's /// `makeIterator()` method rather than by copying. Copying an iterator is /// safe, but advancing one copy of an iterator by calling its `next()` method /// may invalidate other copies of that iterator. `for`-`in` loops are safe in /// this regard. /// /// Adding IteratorProtocol Conformance to Your Type /// ================================================ /// /// Implementing an iterator that conforms to `IteratorProtocol` is simple. /// Declare a `next()` method that advances one step in the related sequence /// and returns the current element. When the sequence has been exhausted, the /// `next()` method returns `nil`. /// /// For example, consider a custom `Countdown` sequence. You can initialize the /// `Countdown` sequence with a starting integer and then iterate over the /// count down to zero. The `Countdown` structure's definition is short: It /// contains only the starting count and the `makeIterator()` method required /// by the `Sequence` protocol. /// /// struct Countdown: Sequence { /// let start: Int /// /// func makeIterator() -> CountdownIterator { /// return CountdownIterator(self) /// } /// } /// /// The `makeIterator()` method returns another custom type, an iterator named /// `CountdownIterator`. The `CountdownIterator` type keeps track of both the /// `Countdown` sequence that it's iterating and the number of times it has /// returned a value. /// /// struct CountdownIterator: IteratorProtocol { /// let countdown: Countdown /// var times = 0 /// /// init(_ countdown: Countdown) { /// self.countdown = countdown /// } /// /// mutating func next() -> Int? { /// let nextNumber = countdown.start - times /// guard nextNumber > 0 /// else { return nil } /// /// times += 1 /// return nextNumber /// } /// } /// /// Each time the `next()` method is called on a `CountdownIterator` instance, /// it calculates the new next value, checks to see whether it has reached /// zero, and then returns either the number, or `nil` if the iterator is /// finished returning elements of the sequence. /// /// Creating and iterating over a `Countdown` sequence uses a /// `CountdownIterator` to handle the iteration. /// /// let threeTwoOne = Countdown(start: 3) /// for count in threeTwoOne { /// print(\"\\(count)...\") /// } /// // Prints \"3...\" /// // Prints \"2...\" /// // Prints \"1...\" public protocol IteratorProtocol { /// The type of element traversed by the iterator. associatedtype Element /// Advances to the next element and returns it, or `nil` if no next element /// exists. /// /// Repeatedly calling this method returns, in order, all the elements of the /// underlying sequence. As soon as the sequence has run out of elements, all /// subsequent calls return `nil`. /// /// You must not call this method if any other copy of this iterator has been /// advanced with a call to its `next()` method. /// /// The following example shows how an iterator can be used explicitly to /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and /// then call the iterator's `next()` method until it returns `nil`. /// /// let numbers = [2, 3, 5, 7] /// var numbersIterator = numbers.makeIterator() /// /// while let num = numbersIterator.next() { /// print(num) /// } /// // Prints \"2\" /// // Prints \"3\" /// // Prints \"5\" /// // Prints \"7\" /// /// - Returns: The next element in the underlying sequence, if a next element /// exists; otherwise, `nil`. mutating func next() -> Element? } /// A type that provides sequential, iterated access to its elements. /// /// A sequence is a list of values that you can step through one at a time. The /// most common way to iterate over the elements of a sequence is to use a /// `for`-`in` loop: /// /// let oneTwoThree = 1...3 /// for number in oneTwoThree { /// print(number) /// } /// // Prints \"1\" /// // Prints \"2\" /// // Prints \"3\" /// /// While seemingly simple, this capability gives you access to a large number /// of operations that you can perform on any sequence. As an example, to /// check whether a sequence includes a particular value, you can test each /// value sequentially until you've found a match or reached the end of the /// sequence. This example checks to see whether a particular insect is in an /// array. /// /// let bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"] /// var hasMosquito = false /// for bug in bugs { /// if bug == \"Mosquito\" { /// hasMosquito = true /// break /// } /// } /// print(\"'bugs' has a mosquito: \\(hasMosquito)\") /// // Prints \"'bugs' has a mosquito: false\" /// /// The `Sequence` protocol provides default implementations for many common /// operations that depend on sequential access to a sequence's values. For /// clearer, more concise code, the example above could use the array's /// `contains(_:)` method, which every sequence inherits from `Sequence`, /// instead of iterating manually: /// /// if bugs.contains(\"Mosquito\") { /// print(\"Break out the bug spray.\") /// } else { /// print(\"Whew, no mosquitos!\") /// } /// // Prints \"Whew, no mosquitos!\" /// /// Repeated Access /// =============== /// /// The `Sequence` protocol makes no requirement on conforming types regarding /// whether they will be destructively consumed by iteration. As a /// consequence, don't assume that multiple `for`-`in` loops on a sequence /// will either resume iteration or restart from the beginning: /// /// for element in sequence { /// if ... some condition { break } /// } /// /// for element in sequence { /// // No defined behavior /// } /// /// In this case, you cannot assume either that a sequence will be consumable /// and will resume iteration, or that a sequence is a collection and will /// restart iteration from the first element. A conforming sequence that is /// not a collection is allowed to produce an arbitrary sequence of elements /// in the second `for`-`in` loop. /// /// To establish that a type you've created supports nondestructive iteration, /// add conformance to the `Collection` protocol. /// /// Conforming to the Sequence Protocol /// =================================== /// /// Making your own custom types conform to `Sequence` enables many useful /// operations, like `for`-`in` looping and the `contains` method, without /// much effort. To add `Sequence` conformance to your own custom type, add a /// `makeIterator()` method that returns an iterator. /// /// Alternatively, if your type can act as its own iterator, implementing the /// requirements of the `IteratorProtocol` protocol and declaring conformance /// to both `Sequence` and `IteratorProtocol` are sufficient. /// /// Here's a definition of a `Countdown` sequence that serves as its own /// iterator. The `makeIterator()` method is provided as a default /// implementation. /// /// struct Countdown: Sequence, IteratorProtocol { /// var count: Int /// /// mutating func next() -> Int? { /// if count == 0 { /// return nil /// } else { /// defer { count -= 1 } /// return count /// } /// } /// } /// /// let threeToGo = Countdown(count: 3) /// for i in threeToGo { /// print(i) /// } /// // Prints \"3\" /// // Prints \"2\" /// // Prints \"1\" /// /// Expected Performance /// ==================== /// /// A sequence should provide its iterator in O(1). The `Sequence` protocol /// makes no other requirements about element access, so routines that /// traverse a sequence should be considered O(*n*) unless documented /// otherwise. public protocol Sequence { /// A type representing the sequence's elements. associatedtype Element /// A type that provides the sequence's iteration interface and /// encapsulates its iteration state. associatedtype Iterator: IteratorProtocol where Iterator.Element == Element /// A type that represents a subsequence of some of the sequence's elements. // associatedtype SubSequence: Sequence = AnySequence&lt;Element> // where Element == SubSequence.Element, // SubSequence.SubSequence == SubSequence // typealias SubSequence = AnySequence&lt;Element> /// Returns an iterator over the elements of this sequence. __consuming func makeIterator() -> Iterator /// A value less than or equal to the number of elements in the sequence, /// calculated nondestructively. /// /// The default implementation returns 0. If you provide your own /// implementation, make sure to compute the value nondestructively. /// /// - Complexity: O(1), except if the sequence also conforms to `Collection`. /// In this case, see the documentation of `Collection.underestimatedCount`. var underestimatedCount: Int { get } func _customContainsEquatableElement( _ element: Element ) -> Bool? /// Create a native array buffer containing the elements of `self`, /// in the same order. __consuming func _copyToContiguousArray() -> ContiguousArray&lt;Element> /// Copy `self` into an unsafe buffer, returning a partially-consumed /// iterator with any elements that didn't fit remaining. __consuming func _copyContents( initializing ptr: UnsafeMutableBufferPointer&lt;Element> ) -> (Iterator,UnsafeMutableBufferPointer&lt;Element>.Index) /// Call `body(p)`, where `p` is a pointer to the collection's /// contiguous storage. If no such storage exists, it is /// first created. If the collection does not support an internal /// representation in a form of contiguous storage, `body` is not /// called and `nil` is returned. /// /// A `Collection` that provides its own implementation of this method /// must also guarantee that an equivalent buffer of its `SubSequence` /// can be generated by advancing the pointer by the distance to the /// slice's `startIndex`. func withContiguousStorageIfAvailable&lt;R>( _ body: (UnsafeBufferPointer&lt;Element>) throws -> R ) rethrows -> R? } // Provides a default associated type witness for Iterator when the // Self type is both a Sequence and an Iterator. extension Sequence where Self: IteratorProtocol { // @_implements(Sequence, Iterator) public typealias _Default_Iterator = Self } /// A default makeIterator() function for `IteratorProtocol` instances that /// are declared to conform to `Sequence` extension Sequence where Self.Iterator == Self { /// Returns an iterator over the elements of this sequence. @inlinable public __consuming func makeIterator() -> Self { return self } } /// A sequence that lazily consumes and drops `n` elements from an underlying /// `Base` iterator before possibly returning the first available element. /// /// The underlying iterator's sequence may be infinite. @frozen public struct DropFirstSequence&lt;Base: Sequence> { @usableFromInline internal let _base: Base @usableFromInline internal let _limit: Int @inlinable public init(_ base: Base, dropping limit: Int) { _precondition(limit >= 0, \"Can't drop a negative number of elements from a sequence\") _base = base _limit = limit } } extension DropFirstSequence: Sequence { public typealias Element = Base.Element public typealias Iterator = Base.Iterator public typealias SubSequence = AnySequence&lt;Element> @inlinable public __consuming func makeIterator() -> Iterator { var it = _base.makeIterator() var dropped = 0 while dropped &lt; _limit, it.next() != nil { dropped &amp;+= 1 } return it } @inlinable public __consuming func dropFirst(_ k: Int) -> DropFirstSequence&lt;Base> { // If this is already a _DropFirstSequence, we need to fold in // the current drop count and drop limit so no data is lost. // // i.e. [1,2,3,4].dropFirst(1).dropFirst(1) should be equivalent to // [1,2,3,4].dropFirst(2). return DropFirstSequence(_base, dropping: _limit + k) } } /// A sequence that only consumes up to `n` elements from an underlying /// `Base` iterator. /// /// The underlying iterator's sequence may be infinite. @frozen public struct PrefixSequence&lt;Base: Sequence> { @usableFromInline internal var _base: Base @usableFromInline internal let _maxLength: Int @inlinable public init(_ base: Base, maxLength: Int) { _precondition(maxLength >= 0, \"Can't take a prefix of negative length\") _base = base _maxLength = maxLength } } extension PrefixSequence { @frozen public struct Iterator { @usableFromInline internal var _base: Base.Iterator @usableFromInline internal var _remaining: Int @inlinable internal init(_ base: Base.Iterator, maxLength: Int) { _base = base _remaining = maxLength } } } extension PrefixSequence.Iterator: IteratorProtocol { public typealias Element = Base.Element @inlinable public mutating func next() -> Element? { if _remaining != 0 { _remaining &amp;-= 1 return _base.next() } else { return nil } } } extension PrefixSequence: Sequence { @inlinable public __consuming func makeIterator() -> Iterator { return Iterator(_base.makeIterator(), maxLength: _maxLength) } @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence&lt;Base> { let length = Swift.min(maxLength, self._maxLength) return PrefixSequence(_base, maxLength: length) } } /// A sequence that lazily consumes and drops `n` elements from an underlying /// `Base` iterator before possibly returning the first available element. /// /// The underlying iterator's sequence may be infinite. @frozen public struct DropWhileSequence&lt;Base: Sequence> { public typealias Element = Base.Element @usableFromInline internal var _iterator: Base.Iterator @usableFromInline internal var _nextElement: Element? @inlinable internal init(iterator: Base.Iterator, predicate: (Element) throws -> Bool) rethrows { _iterator = iterator _nextElement = _iterator.next() while let x = _nextElement, try predicate(x) { _nextElement = _iterator.next() } } @inlinable internal init(_ base: Base, predicate: (Element) throws -> Bool) rethrows { self = try DropWhileSequence(iterator: base.makeIterator(), predicate: predicate) } } extension DropWhileSequence { @frozen public struct Iterator { @usableFromInline internal var _iterator: Base.Iterator @usableFromInline internal var _nextElement: Element? @inlinable internal init(_ iterator: Base.Iterator, nextElement: Element?) { _iterator = iterator _nextElement = nextElement } } } extension DropWhileSequence.Iterator: IteratorProtocol { public typealias Element = Base.Element @inlinable public mutating func next() -> Element? { guard let next = _nextElement else { return nil } _nextElement = _iterator.next() return next } } extension DropWhileSequence: Sequence { @inlinable public func makeIterator() -> Iterator { return Iterator(_iterator, nextElement: _nextElement) } @inlinable public __consuming func drop( while predicate: (Element) throws -> Bool ) rethrows -> DropWhileSequence&lt;Base> { guard let x = _nextElement, try predicate(x) else { return self } return try DropWhileSequence(iterator: _iterator, predicate: predicate) } } //===----------------------------------------------------------------------===// // Default implementations for Sequence //===----------------------------------------------------------------------===// extension Sequence { /// Returns an array containing the results of mapping the given closure /// over the sequence's elements. /// /// In this example, `map` is used first to convert the names in the array /// to lowercase strings and then to count their characters. /// /// let cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"] /// let lowercaseNames = cast.map { $0.lowercased() } /// // 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"] /// let letterCounts = cast.map { $0.count } /// // 'letterCounts' == [6, 6, 3, 4] /// /// - Parameter transform: A mapping closure. `transform` accepts an /// element of this sequence as its parameter and returns a transformed /// value of the same or of a different type. /// - Returns: An array containing the transformed elements of this /// sequence. /// /// - Complexity: O(*n*), where *n* is the length of the sequence. @inlinable public func map&lt;T>( _ transform: (Element) throws -> T ) rethrows -> [T] { let initialCapacity = underestimatedCount var result = ContiguousArray&lt;T>() result.reserveCapacity(initialCapacity) var iterator = self.makeIterator() // Add elements up to the initial capacity without checking for regrowth. for _ in 0..&lt;initialCapacity { result.append(try transform(iterator.next()!)) } // Add remaining elements, if any. while let element = iterator.next() { result.append(try transform(element)) } return Array(result) } /// Returns an array containing, in order, the elements of the sequence /// that satisfy the given predicate. /// /// In this example, `filter(_:)` is used to include only names shorter than /// five characters. /// /// let cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"] /// let shortNames = cast.filter { $0.count &lt; 5 } /// print(shortNames) /// // Prints \"[\"Kim\", \"Karl\"]\" /// /// - Parameter isIncluded: A closure that takes an element of the /// sequence as its argument and returns a Boolean value indicating /// whether the element should be included in the returned array. /// - Returns: An array of the elements that `isIncluded` allowed. /// /// - Complexity: O(*n*), where *n* is the length of the sequence. @inlinable public __consuming func filter( _ isIncluded: (Element) throws -> Bool ) rethrows -> [Element] { return try _filter(isIncluded) } @_transparent public func _filter( _ isIncluded: (Element) throws -> Bool ) rethrows -> [Element] { var result = ContiguousArray&lt;Element>() var iterator = self.makeIterator() while let element = iterator.next() { if try isIncluded(element) { result.append(element) } } return Array(result) } /// A value less than or equal to the number of elements in the sequence, /// calculated nondestructively. /// /// The default implementation returns 0. If you provide your own /// implementation, make sure to compute the value nondestructively. /// /// - Complexity: O(1), except if the sequence also conforms to `Collection`. /// In this case, see the documentation of `Collection.underestimatedCount`. @inlinable public var underestimatedCount: Int { return 0 } @inlinable @inline(__always) public func _customContainsEquatableElement( _ element: Iterator.Element ) -> Bool? { return nil } /// Calls the given closure on each element in the sequence in the same order /// as a `for`-`in` loop. /// /// The two loops in the following example produce the same output: /// /// let numberWords = [\"one\", \"two\", \"three\"] /// for word in numberWords { /// print(word) /// } /// // Prints \"one\" /// // Prints \"two\" /// // Prints \"three\" /// /// numberWords.forEach { word in /// print(word) /// } /// // Same as above /// /// Using the `forEach` method is distinct from a `for`-`in` loop in two /// important ways: /// /// 1. You cannot use a `break` or `continue` statement to exit the current /// call of the `body` closure or skip subsequent calls. /// 2. Using the `return` statement in the `body` closure will exit only from /// the current call to `body`, not from any outer scope, and won't skip /// subsequent calls. /// /// - Parameter body: A closure that takes an element of the sequence as a /// parameter. @_semantics(\"sequence.forEach\") @inlinable public func forEach( _ body: (Element) throws -> Void ) rethrows { for element in self { try body(element) } } } extension Sequence { /// Returns the first element of the sequence that satisfies the given /// predicate. /// /// The following example uses the `first(where:)` method to find the first /// negative number in an array of integers: /// /// let numbers = [3, 7, 4, -2, 9, -6, 10, 1] /// if let firstNegative = numbers.first(where: { $0 &lt; 0 }) { /// print(\"The first negative number is \\(firstNegative).\") /// } /// // Prints \"The first negative number is -2.\" /// /// - Parameter predicate: A closure that takes an element of the sequence as /// its argument and returns a Boolean value indicating whether the /// element is a match. /// - Returns: The first element of the sequence that satisfies `predicate`, /// or `nil` if there is no element that satisfies `predicate`. /// /// - Complexity: O(*n*), where *n* is the length of the sequence. @inlinable public func first( where predicate: (Element) throws -> Bool ) rethrows -> Element? { for element in self { if try predicate(element) { return element } } return nil } } extension Sequence where Element: Equatable { /// Returns the longest possible subsequences of the sequence, in order, /// around elements equal to the given element. /// /// The resulting array consists of at most `maxSplits + 1` subsequences. /// Elements that are used to split the sequence are not returned as part of /// any subsequence. /// /// The following examples show the effects of the `maxSplits` and /// `omittingEmptySubsequences` parameters when splitting a string at each /// space character (\" \"). The first use of `split` returns each word that /// was originally separated by one or more spaces. /// /// let line = \"BLANCHE: I don't want realism. I want magic!\" /// print(line.split(separator: \" \") /// .map(String.init)) /// // Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\" /// /// The second example passes `1` for the `maxSplits` parameter, so the /// original string is split just once, into two new strings. /// /// print(line.split(separator: \" \", maxSplits: 1) /// .map(String.init)) /// // Prints \"[\"BLANCHE:\", \" I don\\'t want realism. I want magic!\"]\" /// /// The final example passes `false` for the `omittingEmptySubsequences` /// parameter, so the returned array contains empty strings where spaces /// were repeated. /// /// print(line.split(separator: \" \", omittingEmptySubsequences: false) /// .map(String.init)) /// // Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\" /// /// - Parameters: /// - separator: The element that should be split upon. /// - maxSplits: The maximum number of times to split the sequence, or one /// less than the number of subsequences to return. If `maxSplits + 1` /// subsequences are returned, the last one is a suffix of the original /// sequence containing the remaining elements. `maxSplits` must be /// greater than or equal to zero. The default value is `Int.max`. /// - omittingEmptySubsequences: If `false`, an empty subsequence is /// returned in the result for each consecutive pair of `separator` /// elements in the sequence and for each instance of `separator` at the /// start or end of the sequence. If `true`, only nonempty subsequences /// are returned. The default value is `true`. /// - Returns: An array of subsequences, split from this sequence's elements. /// /// - Complexity: O(*n*), where *n* is the length of the sequence. @inlinable public __consuming func split( separator: Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true ) -> [ArraySlice&lt;Element>] { return split( maxSplits: maxSplits, omittingEmptySubsequences: omittingEmptySubsequences, whereSeparator: { $0 == separator }) } } extension Sequence { /// Returns the longest possible subsequences of the sequence, in order, that /// don't contain elements satisfying the given predicate. Elements that are /// used to split the sequence are not returned as part of any subsequence. /// /// The following examples show the effects of the `maxSplits` and /// `omittingEmptySubsequences` parameters when splitting a string using a /// closure that matches spaces. The first use of `split` returns each word /// that was originally separated by one or more spaces. /// /// let line = \"BLANCHE: I don't want realism. I want magic!\" /// print(line.split(whereSeparator: { $0 == \" \" }) /// .map(String.init)) /// // Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\" /// /// The second example passes `1` for the `maxSplits` parameter, so the /// original string is split just once, into two new strings. /// /// print( /// line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }) /// .map(String.init)) /// // Prints \"[\"BLANCHE:\", \" I don\\'t want realism. I want magic!\"]\" /// /// The final example passes `true` for the `allowEmptySlices` parameter, so /// the returned array contains empty strings where spaces were repeated. /// /// print( /// line.split( /// omittingEmptySubsequences: false, /// whereSeparator: { $0 == \" \" } /// ).map(String.init)) /// // Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\" /// /// - Parameters: /// - maxSplits: The maximum number of times to split the sequence, or one /// less than the number of subsequences to return. If `maxSplits + 1` /// subsequences are returned, the last one is a suffix of the original /// sequence containing the remaining elements. `maxSplits` must be /// greater than or equal to zero. The default value is `Int.max`. /// - omittingEmptySubsequences: If `false`, an empty subsequence is /// returned in the result for each pair of consecutive elements /// satisfying the `isSeparator` predicate and for each element at the /// start or end of the sequence satisfying the `isSeparator` predicate. /// If `true`, only nonempty subsequences are returned. The default /// value is `true`. /// - isSeparator: A closure that returns `true` if its argument should be /// used to split the sequence; otherwise, `false`. /// - Returns: An array of subsequences, split from this sequence's elements. /// /// - Complexity: O(*n*), where *n* is the length of the sequence. @inlinable public __consuming func split( maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator: (Element) throws -> Bool ) rethrows -> [ArraySlice&lt;Element>] { _precondition(maxSplits >= 0, \"Must take zero or more splits\") let whole = Array(self) return try whole.split( maxSplits: maxSplits, omittingEmptySubsequences: omittingEmptySubsequences, whereSeparator: isSeparator) } /// Returns a subsequence, up to the given maximum length, containing the /// final elements of the sequence. /// /// The sequence must be finite. If the maximum length exceeds the number of /// elements in the sequence, the result contains all the elements in the /// sequence. /// /// let numbers = [1, 2, 3, 4, 5] /// print(numbers.suffix(2)) /// // Prints \"[4, 5]\" /// print(numbers.suffix(10)) /// // Prints \"[1, 2, 3, 4, 5]\" /// /// - Parameter maxLength: The maximum number of elements to return. The /// value of `maxLength` must be greater than or equal to zero. /// /// - Complexity: O(*n*), where *n* is the length of the sequence. @inlinable public __consuming func suffix(_ maxLength: Int) -> [Element] { _precondition(maxLength >= 0, \"Can't take a suffix of negative length from a sequence\") guard maxLength != 0 else { return [] } // FIXME: &lt;rdar://problem/21885650> Create reusable RingBuffer&lt;T> // Put incoming elements into a ring buffer to save space. Once all // elements are consumed, reorder the ring buffer into a copy and return it. // This saves memory for sequences particularly longer than `maxLength`. var ringBuffer = ContiguousArray&lt;Element>() ringBuffer.reserveCapacity(Swift.min(maxLength, underestimatedCount)) var i = 0 for element in self { if ringBuffer.count &lt; maxLength { ringBuffer.append(element) } else { ringBuffer[i] = element i = (i + 1) % maxLength } } if i != ringBuffer.startIndex { var rotated = ContiguousArray&lt;Element>() rotated.reserveCapacity(ringBuffer.count) rotated += ringBuffer[i..&lt;ringBuffer.endIndex] rotated += ringBuffer[0..&lt;i] return Array(rotated) } else { return Array(ringBuffer) } } /// Returns a sequence containing all but the given number of initial /// elements. /// /// If the number of elements to drop exceeds the number of elements in /// the sequence, the result is an empty sequence. /// /// let numbers = [1, 2, 3, 4, 5] /// print(numbers.dropFirst(2)) /// // Prints \"[3, 4, 5]\" /// print(numbers.dropFirst(10)) /// // Prints \"[]\" /// /// - Parameter k: The number of elements to drop from the beginning of /// the sequence. `k` must be greater than or equal to zero. /// - Returns: A sequence starting after the specified number of /// elements. /// /// - Complexity: O(1), with O(*k*) deferred to each iteration of the result, /// where *k* is the number of elements to drop from the beginning of /// the sequence. @inlinable public __consuming func dropFirst(_ k: Int = 1) -> DropFirstSequence&lt;Self> { return DropFirstSequence(self, dropping: k) } /// Returns a sequence containing all but the given number of final /// elements. /// /// The sequence must be finite. If the number of elements to drop exceeds /// the number of elements in the sequence, the result is an empty /// sequence. /// /// let numbers = [1, 2, 3, 4, 5] /// print(numbers.dropLast(2)) /// // Prints \"[1, 2, 3]\" /// print(numbers.dropLast(10)) /// // Prints \"[]\" /// /// - Parameter n: The number of elements to drop off the end of the /// sequence. `n` must be greater than or equal to zero. /// - Returns: A sequence leaving off the specified number of elements. /// /// - Complexity: O(*n*), where *n* is the length of the sequence. @inlinable public __consuming func dropLast(_ k: Int = 1) -> [Element] { _precondition(k >= 0, \"Can't drop a negative number of elements from a sequence\") guard k != 0 else { return Array(self) } // FIXME: &lt;rdar://problem/21885650> Create reusable RingBuffer&lt;T> // Put incoming elements from this sequence in a holding tank, a ring buffer // of size &lt;= k. If more elements keep coming in, pull them out of the // holding tank into the result, an `Array`. This saves // `k` * sizeof(Element) of memory, because slices keep the entire // memory of an `Array` alive. var result = ContiguousArray&lt;Element>() var ringBuffer = ContiguousArray&lt;Element>() var i = ringBuffer.startIndex for element in self { if ringBuffer.count &lt; k { ringBuffer.append(element) } else { result.append(ringBuffer[i]) ringBuffer[i] = element i = (i + 1) % k } } return Array(result) } /// Returns a sequence by skipping the initial, consecutive elements that /// satisfy the given predicate. /// /// The following example uses the `drop(while:)` method to skip over the /// positive numbers at the beginning of the `numbers` array. The result /// begins with the first element of `numbers` that does not satisfy /// `predicate`. /// /// let numbers = [3, 7, 4, -2, 9, -6, 10, 1] /// let startingWithNegative = numbers.drop(while: { $0 > 0 }) /// // startingWithNegative == [-2, 9, -6, 10, 1] /// /// If `predicate` matches every element in the sequence, the result is an /// empty sequence. /// /// - Parameter predicate: A closure that takes an element of the sequence as /// its argument and returns a Boolean value indicating whether the /// element should be included in the result. /// - Returns: A sequence starting after the initial, consecutive elements /// that satisfy `predicate`. /// /// - Complexity: O(*k*), where *k* is the number of elements to drop from /// the beginning of the sequence. @inlinable public __consuming func drop( while predicate: (Element) throws -> Bool ) rethrows -> DropWhileSequence&lt;Self> { return try DropWhileSequence(self, predicate: predicate) } /// Returns a sequence, up to the specified maximum length, containing the /// initial elements of the sequence. /// /// If the maximum length exceeds the number of elements in the sequence, /// the result contains all the elements in the sequence. /// /// let numbers = [1, 2, 3, 4, 5] /// print(numbers.prefix(2)) /// // Prints \"[1, 2]\" /// print(numbers.prefix(10)) /// // Prints \"[1, 2, 3, 4, 5]\" /// /// - Parameter maxLength: The maximum number of elements to return. The /// value of `maxLength` must be greater than or equal to zero. /// - Returns: A sequence starting at the beginning of this sequence /// with at most `maxLength` elements. /// /// - Complexity: O(1) @inlinable public __consuming func prefix(_ maxLength: Int) -> PrefixSequence&lt;Self> { return PrefixSequence(self, maxLength: maxLength) } /// Returns a sequence containing the initial, consecutive elements that /// satisfy the given predicate. /// /// The following example uses the `prefix(while:)` method to find the /// positive numbers at the beginning of the `numbers` array. Every element /// of `numbers` up to, but not including, the first negative value is /// included in the result. /// /// let numbers = [3, 7, 4, -2, 9, -6, 10, 1] /// let positivePrefix = numbers.prefix(while: { $0 > 0 }) /// // positivePrefix == [3, 7, 4] /// /// If `predicate` matches every element in the sequence, the resulting /// sequence contains every element of the sequence. /// /// - Parameter predicate: A closure that takes an element of the sequence as /// its argument and returns a Boolean value indicating whether the /// element should be included in the result. /// - Returns: A sequence of the initial, consecutive elements that /// satisfy `predicate`. /// /// - Complexity: O(*k*), where *k* is the length of the result. @inlinable public __consuming func prefix( while predicate: (Element) throws -> Bool ) rethrows -> [Element] { var result = ContiguousArray&lt;Element>() for element in self { guard try predicate(element) else { break } result.append(element) } return Array(result) } } extension Sequence { /// Copies `self` into the supplied buffer. /// /// - Precondition: The memory in `self` is uninitialized. The buffer must /// contain sufficient uninitialized memory to accommodate `source.underestimatedCount`. /// /// - Postcondition: The `Pointee`s at `buffer[startIndex..&lt;returned index]` are /// initialized. @inlinable public __consuming func _copyContents( initializing buffer: UnsafeMutableBufferPointer&lt;Element> ) -> (Iterator,UnsafeMutableBufferPointer&lt;Element>.Index) { var it = self.makeIterator() guard var ptr = buffer.baseAddress else { return (it,buffer.startIndex) } for idx in buffer.startIndex..&lt;buffer.count { guard let x = it.next() else { return (it, idx) } ptr.initialize(to: x) ptr += 1 } return (it,buffer.endIndex) } @inlinable public func withContiguousStorageIfAvailable&lt;R>( _ body: (UnsafeBufferPointer&lt;Element>) throws -> R ) rethrows -> R? { return nil } } // FIXME(ABI)#182 // Pending &lt;rdar://problem/14011860> and &lt;rdar://problem/14396120>, // pass an IteratorProtocol through IteratorSequence to give it \"Sequence-ness\" /// A sequence built around an iterator of type `Base`. /// /// Useful mostly to recover the ability to use `for`...`in`, /// given just an iterator `i`: /// /// for x in IteratorSequence(i) { ... } @frozen public struct IteratorSequence&lt;Base: IteratorProtocol> { @usableFromInline internal var _base: Base /// Creates an instance whose iterator is a copy of `base`. @inlinable public init(_ base: Base) { _base = base } } extension IteratorSequence: IteratorProtocol, Sequence { /// Advances to the next element and returns it, or `nil` if no next element /// exists. /// /// Once `nil` has been returned, all subsequent calls return `nil`. /// /// - Precondition: `next()` has not been applied to a copy of `self` /// since the copy was made. @inlinable public mutating func next() -> Base.Element? { return _base.next() } } /* FIXME: ideally for compatability we would declare extension Sequence { @available(swift, deprecated: 5, message: \"\") public typealias SubSequence = AnySequence&lt;Element> } */","categories":[{"name":"源码","slug":"源码","permalink":"https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://mingriweiji-github.github.io/tags/swift/"}]},{"title":"Swift集合源码","slug":"Swift集合源码","date":"2020-04-18T00:08:23.000Z","updated":"2020-05-01T13:42:32.507Z","comments":true,"path":"2020/04/18/Swift集合源码/","link":"","permalink":"https://mingriweiji-github.github.io/2020/04/18/Swift%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/","excerpt":"","text":"Swift Collections使用篇1、Array数组Array的两种for循环 只遍历value for item in array { print(item) } 快速枚举数组，用元祖(index, value)接收 for (index, value) in array.enumerated() { print(index, value) } array.enumerated() + map 快速枚举 let nums = [1,2,3,4,5] let newNums = nums.enumerated().map { (index, num) in return num * 10 } print(\"newNums:\\(newNums)\") 数组的值倒叙reversed() + enumerated() //可以用来快速的枚举数组中的内容，并用元组(index, value)接收 public func enumerated() -&gt; EnumeratedSequence&gt; //可以倒叙数组内容 public func reversed() -&gt; ReversedRandomAccessCollection&gt; let nums = [5,4,3,2,1] //1、值倒叙 for item in nums.reversed().enumerated() { print(item) } for (index, item) in nums.reversed().enumerated() { } /* (offset: 0, element: 1) (offset: 1, element: 2) (offset: 2, element: 3) (offset: 3, element: 4) (offset: 4, element: 5) */ ------------------------------------------- // 2、索引+值都是倒叙 for i in nums.enumerated().reversed() { // print(\"\\(i)\") } /* (offset: 4, element: 1) (offset: 3, element: 2) (offset: 2, element: 3) (offset: 1, element: 4) (offset: 0, element: 5) */ 数组的索引逆序for i in (0...(nums.count - 1)).reversed() { print(i) } 数组的索引逆序1、forEach()遍历optional集合会自动过滤nillet optionalString: [String]? = nil //使用forEach强制解包option，会过滤 optionalString?.forEach { str in print(\"str is (str)\") } ///使用for-in强制解包optional，会crash for str in optionalString! { print(\"str is (str)\") } 2、forEach()和enumerated()的区别? forEach的官方定义 public func forEach(_ body: (Element) throws -> Void) rethrows { for element in self { try body(element) } } forEach的使用 ships.forEach { print(\"\\($0.value) is from \\($0.key)\") } 3、enumerated()还是zip()???我见到 enumerated() 最常用的方式是对一个数组执行 enumerated，使用返回的 offset 来获取另一个数组对应的元素。 for (offset, model) in models.enumerated() { let viewController = viewControllers[offset] viewController.model = model } 虽然这段代码可以正常运作，但前提是 models 和 viewControllers 都是 Array 类型，使用整型来作为索引值类型，从 0 开始。另一个前提是这两个数组拥有相同的长度。如果models 的数组长度比 viewControllers 短的话，就会崩溃。我们还多了一个没有实际意义的多余的变量 offset。一个简洁的 Swift 实现方式应该是： for (model, viewController) in zip(models, viewControllers) { viewController.model = model } 使用zip()加简洁，而且适用于所有 Sequence 类型，而且可以安全地处理不等长的数组。 让我们看看另一个例子，这段代码给第一个 imageView 和它的容器以及每个 imageView 之间添加了一段 autolayout 的约束 for (offset, imageView) in imageViews.enumerated() { if offset == 0 { imageView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor).isActive = true } else { let imageToAnchor = imageView[offset - 1] imageView.leadingAnchor.constraint(equalTo: imageToAnchor.trailingAnchor).isActive = true } } 这段示例代码也有同样的问题，我们想要成对的元素，但使用 enumerated() 去获取索引以便后续操作的时候，我们就需要手动去处理索引，这并没有必要。zip 在这种情况下也适用。 首先，处理容器和第一个元素的约束： imageViews.first?.leadingAnchor.constraint(equalTo: containerView.leadingAnchor).isActive = true 接着，我们来把元素拼成一对： for (left, right) in zip(imageViews, imageViews.dropFirst()) { left.trailingAnchor.constraint(equalTo: right.leadingAnchor).isActive = true } 搞定，没有索引值，任何 Sequence 类型都适用，而且更加简洁。 2、字典Dictionary to JSON stringThe dictionary is converted to Data which contains an UTF8 encoded string inside. let dictionary = [\"nacho\": [\"1\",\"2\",\"3\"]] let jsonData = try? JSONSerialization.data(withJSONObject: dictionary, options: []) let jsonString = String(data: jsonData!, encoding: .utf8) print(jsonString) {\"nacho\":[\"1\",\"2\",\"3\"]} Also it is possible to use .prettyPrinted which is nice for showing the result string to humans, but in reality I almost never use it. JSON String to DictionaryThe JSON string should be converted to NSData (using UTF8 encoding), then we can create a dictionary from such data. let jsonString = \"{\\\"nacho\\\":[\\\"1\\\",\\\"2\\\",\\\"3\\\"]}\" let jsonData = jsonString.data(using: .utf8)! let dictionary = try? JSONSerialization.jsonObject(with: jsonData, options: .mutableLeaves) print(dictionary) Optional([\"nacho\": [\"1\", \"2\", \"3\"]]) In JSONReadingOptions there is also .mutableLeaves, .allowFragments, etc but I don’t use them very often (Mutable leaves will create a mutable dictionary which might sound helpful but in reality you want to handle things as few as possible in dictionaries since its information is not always statically typed and programmers are able to add/remove key/values without the compiler knowing about it). Accessing information from objects created with JSONSerialization.jsonObjectNow, since JSONSerialization.jsonObject returns an object of type Any we need to cast it (according to our needs) to be able to access its information. For example: if let personsDictionary = dictionary as? [String: Any] { print(personsDictionary) if let numbers = personsDictionary[\"nacho\"] as? [String] { print(numbers) } } [\"nacho\": [\"1\", \"2\", \"3\"]] [\"1\", \"2\", \"3\"]","categories":[{"name":"源码","slug":"源码","permalink":"https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://mingriweiji-github.github.io/tags/swift/"}]},{"title":"Alamfire源码","slug":"Alamfire源码","date":"2020-04-16T02:13:45.000Z","updated":"2020-05-01T12:53:31.548Z","comments":true,"path":"2020/04/16/Alamfire源码/","link":"","permalink":"https://mingriweiji-github.github.io/2020/04/16/Alamfire%E6%BA%90%E7%A0%81/","excerpt":"","text":"Alamfire Github地址1、Request分析Request准守的Protocol Equatable Hashable CustomStringConvertible Downloadable UploadableConvertible Equatableextension Request: Equatable { public static func ==(lhs: Request, rhs: Request) -> Bool { return lhs.id == rhs.id } } Hashableextension Request: Hashable { public func hash(into hasher: inout Hasher) { hasher.combine(id) } } CustomStringConvertible extension Request: CustomStringConvertible { /// A textual representation of this instance, including the `HTTPMethod` and `URL` if the `URLRequest` has been /// created, as well as the response status code, if a response has been received. public var description: String { guard let request = performedRequests.last ?? lastRequest, let url = request.url, let method = request.httpMethod else { return \"No request created yet.\" } let requestDescription = \"\\(method) \\(url.absoluteString)\" return response.map { \"\\(requestDescription) (\\($0.statusCode))\" } ?? requestDescription } } Downloadable /// Type describing the source used to create the underlying `URLSessionDownloadTask`. public enum Downloadable { ​ /// Download should be started from the `URLRequest` produced by the associated `URLRequestConvertible` value. ​ case request(URLRequestConvertible) ​ /// Download should be started from the associated resume `Data` value. ​ case resumeData(Data) } UploadableConvertible/// A type that can produce an `UploadRequest.Uploadable` value. public protocol UploadableConvertible { /// Produces an `UploadRequest.Uploadable` value from the instance. /// /// - Returns: The `UploadRequest.Uploadable`. /// - Throws: Any `Error` produced during creation. func createUploadable() throws -> UploadRequest.Uploadable } extension UploadRequest.Uploadable: UploadableConvertible { public func createUploadable() throws -> UploadRequest.Uploadable { return self } } /// A type that can be converted to an upload, whether from an `UploadRequest.Uploadable` or `URLRequestConvertible`. public protocol UploadConvertible: UploadableConvertible &amp; URLRequestConvertible {} 初始化字段id: UUID为request提供唯一标识，用于hash、相等underlyingQueue: DispatchQueue 内部异步操作的串行队列serializationQueue: DispatchQueue 序列化使用的队列eventMonitor: EventMonitor? 事件监控interceptor: RequestInterceptor? 拦截器(重试器、适配器)delegate: RequestDelegate? Result定义State枚举public class Request { public enum State { case initialized //初始化 case resumed //恢复 case suspended //挂起 case cancelled // 取消 case finished //完成 func canTransitionTo(_ state: State) -> Bool { switch (self, state) { case (.initialized, _): return true case (_, .initialized), (.cancelled, _), (.finished, _): return false case (.resumed, .cancelled), (.suspended, .cancelled), (.resumed, .suspended), (.suspended, .resumed): return true case (.suspended, .suspended), (.resumed, .resumed): return false case (_, .finished): return true } } } // MARK: - Initial State // MARK: - Mutable State // MARK: Progress // MARK: Redirect Handling // MARK: Cached Response Handling // MARK: URLCredential // MARK: Validators // MARK: URLRequests // MARK: HTTPURLResponse // MARK: Tasks /// All `URLSessionTask`s created on behalf of the `Request`. public var tasks: [URLSessionTask] { return protectedMutableState.directValue.tasks } /// First `URLSessionTask` created on behalf of the `Request`. public var firstTask: URLSessionTask? { return tasks.first } /// Last `URLSessionTask` crated on behalf of the `Request`. public var lastTask: URLSessionTask? { return tasks.last } /// Current `URLSessionTask` created on behalf of the `Request`. public var task: URLSessionTask? { return lastTask } ///MARK: Metrics ///MARK: Retry Count public var retryCount: Int { return protectedMutableState.directValue.retryCount } ///MARK: Error public fileprivate(set) var error: AFError? { get { return protectedMutableState.directValue.error } set { protectedMutableState.write { $0.error = newValue } } } // MARK: - Internal Event API // All API must be called from underlyingQueue.(所有的API必须从底层队列调用) ... } Task相关: cancle/resume/suspend// MARK: Task Creation /// - Returns: The `URLSessionTask` created. func task(for request: URLRequest, using session: URLSession) -> URLSessionTask { fatalError(\"Subclasses must override.\") } // MARK: State @discardableResult public func cancel() -> Self { protectedMutableState.write { mutableState in guard mutableState.state.canTransitionTo(.cancelled) else { return } mutableState.state = .cancelled underlyingQueue.async { self.didCancel() } guard let task = mutableState.tasks.last, task.state != .completed else { underlyingQueue.async { self.finish() } return } // Resume to ensure metrics are gathered. task.resume() task.cancel() underlyingQueue.async { self.didCancelTask(task) } } return self } /// Suspends the instance. /// /// - Returns: The instance. @discardableResult public func suspend() -> Self { protectedMutableState.write { mutableState in guard mutableState.state.canTransitionTo(.suspended) else { return } mutableState.state = .suspended underlyingQueue.async { self.didSuspend() } guard let task = mutableState.tasks.last, task.state != .completed else { return } task.suspend() underlyingQueue.async { self.didSuspendTask(task) } } return self } /// Resumes the instance. /// /// - Returns: The instance. @discardableResult public func resume() -> Self { protectedMutableState.write { mutableState in guard mutableState.state.canTransitionTo(.resumed) else { return } mutableState.state = .resumed underlyingQueue.async { self.didResume() } guard let task = mutableState.tasks.last, task.state != .completed else { return } task.resume() underlyingQueue.async { self.didResumeTask(task) } } return self } State /// Protected `MutableState` value that provides thread-safe access to state values. fileprivate let protectedMutableState: Protector&lt;MutableState> = Protector(MutableState()) /// `State` of the `Request`. public var state: State { return protectedMutableState.directValue.state } /// Returns whether `state` is `.initialized`. public var isInitialized: Bool { return state == .initialized } /// Returns whether `state is `.resumed`. public var isResumed: Bool { return state == .resumed } /// Returns whether `state` is `.suspended`. public var isSuspended: Bool { return state == .suspended } /// Returns whether `state` is `.cancelled`. public var isCancelled: Bool { return state == .cancelled } /// Returns whether `state` is `.finished`. public var isFinished: Bool { return state == .finished } 可变状态MutableState通过结构体MutableState封装，包括进度、重定向、缓存、cURL、响应序列化、凭证、请求、task、metrics、重试次数、错误。 /// Protected `MutableState` value that provides thread-safe access to state values. fileprivate let protectedMutableState: Protector&lt;MutableState> = Protector(MutableState()) struct MutableState { /// State of the `Request`. var state: State = .initialized /// `ProgressHandler` and `DispatchQueue` provided for upload progress callbacks. var uploadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)? /// `ProgressHandler` and `DispatchQueue` provided for download progress callbacks. var downloadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)? /// `RedirectHandler` provided for to handle request redirection. var redirectHandler: RedirectHandler? /// `CachedResponseHandler` provided to handle response caching. var cachedResponseHandler: CachedResponseHandler? /// Closure called when the `Request` is able to create a cURL description of itself. var cURLHandler: ((String) -> Void)? /// Response serialization closures that handle response parsing. var responseSerializers: [() -> Void] = [] /// Response serialization completion closures executed once all response serializers are complete. var responseSerializerCompletions: [() -> Void] = [] /// Whether response serializer processing is finished. var responseSerializerProcessingFinished = false /// `URLCredential` used for authentication challenges. var credential: URLCredential? /// All `URLRequest`s created by Alamofire on behalf of the `Request`. var requests: [URLRequest] = [] /// All `URLSessionTask`s created by Alamofire on behalf of the `Request`. var tasks: [URLSessionTask] = [] /// All `URLSessionTaskMetrics` values gathered by Alamofire on behalf of the `Request`. Should correspond /// exactly the the `tasks` created. var metrics: [URLSessionTaskMetrics] = [] /// Number of times any retriers provided retried the `Request`. var retryCount = 0 /// Final `AFError` for the `Request`, whether from various internal Alamofire calls or as a result of a `task`. var error: AFError? } Redirects 如果多次设置重定向hander是逻辑错误的而且会引起crash 如果设置了redirect handler,当redirect response 响应的话，会使用到实例Request Cached Responses Sets the cached response handler for the Request which will be used when attempting to cache a response. Note: Attempting to set the cache handler more than once is a logic error and will crash. Clearup/// Final cleanup step executed when the instance finishes response serialization. func cleanup() { delegate?.cleanup(after: self) // No-op: override in subclass } DataRequest/// DataRequest是Request子类，使用URLSessionDataTask处理内存中下载的Data public class DataRequest: Request { } DownloadRequest/// `Request` subclass which downloads `Data` to a file on disk using `URLSessionDownloadTask`. /// DownloadRequest也是Request子类，使用URLSessionDownloadTask处理下载到硬盘中的Data。 public class DownloadRequest也是Request子类，使用: Request { } UploadRequest /// `DataRequest` subclass which handles `Data` upload from memory, file, or stream using `URLSessionUploadTask`. public class UploadRequest: DataRequest { /// Type describing the origin of the upload, whether `Data`, file, or stream. public enum Uploadable { ​ /// Upload from the provided `Data` value. ​ case data(Data) ​ /// Upload from the provided file `URL`, as well as a `Bool` determining whether the source file should be ​ /// automatically removed once uploaded. ​ case file(URL, shouldRemove: Bool) ​ /// Upload from the provided `InputStream`. ​ case stream(InputStream) } // MARK: **Initial State** /// The `UploadableConvertible` value used to produce the `Uploadable` value for this instance. public let upload: UploadableConvertible /// `FileManager` used to perform cleanup tasks, including the removal of multipart form encoded payloads written /// to disk. public let fileManager: FileManager // MARK: **Mutable State** /// `Uploadable` value used by the instance. public var uploadable: Uploadable? /// Creates an `UploadRequest` using the provided parameters. ...... 2、Session3、Result枚举/// Result.swift import Foundation public enum Result&lt;Value> { case success(Value) case failure(Error) /// Returns `true` if the result is a success, `false` otherwise. public var isSuccess: Bool { switch self { case .success: return true case .failure: return false } } /// Returns `true` if the result is a failure, `false` otherwise. public var isFailure: Bool { return !isSuccess } /// Returns the associated value if the result is a success, `nil` otherwise. public var value: Value? { switch self { case .success(let value): return value case .failure: return nil } } /// Returns the associated error value if the result is a failure, `nil` otherwise. public var error: Error? { switch self { case .success: return nil case .failure(let error): return error } } } // MARK: - CustomStringConvertible extension Result: CustomStringConvertible { /// The textual representation used when written to an output stream, which includes whether the result was a /// success or failure. public var description: String { switch self { case .success: return \"SUCCESS\" case .failure: return \"FAILURE\" } } } // MARK: - CustomDebugStringConvertible extension Result: CustomDebugStringConvertible { /// The debug textual representation used when written to an output stream, which includes whether the result was a /// success or failure in addition to the value or error. public var debugDescription: String { switch self { case .success(let value): return \"SUCCESS: \\(value)\" case .failure(let error): return \"FAILURE: \\(error)\" } } } public enum AFError: Error { /// The underlying reason the parameter encoding error occurred. /// /// - missingURL: The URL request did not have a URL to encode. /// - jsonEncodingFailed: JSON serialization failed with an underlying system error during the /// encoding process. /// - propertyListEncodingFailed: Property list serialization failed with an underlying system error during /// encoding process. public enum ParameterEncodingFailureReason { case missingURL case jsonEncodingFailed(error: Error) case propertyListEncodingFailed(error: Error) } /// The underlying reason the multipart encoding error occurred. public enum MultipartEncodingFailureReason { case bodyPartURLInvalid(url: URL) case bodyPartFilenameInvalid(in: URL) case bodyPartFileNotReachable(at: URL) case bodyPartFileNotReachableWithError(atURL: URL, error: Error) case bodyPartFileIsDirectory(at: URL) case bodyPartFileSizeNotAvailable(at: URL) case bodyPartFileSizeQueryFailedWithError(forURL: URL, error: Error) case bodyPartInputStreamCreationFailed(for: URL) case outputStreamCreationFailed(for: URL) case outputStreamFileAlreadyExists(at: URL) case outputStreamURLInvalid(url: URL) case outputStreamWriteFailed(error: Error) case inputStreamReadFailed(error: Error) } public enum ResponseValidationFailureReason { case dataFileNil case dataFileReadFailed(at: URL) case missingContentType(acceptableContentTypes: [String]) case unacceptableContentType(acceptableContentTypes: [String], responseContentType: String) case unacceptableStatusCode(code: Int) } public enum ResponseSerializationFailureReason { case inputDataNil case inputDataNilOrZeroLength case inputFileNil case inputFileReadFailed(at: URL) case stringSerializationFailed(encoding: String.Encoding) case jsonSerializationFailed(error: Error) case propertyListSerializationFailed(error: Error) } case invalidURL(url: URLConvertible) case parameterEncodingFailed(reason: ParameterEncodingFailureReason) case multipartEncodingFailed(reason: MultipartEncodingFailureReason) case responseValidationFailed(reason: ResponseValidationFailureReason) case responseSerializationFailed(reason: ResponseSerializationFailureReason) } JSONSerialization编解码class JSONSerialization : NSObject Overview您可以使用JSONSerialization类将JSON转换为Foundation对象，并将Foundation对象转换为JSON。 可能转换为JSON的Foundation对象必须具有以下属性： 顶级对象是[NSArray]（https://developer.apple.com/documentation/foundation/nsarray）或[`NSDictionary`]（https://developer.apple.com/documentation/foundation/ nsdictionary）。 所有对象都是NSString，NSNumber，NSArray，NSDictionary的实例 NSNull对象 所有字典的key都是NSString的实例。 不是NaN或无穷大的数字。 其他规则可能适用。如调用isValidJSONObject（_：）或尝试进行转换是确定给定对象是否可以转换为JSON的确定方法数据。 线程安全在iOS 7和更高版本以及macOS 10.9和更高版本上，JSONSerialization是线程安全的。 Creating a JSON Objectclass func jsonObject(with: Data, options: JSONSerialization.ReadingOptions) -&gt; Any Returns a Foundation object from given JSON data. class func jsonObject(with: InputStream, options: JSONSerialization.ReadingOptions) -&gt; Any Returns a Foundation object from JSON data in a given stream. Creating JSON Dataclass func data(withJSONObject: Any, options: JSONSerialization.WritingOptions) -&gt; Data Returns JSON data from a Foundation object. class func writeJSONObject(Any, to: OutputStream, options: JSONSerialization.WritingOptions, error: NSErrorPointer) -&gt; Int Writes a given JSON object to a stream. class func isValidJSONObject(Any) -&gt; Bool Returns a Boolean value that indicates whether a given object can be converted to JSON data. 拓展阅读AFNetwork姊妹篇URLSession全家桶AlamFire结构解析戴铭JSONDecoder","categories":[{"name":"源码","slug":"源码","permalink":"https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://mingriweiji-github.github.io/tags/swift/"}]},{"title":"Kingfisher源码","slug":"Kingfisher源码","date":"2020-04-16T02:13:45.000Z","updated":"2020-05-01T12:42:09.782Z","comments":true,"path":"2020/04/16/Kingfisher源码/","link":"","permalink":"https://mingriweiji-github.github.io/2020/04/16/Kingfisher%E6%BA%90%E7%A0%81/","excerpt":"","text":"Kingfisher源码Kingfisher3架构kf命名空间 类 Kingfisher 是一个范型类，类型是 Base 协议 KingfisherCompatible，声明属性 kf，类型是范型 CompatibleType 。并要求遵守协议的一方，实现该属性的 get 方法。 协议扩展中，协议自身实现了属性。这样就不必在每个遵守该协议的类里实现该属性了。 协议里的 kf 是一个 Kingfisher 类的实例，调用的方法是 Kingfisher 类的方法。 根据类型的不同，调用不同类型里的方法。如：对应 Image/ImageView / Button 的 Kingfisher 里的setImage 方法。 //Kingfisher.swift public final class Kingfisher&lt;Base> { public let base: Base public init(_ base: Base) { self.base = base } } /** A type that has Kingfisher extensions. */ public protocol KingfisherCompatible { associatedtype CompatibleType var kf: CompatibleType { get } } public extension KingfisherCompatible { public var kf: Kingfisher&lt;Self> { return Kingfisher(self) } } extension Image: KingfisherCompatible { } #if !os(watchOS) extension ImageView: KingfisherCompatible { } extension Button: KingfisherCompatible { } #else extension WKInterfaceImage: KingfisherCompatible { } #endif 1、weak var解决CADisplayLink循环引用为了防止AnimatedImageView 和 CADisplayLink 之间的循环引用，Kingfisher在AnimatedImageView 内部写了一个代理类。通过TargetProxy 来调用 AnimatedImageView 中的 updateFrame 方法 open class AnimatedImageView: UIImageView { /// Proxy object for prevending a reference cycle between the CADDisplayLink and AnimatedImageView. class TargetProxy { private weak var target: AnimatedImageView? init(target: AnimatedImageView) { self.target = target } @objc func onScreenUpdate() { target?.updateFrame() } } /// A display link that keeps calling the `updateFrame` method on every screen refresh. private lazy var displayLink: CADisplayLink = { self.isDisplayLinkInitialized = true let displayLink = CADisplayLink(target: TargetProxy(target: self), selector: #selector(TargetProxy.onScreenUpdate)) displayLink.add(to: .main, forMode: self.runLoopMode) displayLink.isPaused = true return displayLink }() } 2、处理Gif图片 // MARK: - Image format private struct ImageHeaderData { static var PNG: [UInt8] = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A] static var JPEG_SOI: [UInt8] = [0xFF, 0xD8] static var JPEG_IF: [UInt8] = [0xFF] static var GIF: [UInt8] = [0x47, 0x49, 0x46] } public enum ImageFormat { case unknown, PNG, JPEG, GIF } extension DataProxy { public var imageFormat: ImageFormat { var buffer = [UInt8](repeating: 0, count: 8) (base as NSData).getBytes(&amp;buffer, length: 8) if buffer == ImageHeaderData.PNG { return .PNG } else if buffer[0] == ImageHeaderData.JPEG_SOI[0] &amp;&amp; buffer[1] == ImageHeaderData.JPEG_SOI[1] &amp;&amp; buffer[2] == ImageHeaderData.JPEG_IF[0] { return .JPEG } else if buffer[0] == ImageHeaderData.GIF[0] &amp;&amp; buffer[1] == ImageHeaderData.GIF[1] &amp;&amp; buffer[2] == ImageHeaderData.GIF[2] { return .GIF } return .unknown } } 关联对象objc_setAssociatedObject private var animatedImageDataKey: Void? private var imageSourceKey: Void? // MARK: - Image Properties extension Kingfisher where Base: Image { fileprivate(set) var animatedImageData: Data? { get { return objc_getAssociatedObject(base, &amp;animatedImageDataKey) as? Data } set { objc_setAssociatedObject(base, &amp;animatedImageDataKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } fileprivate(set) var imageSource: ImageSource? { get { return objc_getAssociatedObject(base, &amp;imageSourceKey) as? ImageSource } set { objc_setAssociatedObject(base, &amp;imageSourceKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } } KingfisherManager原理 KingfisherManager 包含了downloader和cache 通过URL检索图片 获取图片retrieveImage /// Main manager class of Kingfisher. It connects Kingfisher downloader and cache. /// You can use this class to retrieve an image via a specified URL from web or cache. public class KingfisherManager { /// Shared manager used by the extensions across Kingfisher. public static let shared = KingfisherManager() /// Cache used by this manager public var cache: ImageCache /// Downloader used by this manager public var downloader: ImageDownloader fileprivate let processQueue: DispatchQueue convenience init() { self.init(downloader: .default, cache: .default) } init(downloader: ImageDownloader, cache: ImageCache) { self.downloader = downloader self.cache = cache let processQueueName = \"com.onevcat.Kingfisher.KingfisherManager.processQueue.\\(UUID().uuidString)\" processQueue = DispatchQueue(label: processQueueName, attributes: .concurrent) } /** Get an image with resource. If KingfisherOptions.None is used as `options`, Kingfisher will seek the image in memory and disk first. If not found, it will download the image at `resource.downloadURL` and cache it with `resource.cacheKey`. These default behaviors could be adjusted by passing different options. See `KingfisherOptions` for more. - parameter resource: Resource object contains information such as `cacheKey` and `downloadURL`. - parameter options: A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more. - parameter progressBlock: Called every time downloaded data changed. This could be used as a progress UI. - parameter completionHandler: Called when the whole retrieving process finished. - returns: A `RetrieveImageTask` task object. You can use this object to cancel the task. */ @discardableResult public func retrieveImage(with resource: Resource, options: KingfisherOptionsInfo?, progressBlock: DownloadProgressBlock?, completionHandler: CompletionHandler?) -> RetrieveImageTask { let task = RetrieveImageTask() let options = currentDefaultOptions + (options ?? KingfisherEmptyOptionsInfo) if options.forceRefresh { _ = downloadAndCacheImage( with: resource.downloadURL, forKey: resource.cacheKey, retrieveImageTask: task, progressBlock: progressBlock, completionHandler: completionHandler, options: options) } else { tryToRetrieveImageFromCache( forKey: resource.cacheKey, with: resource.downloadURL, retrieveImageTask: task, progressBlock: progressBlock, completionHandler: completionHandler, options: options) } return task } }","categories":[{"name":"源码","slug":"源码","permalink":"https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://mingriweiji-github.github.io/tags/swift/"}]},{"title":"Swift函数式编程","slug":"Swift函数式编程","date":"2020-02-20T02:13:45.000Z","updated":"2020-05-01T12:42:53.935Z","comments":true,"path":"2020/02/20/Swift函数式编程/","link":"","permalink":"https://mingriweiji-github.github.io/2020/02/20/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"Functional Programming in Swift函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。","text":"Functional Programming in Swift函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。 不变性和副作用无论您首先学习哪种编程语言，您可能要学习的最初概念之一就是变量代表数据或状态。如果您退一步考虑一下这个想法，变量似乎很奇怪。 术语“变量”表示随程序运行而变化的数量。从数学角度考虑数量问题，您已将时间作为软件行为的关键参数。通过更改变量，可以创建可变状态。 为了进行演示，请将以下代码添加到playground： var thing = 3 //some stuff thing = 4 func superHero() { print(\"I'm batman\") thing = 5 } print(\"original state = \\(thing)\") superHero() print(\"mutated state = \\(thing)\") 神圣的神秘变化！为什么现在是5？这种变化称为副作用。函数superHero（）更改了一个甚至没有定义自己的变量。 单独或在简单系统中，可变状态不一定是问题。将许多对象连接在一起时（例如在大型的面向对象的系统中）会出现问题。可变状态会使人难以理解变量具有什么值以及该值随时间的变化而产生头痛。 例如，在为多线程系统编写代码时，如果两个或多个线程同时访问同一变量，则它们可能会无序地修改或访问它。这会导致意外的行为。这种意外行为包括竞态条件，死锁和许多其他问题。 试想一下，如果您可以编写状态永远不变的代码。并发系统中发生的所有问题都将消失。像这样工作的系统具有不变的状态，这意味着不允许状态在程序过程中进行更改。 使用不可变数据的主要好处是，使用不可变数据的代码单元没有副作用。代码中的函数不会更改其自身之外的元素，并且在发生函数调用时不会出现怪异的效果。您的程序可以正常运行，因为没有副作用，您可以轻松重现其预期的效果。 本教程从较高的层次介绍了FP，因此在实际情况下考虑这些概念会很有帮助。在这种情况下，假设您正在为游乐园构建应用程序，并且该游乐园的后端服务器通过REST API提供了行程数据。 创建Modelenum RideCategory: String { case family case kids case thrill case scary case relaxing case water } typealias Minutes = Double struct Ride { let name: String let categories: Set&lt;RideCategory> let waitTime: Minutes } Create some data using that modellet parkRides = [ Ride(name: \"R45\", categories: [.family, .thrill, .water], waitTime: 45.0), Ride(name: \"R10\", categories: [.family], waitTime: 10.0), Ride(name: \"R15\", categories: [.kids], waitTime: 15.0), Ride(name: \"R30\", categories: [.scary], waitTime: 30.0), Ride(name: \"R60\", categories: [.family, .thrill], waitTime: 60.0), Ride(name: \"R15-2\", categories: [.family, .kids], waitTime: 15.0), Ride(name: \"R25\", categories: [.family, .water], waitTime: 25.0), Ride(name: \"R0\", categories: [.family, .relaxing], waitTime: 0.0) ] Map 、Filter、 ReduceMost languages that support FP will have the functions filter, map &amp; reduce. Map Map是将输入Collection中的每个Element转换为新Element。 使用map遍历一个集合，并对集合中的每个元素应用相同的操作。 map函数返回一个数组，其中包含对每个元素的映射或转换函数的结果。 Map on array:let arrayOfInt = [1,2,3,4,5] 如果我们要对每个元素乘上10呢？我们以前可能要这样 var newArr: [Int] = [] for value in arrayOfInt { newArr.append(value * 10) } print(newArr) 现在有map()后我们可以这样： let mapArr = arrayOfInt.map { $0 * 10 } print(mapArr) Working of map: The map function has a single argument which is a closure (a function) that it calls as it loops over the collection. This closure takes the element from the collection as an argument and returns a result. The map function returns these results in an array. Map on Dictionarylet book = [\"A\": 100, \"B\": 80, \"C\": 90] let mapedBook = book.map { (key, value) in key.capitalized } print(mapedBook) //[\"C\", \"B\", \"A\"] Map on Setlet lengthInmeter: Set = [1,3,5] let km = lengthInmeter.map { meter in meter * 1000 } print(km) // [1000, 5000, 3000] Map同时获取array.Index??let nums = [1,2,3,4,5] let newNums = nums.enumerated().map { (index, num) in return num * 10 } print(\"newNums:\\(newNums)\") FilterFilter函数的作用是过滤集合，返回符合条件的集合。 Filter on Arraylet filterArray = [2,4,6,1,5,7] let newFilterArray = filterArray.filter { num -> Bool in num % 2 == 0 } print(newFilterArray) Filter on Dictionarylet book = [\"A\": 100, \"B\": 80, \"C\": 90] let bookFilter = book.filter { (key, value) in value > 80 } print(bookFilter) 简化 let book = [\"A\": 100, \"B\": 80, \"C\": 90] let bookFilter = book.filter { $1 > 80 } $0是key $1是value Filter on Setlet setNums = [4.9,5.5,8.6] let newSet = setNums.filter { $0 > 5.0 } print(newSet) 重要：返回类型是数组 Reduce Use reduce to combine all items in a collection to create a single new value. 使用reduce可以合并集合中的所有元素来创建一个新的value Apple文档声明reduce() func reduce&lt;Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -> Result) rethrows -> Result reduce函数有两个参数： 第一个参数 initial value用来存储初始值或者结果（每次迭代器的结果） 第二个是带有两个参数的闭包，Result是初始值或迭代器的结果，Element是集合中的下一个元素。 Reduce on Arraylet numbers = [1,2,3,4,5,6] let sum = numbers.reduce(0) { x, y in x + y } print(sum) 简化版本：使用$0代表result let reducedSum = numbers.reduce(0) { $0 + $1 } print(reducedSum) ///等价 let reducedSum = numbers.reduce(0, +) print(reducedSum) 乘法 let produceNum = numbers.reduce(1) { x, y in x * y } print(produceNum) ///等价 let produceNum = numbers.reduce(1, *) print(produceNum) Reduce + 连接字符串let charactors = [\"abc\",\"def\",\"hijk\"] let newCharactor = charactors.reduce(\"\", +) print(newCharactor) // abcdefhijk Reduce on Dictionary let dict = [\"A\": 20, \"B\": 100] // Reduce on value let reducedNum = dict.reduce(5) { result, dic in return result + dic.value } print(\"reduc on value is \\(reducedNum)\") // reduc on value is 125 // Reduce on key let reducedName = dict.reduce(\"Charactor are \") { (result, dic) in return result + dic.key + \" \" } print(\"reduce on key is &lt;\\(reducedName)>\") //reduce on key is &lt;Charactor are A B > 简化 let reducedNameOnDic = dict.reduce(\"Charater are \") { $0 + $1.key + \" \"} Reduce on Set// Reduce on Set let lengthMeters = [3.4,1.6] let reducedMeters = lengthMeters.reduce(0.0) { $0 + $1 } print(\"reduced meters :\\(reducedMeters)\") // 5.0 FlatMapFlatmap is used to flatten a collection of collections . But before flattening the collection, we can apply map to each elements. Apple docs says: Returns an array containing the concatenated results of calling the given transformation with each element of this sequence. Flatmap用于展平集合的集合。 但是在展平集合之前，我们可以将map应用于每个集合元素。 let charaters = [\"abc\",\"def\",\"ghi\"] let newCharaters = charaters.flatMap { $0 } print(newCharaters) //[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"] let codes = [[\"abc\",\"def\",\"ghi\"], [\"jkl\",\"mno\",\"pqr\"],[\"stu\",\"vwx\",\"yz\"] ] let newCodes = codes.flatMap {$0.map { $0 } } print(newCodes) // [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\"] nillet nilArray = [2,3,nil] print(nilArray.flatMap { $0 }) // [2,3] // warning: 'flatMap' is deprecated: Please use compactMap(_:) for the case where closure returns an optional value print(nilArray.compactMap { $0 }) // [2,3]","categories":[],"tags":[{"name":"swift","slug":"swift","permalink":"https://mingriweiji-github.github.io/tags/swift/"}]},{"title":"Swift备忘录","slug":"Swift备忘录","date":"2020-02-18T02:13:45.000Z","updated":"2020-06-09T00:05:58.883Z","comments":true,"path":"2020/02/18/Swift备忘录/","link":"","permalink":"https://mingriweiji-github.github.io/2020/02/18/Swift%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"SwiftTip","text":"SwiftTip Flip the image: 翻转图片 Retrive the paths: 检索，重新获得 问题记录 柯里化 什么意思 POP 与 OOP的区别 Any 与AnyObject 区别 rethrows 和 throws 有什么区别呢？ break return continue fallthough 在语句中的含义（switch、while、for） 关键字 public open final static class mutating inout infix operator dynamicMemberLookup where @dynamicCallable @autoclosure @escaping 协议 Protocol ExpressibleByDictionaryLiteral Sequence Collection CustomStringConvertible Hashable Codable Comparable RangeReplaceableCollection 以上协议常见应用场景是什么，有什么作用？ 时间戳毫秒let mill = Int64(round(Date().timeIntervalSince1970 * 1000)) let mill = Int64(Date().timeIntervalSince1970 * 1000) Swift 单例class Manager { static let shared = Manager() private init() {} } 这种写法不仅简洁，而且保证了单例的独一无二。 在初始化类变量的时候，Apple 将会把这个初始化包装在一次 swift_once_block_invoke 中，以保证它的唯一性。 不仅如此，对于所有的全局变量，Apple 都会在底层使用这个类似 dispatch_once 的方式来确保只以 lazy 的方式初始化一次。 另外，我们在这个类型中加入了一个私有的初始化方法，来覆盖默认的公开初始化方法，这让项目中的其他地方不能够通过 init 来生成自己的 MyManager 实例，也保证了类型单例的唯一性。 如果你需要的是类似 default 的形式的单例 (也就是说这个类的使用者可以创建自己的实例) 的话，可以去掉这个私有的 init 方法。 摘录来自: 王巍 (onevcat). “Swifter - Swift 必备 Tips (第四版)。” Apple Books. Swift 闭包///定义一个闭包 var itemClickCallback: ((AnalysisSpaceInfo) -> Void)? var rankViewScrollCallBack: (() -> Void)? /// 使用 view.itemClickCallback = { [weak self] item in guard let self = self else { return } self.loadSpaceDetail(id: item.id) } view.rankViewScrollCallBack = { [weak self] in guard let self = self else { return } self.view.isHidden = true } 逃逸闭包static func getInfo(successHandler: ((Bool) -> Void)? = nil) { } static func getInfo(successHandler:@escaping ((Bool) -> Void)) { } iOS初始化核心原则 iOS 的初始化最核心两条的规则： • 必须至少有一个指定初始化器，在指定初始化器里保证所有非可选类型属性都得到正确的初始化（有值） • 便利初始化器必须调用其他初始化器，使得最后肯定会调用指定初始化器 示例如下： public override init(frame: CGRect) { super.init(frame: frame) } public convenience init(style: Style) { self.init(frame: .zero) } 在Swift中千万不要用String的count方法计算文本长度,否则当文本中有emoji时，会计算出错。 应当转成NSString再去求length Swift访问控制权限Swift的访问权限管理依赖于两个概念：module和文件。module是一个完整的代码单元， 它可以是一个或多个框架（Framework），或者是一个App Bundle，可以被import导入到工程中。 文件指的就是Swift File，它通常属于一个module。 Swift 为代码中的实体提供了5种不同的访问级别:open、public、internal、fileprivate、private。 Open 为最高级访问级别，private 为最低级访问级别, internal是module中默认权限，private和fileprivate的区别如下： 访问级别 定义 open 这个属性允许在 app 内或 app 外重写和访问。在开发框架的时候，会应用到这个访问修饰符。 public 可以访问自己模块中源文件里的任何实体，别人也可以通过引入该模块来访问源文件里的所有实体。 internal 默认权限可以访问自己module中源文件里的任何实体 fileprivate 只能在当前源文件中使用。 private 只允许实体在定义的类以及相同源文件内的 extension 中访问 class Person { private var name: String? } *如果希望name仅在当前文件中可访问，可以使用private修饰 * class Person { private(set) var name: String? } 如果希望外部可以读取，但不可以修改。这也是为了保证类型的封装和安全，在内部提供可读可写，而外部仅仅可读 这种写法相当于把setter设置为private，而getter仍然是默认的internal class Person { public private(set) var name: String? } 如果既想要外部可读，又想仅内部可写，可以为getter加上public： 声明关键字associatedtype：在协议中，定义一个类型的占位符名称。直到协议被实现，该占位符才会被指定具体的类型。protocol Entertainment { associatedtype MediaType } class Foo : Entertainment { typealias MediaType = String //可以指定任意类型 } class：通用、灵活的结构体，是程序的基础组成部分。与 struct 类似，不同之处在于： 允许一个类继承另一个类的特性。 类型转换，允许在运行时检查和指定一个类的实际类型。 析构方法允许类的实例释放所有资源。 引用计数允许多个引用指向一个实例。 struct：通用、灵活的结构体，是程序的基础组成部分，并提供了默认初始化方法。与 class 不同，当 struct 在代码中被传递时，是被拷贝的，并不使用引用计数。除此之外，struct 没有下面的这些功能： 使用继承。 运行时的类型转换。 使用析构方法。 struct Person { var name:String var age:Int var gender:String } extension：允许给已有的类、结构体、枚举、协议类型，添加新功能。NSError：code、domin、userInfoSwift Error分类 domain error Recoverable error Universal error Logic error enum Result&lt;T> { case Success(T) case Failure(NSError) } try!表示强制执行，如果发生异常程序crashtry?返回可选项，如果发生异常返回nil 不会crashenum E: Error { case Negative } func methodThrowsWhenPassingNegative(number: Int) throws -> Int { if number &lt; 0 { throw E.Negative } return number } if let num = try? methodThrowsWhenPassingNegative(100) { print(num.dynamicType) } else { print(\"failed\") } Swift 5.1 初始化和反初始化Precondition预处理定义public func precondition(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line) public func preconditionFailure(_ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line) -> Never 使用precondition(condition: Bool, message: String) precondition 在一般的代码中并不多见，因为它是动态的，只会在程序运行时进行检查，适用于哪些无法在编译期确定的风险情况。 如果出现了诸如数据错误的情况，precondition 会提前终止程序，避免因数据错误造成更多的损失。 如果条件判断为 true，代码运行会继续进行。 如果条件判断为 false，程序将终止。 assert 是单纯地触发断言即停止程序，不会让你有机会将可能出错的设计走过它这一关。？？？ 例如：Swift 数组的下标操作可能造成越界，使用扩展的方式向其中增加一个方法来判断下标是否越界。 extension Array { func isOutOfBounds(index: Int) { precondition((0..&lt;endIndex).contains(index), &quot;数组越界&quot;) print(&quot;继续执行&quot;) } }// 不越界的情况 [1, 2, 3].isOutOfBounds(index: 2) // 继续执行 // 越界的情况 [1, 2, 3].isOutOfBounds(index: 3) // Thread 1: Precondition failed: 数组越界 在满足 precondition 条件的时候，程序会继续执行。 在不满足 precondition 条件的时候，程序被终止，并且将 precondition 中预设的错误信息打印到了控制台上，precondition 避免了一些无意义的操作。 precondition和assert的区别 https://stackoverflow.com/questions/29673027/difference-between-precondition-and-assert-in-swift 闭包@autoclosure作用：将表达式自动封装成一个闭包()-&gt;Void 1.2 ??的底层实现是用的enum 1.3 “闭包和循环引用” weak解决循环引用的正确写法： var name: ()->() = { [weak self] in if let strongSelf = self { print(\"The name is (strongSelf.name)\") } } 值类型和引用类型的选择 数组和字典设计为值类型最大的考虑是为了线程安全. 另一个优点，那就是非常高效，因为 “一旦赋值就不太会变化” 这种使用情景在 Cocoa 框架中是占有绝大多数的，这有效减少了内存的分配和回收。 但是在少数情况下，我们显然也可能会在数组或者字典中存储非常多的东西，并且还要对其中的内容进行添加或者删除。” 在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好， 对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary @escaping的作用？ class func animate(withDuration duration: TimeInterval, animations: @escaping () -&amp;gt; Void, completion: ((Bool) -> Void)? = nil) defer的使用注意点defer的作用域 以前很单纯地认为 defer 是在函数退出的时候调用，并没有注意其实是当前 scope 退出的时候调用这个事实，造成了这个错误。在 if，guard，for，try 这些语句中使用 defer 时，应该要特别注意这一点。 @discardableResultResultResult&lt;T, E: Error&gt; 和 Result Lazy的使用 let data = 1...3 let result = data.lazy.map { (i: Int) -> Int in print(\"准备处理(i)\") return i * 2 } print(\"准备访问结果\") for i in result { print(\"处理后的结果:(i)\") } print(\"done\") 打印结果： 准备访问结果 准备处理1 处理后的结果:2 准备处理2 处理后的结果:4 准备处理3 处理后的结果:6 done Swift反射机制Mirror “通过 Mirror 初始化得到的结果中包含的元素的描述都被集合在 children 属性下，如果你有心可以到 Swift 标准库中查找它的定义，它实际上是一个 Child 的集合，而 Child 则是一对键值的多元组： 示例1 struct Car { let logo: String var wheel: Int let door: Int } let baoM = Car(logo: \"BMW\", wheel: 4, door: 2) let mirror = Mirror(reflecting: baoM) print(\"类型:(String(describing: mirror.displayStyle))\") ///1、通过Mirror的children获取属性信息 print(\"属性个数:(mirror.children.count)\") mirror.children.map { (child) -> Any in print(\"label: (String(describing: child.label)), value: (child.value)\") } ///2、通过Refletion的dump(Any)方法获取属性信息 dump(baoM) 示例2 获取property let homeProperty = Mirror(reflecting: self) homeProperty.children.map { LOG.D(\"home property:($0)\") } @propertyWrapper定义与使用@propertyWrapper定义@propertyWrapper struct Clamping&lt;Value: Comparable> { var value: Value let range: ClosedRange&lt;Value> init(initialValue value: Value, _ range: ClosedRange&lt;Value>) { precondition(range.contains(value)) self.value = value self.range = range } var wrappedValue: Value { get { value } set { value = min(max(range.lowerBound, newValue), range.upperBound) } } } 使用struct Solution { @Clamping(0...14) var pH: Double = 7.0 } let carbonicAcid = Solution(pH: 4.68) // at 1 mM under standard conditions @propertyWrapper属性包裹器 | SwiftLee@propertyWrapper /// 先告诉编译器 下面这个UserDefault是一个属性包裹器 struct UserDefault&lt;T> { ///这里的属性key 和 defaultValue 还有init方法都是实际业务中的业务代码 ///我们不需要过多关注 let key: String let defaultValue: T init(_ key: String, defaultValue: T) { self.key = key self.defaultValue = defaultValue } /// wrappedValue是@propertyWrapper必须要实现的属性 /// 当操作我们要包裹的属性时 其具体set get方法实际上走的都是wrappedValue 的set get 方法。 var wrappedValue: T { get { return UserDefaults.standard.object(forKey: key) as? T ?? defaultValue } set { UserDefaults.standard.set(newValue, forKey: key) } } } struct UserDefaultsConfig { @UserDefault(\"has_seen_app_introduction\", defaultValue: false) static var hasSeenAppIntroduction: Bool @UserDefault(\"username\", defaultValue: \"Antoine van der Lee\") static var username: String @UserDefault(\"year_of_birth\", defaultValue: 1990) static var yearOfBirth: Int } ///具体的业务代码。 UserDefaultsConfig.hasSeenAppIntroduction = false print(UserDefaultsConfig.hasSeenAppIntroduction) // Prints: false UserDefaultsConfig.hasSeenAppIntroduction = true print(UserDefaultsConfig.hasSeenAppIntroduction) // Prints: true Other usage examplesProperty wrappers are used throughout the default Swift APIs as well. The new @State and @Binding keys are an example of this. Another idea could be to create a wrapper for thread-specific writing and reading: @ThreadSpecific var localPool: MemoryPool Or, as some might find handy, a way to define command line actions: @Option(shorthand: \"m\", documentation: \"Minimum value\", defaultValue: 0) var minimum: Int Related Ideas A @Positive / @NonNegative property wrapper that provides the unsigned guarantees to signed integer types. A @NonZero property wrapper that ensures that a number value is either greater than or less than 0. @Validated or @Whitelisted / @Blacklisted property wrappers that restrict which values can be assigned. FirstVC via UIViewextension UIView { /// Get current view controller based current view. public func firstViewController() -> UIViewController? { for view in sequence(first: self.superview, next: { $0?.superview }) { if let responder = view?.next { if responder.isKind(of: UIViewController.self) { return responder as? UIViewController } } } return nil } public func firstResponder() -> UIView? { var views = [UIView](arrayLiteral: self) var index = 0 repeat { let view = views[index] if view.isFirstResponder { return view } views.append(contentsOf: view.subviews) index += 1 } while index &lt; views.count return nil } } TopVC via UIWindowif let controller = UIWindow.topViewController() { controller.present(alert, animated: true, completion: nil) } extension UIWindow { /// Returns the top most controller open class func topViewController() -> UIViewController? { let window = UIApplication.shared.delegate?.window let rootViewController = window??.rootViewController return topMost(of: rootViewController) } /// Returns the top most view controller from given view controller's stack. open class func topMost(of viewController: UIViewController?) -> UIViewController? { // presented view controller if let presentedViewController = viewController?.presentedViewController { return self.topMost(of: presentedViewController) } // UITabBarController if let tabBarController = viewController as? UITabBarController, let selectedViewController = tabBarController.selectedViewController { return self.topMost(of: selectedViewController) } // UINavigationController if let navigationController = viewController as? UINavigationController, let visibleViewController = navigationController.visibleViewController { return self.topMost(of: visibleViewController) } // UIPageController if let pageViewController = viewController as? UIPageViewController, pageViewController.viewControllers?.count == 1 { return self.topMost(of: pageViewController.viewControllers?.first) } // child view controller for subview in viewController?.view?.subviews ?? [] { if let childViewController = subview.next as? UIViewController { return self.topMost(of: childViewController) } } return viewController } } DispatchGroup分组管理异步任务 enter和leave必须配对出现，如下： let group = DispatchGroup() group.enter()//把该任务添加到组队列中执行 myQueue?.async(group: group, qos: .default, flags: [], execute: { for _ in 0...10 { print(\"耗时任务一\") group.leave()//执行完之后从组队列中移除 } }) group.enter()//把该任务添加到组队列中执行 myQueue?.async(group: group, qos: .default, flags: [], execute: { for _ in 0...10 { print(\"耗时任务二\") group.leave()//执行完之后从组队列中移除 } }) //当上面所有的任务执行完之后通知 group.notify(queue: .main) { print(\"所有的任务执行完了\") } Swift4.2中的self 在 4.2 之前，self 是全局保留关键字，所以如果在逃逸闭包中如果在闭包中把 self 标记为 weak 后，如果要使用需要使用 ` 包起来： guard let `self` = self else { return } Swift4.2之后 doSomething(then: { [weak self] in guard let self = self { else return } self.doSomethingElse() ) 当然取消了这个限制后也意味着 self 可能不一定是 self 了： var number: Int? = nil if let self = number { print(self) // 这里的 self 是 number：Int } 给Struct 添加属性储存属性///public struct URLRequest : ReferenceConvertible, Equatable, Hashable {} private var KeyIdentifer: Void? extension URLRequest { public internal(set) var key: String? { get { return objc_getAssociatedObject(self, &amp;KeyIdentifer) as? String } set { objc_setAssociatedObject(self, &amp;KeyIdentifer, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } } Bool属性///public struct URLRequest : ReferenceConvertible, Equatable, Hashable {} private var KeyIdentifer: Void? extension xxx { public internal(set) var isSuccess: Bool? { get { return objc_getAssociatedObject(self, &amp;KeyIdentifer) as? Bool } set { objc_setAssociatedObject(self, &amp;KeyIdentifer, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } } typealias使用顾名思义，typealias 是特定类型的别名。类型，例如 Int、Double、UIViewController 或一种自定义类型。Int32 和 Int8 是不同的类型。换句话说，类型别名在你的代码库里插入现有类型的另一个名称。例如： typealias Money = Int 举例struct Bank { typealias DepositMoney = Int typealias WithdrawMoney = Int private var credit: Int = 0 mutating func deposit(amount: DepositMoney) { credit += amount } mutating func withdraw(amount: WithdrawMoney) { credit -= amount } } 提高可读性final class Dispatcher { private var successHandler: ((Int) -> Void)? private var errorHandler: ((Error) -> Void)? func handle(success: ((Int) -> Void)?, error: ((Error) -> Void)?) { self.successHandler = success self.errorHandler = error internalHandle() } func handle(success: ((Int) -> Void)?) { self.successHandler = success internalHandle() } func handle(error: ((Int)-> Void?)) { self.errorHandler = error internalHandle() } private func internalHandle() { ... } } 该结构体引入了两个闭包，一个用于成功情况，一个用于错误情况。但是，我们还希望提供更方便的函数，调用其中一个处理器即可。在上面的示例中，如果要向成功和错误处理器添加另一个参数（例如 HTTPResponse），那么需要更改很多代码。在三个地方，((Int) -&gt; Void)? 需要变成 ((Int, HTTPResponse) -&gt; Void)?。错误处理器也是一样的。通过使用多个类型别名，可以避免这种情况，只需要在一个地方修改类型： final class Dispatcher { typealias Success = (Int, HTTPResponse) -> Void typealias Failure = (Error, HTTPResponse) -> Void private var successHandler: Success? private var errorHandler: Failure? func handle(success: Success?, error: Failure?) { self.successHandler = success self.errorHandler = error internalHandle() } func handle(success: Success?) { self.successHandler = success internalHandle() } func handle(error: Failure?) { self.errorHandler = error internalHandle() } private func internalHandle() { ... } } 组合协议protocol CanRead {} protocol CanWrite {} protocol CanAuthorize {} protocol CanCreateUser {} typealias Administrator = CanRead &amp; CanWrite &amp; CanAuthorize &amp; CanCreateUser typealias User = CanRead &amp; CanWrite typealias Consumer = CanRead 在这里，我们定义了权限层。管理员可以做所有事情，用户可以读写，而消费者只能读。 缺点func first(action: (Int, Error?) -> Void) {} func second(action: Success) {} 第二个不是立即就能明白的。Success 是什么类型？如何构造它？你必须在 Xcode 中按住 Option 单击它，以了解它的功能和工作方式。这会带来额外的工作量。如果使用了许多类型别名，则将花费更多的时间。这没有很好的解决方案，（通常）只能依赖于用例。 callbackvar select1Callback: ((String) -> Void)? var select2Callback: ((IndexPath, Model) -> Void)? 处理cell复用1、prepareForReuse重置 Apple: If a UITableViewCell object is reusable—that is, it has a reuse identifier—this method is invoked just before the object is returned from the UITableView method dequeueReusableCell(withIdentifier:). For performance reasons, you should only reset attributes of the cell that are not related to content, for example, alpha, editing, and selection state. The table view’s delegate in tableView(_:cellForRowAt:) should always reset all content when reusing a cell. If the cell object does not have an associated reuse identifier, this method is not called. If you override this method, you must be sure to invoke the superclass implementation. override func prepareForReuse() { // Clean up if [self.subviews containsObject: self.someNotoriousView] { [self.contentView removeFromSuperview]; } } 2、Swift不安全的指针UnsafePointerUnsafeMutablePointerUnsafeRawPointerUnsafeMutableRawPointer","categories":[],"tags":[{"name":"swift","slug":"swift","permalink":"https://mingriweiji-github.github.io/tags/swift/"}]},{"title":"LookinLoader安装使用","slug":"LookinLoader安装使用","date":"2020-01-20T02:13:45.000Z","updated":"2020-05-01T12:45:25.191Z","comments":true,"path":"2020/01/20/LookinLoader安装使用/","link":"","permalink":"https://mingriweiji-github.github.io/2020/01/20/LookinLoader%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Lookin查看自己的App 1、Lookin下载 2、pod添加：pod &#39;LookinServer&#39;, :configurations =&gt; [&#39;Debug&#39;] 3、pod install 4、打开mac上安装的Lookin 配合LookinLoader查看第三方App 官方：正常情况下，你无法将 LookinServer 嵌入到别人的 iOS App 里，因此你也就无法使用 Lookin 查看别人的 App。但我们也注意到有些第三方开发者通过某些方式实现了向别人的 App 中注入 Framework 的需求，这可能已属于逆向破解范畴，你可在 Github 中搜索 LookinLoader 自行研究，或向他们寻求帮助。 1、LookinLoader安装Step 1 在越狱手机中的「Cydia」-&gt;搜索「LookinLoader」-&gt;「安裝」 Step 2进入设置-&gt;「Lookin」-&gt;「Enabled Applications」-&gt;启用想要查看的App Step 3数据线连接越狱手机到Mac-&gt; 打开要查看的APP -&gt;Mac上打开Lookin -&gt; 查看三方的App。 2、Lookin使用2.1可以看到列表0 2.2可以看到列表6 代理方法：UIScrollViewDelayedTouchesBeganGestureRecognizer 代理方法：UIScrollViewPanGestureRecognizer","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://mingriweiji-github.github.io/tags/iOS/"}]},{"title":"Dyld源码阅读","slug":"Dyld源码阅读","date":"2020-01-15T02:13:45.000Z","updated":"2020-05-01T12:47:36.384Z","comments":true,"path":"2020/01/15/Dyld源码阅读/","link":"","permalink":"https://mingriweiji-github.github.io/2020/01/15/Dyld%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"Dyld源码阅读 Version：dyld-551.4 Lauange：C++ load()调用路径：3566行 load()-&gt;loadPhase0()-&gt;loadPhase1()-&gt;loadPhase2()-&gt;loadPhase4()-&gt;loadPhase5()打开或检查已经存在的动态库：dyld3::findInSharedCacheImage-&gt;loadPhase5load()-&gt;loadPhase5open()-&gt;loadPhase6()-&gt;加载3种Mach-O文件 1、动态库路径iOS越狱手机 在Mac\\iOS中，是使用了/usr/lib/dyld程序来加载动态库 UIKit路径：/system/Library/Frameworks/UIKit.framework 动态库共享缓存：/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64 0x00 load()ImageLoader* load(const char* path, const LoadContext&amp; context, unsigned&amp; cacheIndex) { // try all path permutations and check against existing loaded images ImageLoader* image = loadPhase0(path, orgPath, context, cacheIndex, NULL); if ( image != NULL ) { CRSetCrashLogMessage2(NULL); return image; } // try all path permutations and try open() until first success image = loadPhase0(path, orgPath, context, cacheIndex, &amp;exceptions); if ( image == NULL) image = loadPhase2cache(path, orgPath, context, cacheIndex, &amp;exceptions); #endif CRSetCrashLogMessage2(NULL); } 0x01 loadPhase2()0x02 loadPhase5loadPhase5load（）loadPhase5check（）// open or check existing static ImageLoader* loadPhase5(const char* path, const char* orgPath, const LoadContext&amp; context, unsigned&amp; cacheIndex, std::vector&lt;const char*>* exceptions) { // check for specific dylib overrides for (std::vector&lt;DylibOverride>::iterator it = sDylibOverrides.begin(); it != sDylibOverrides.end(); ++it) { if ( strcmp(it->installName, path) == 0 ) { path = it->override; break; } } if ( exceptions != NULL ) return loadPhase5load(path, orgPath, context, cacheIndex, exceptions); else return loadPhase5check(path, orgPath, context); } 0x03 findInSharedCacheImagestatic bool findInSharedCacheImage(const char* path, bool searchByPath, const struct stat* stat_buf, const macho_header** mh, const char** pathInCache, long* slide) { dyld3::SharedCacheFindDylibResults results; if ( dyld3::findInSharedCacheImage(sSharedCacheLoadInfo, path, &amp;results) ) { *mh = (macho_header*)results.mhInCache; *pathInCache = results.pathInCache; *slide = results.slideInCache; return true; } return false; } bool inSharedCache(const char* path) { return dyld3::pathIsInSharedCacheImage(sSharedCacheLoadInfo, path); } static int imageSorter(const void* l, const void* r) { const ImageLoader* left = *((ImageLoader**)l); const ImageLoader* right= *((ImageLoader**)r); return left->compare(right); } findInSharedCacheImage inSharedCache 0x04 Clang++编译dsc_extractor.cpp生成可执行文件dsc_extractor :$: clang++ -o dsc_extractor dsc_extractor.cpp 抽取动态共享缓存中的Mach-O$: cd xxx/com.apple.dyld $: ./dsc_extractor dyld_shared_cache_arm64 arm64_file dsc_extractor.cpp内容如下: // test program #include &lt;stdio.h> #include &lt;stddef.h> #include &lt;dlfcn.h> typedef int (*extractor_proc)(const char* shared_cache_file_path, const char* extraction_root_path, void (^progress)(unsigned current, unsigned total)); int main(int argc, const char* argv[]) { if ( argc != 3 ) { fprintf(stderr, \"usage: dsc_extractor &lt;path-to-cache-file> &lt;path-to-device-dir>\\n\"); return 1; } //void* handle = dlopen(\"/Volumes/my/src/dyld/build/Debug/dsc_extractor.bundle\", RTLD_LAZY); void* handle = dlopen(\"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle\", RTLD_LAZY); if ( handle == NULL ) { fprintf(stderr, \"dsc_extractor.bundle could not be loaded\\n\"); return 1; } extractor_proc proc = (extractor_proc)dlsym(handle, \"dyld_shared_cache_extract_dylibs_progress\"); if ( proc == NULL ) { fprintf(stderr, \"dsc_extractor.bundle did not have dyld_shared_cache_extract_dylibs_progress symbol\\n\"); return 1; } int result = (*proc)(argv[1], argv[2], ^(unsigned c, unsigned total) { printf(\"%d/%d\\n\", c, total); } ); fprintf(stderr, \"dyld_shared_cache_extract_dylibs_progress() => %d\\n\", result); return 0; } dyld加载流程 dyldStartup.s： call __dyld_start -&gt;call dyldbootstrap::start -&gt; dyldInitialization.cpp: call start()-&gt;_main()-&gt; dyld的start()方法：uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader, uintptr_t* startGlue) { // if kernel had to slide dyld, we need to fix up load sensitive locations // we have to do this before using any global variables if ( slide != 0 ) { rebaseDyld(dyldsMachHeader, slide); } // allow dyld to use mach messaging mach_init(); // kernel sets up env pointer to be just past end of agv array const char** envp = &amp;argv[argc+1]; // kernel sets up apple pointer to be just past end of envp array const char** apple = envp; while(*apple != NULL) { ++apple; } ++apple; // set up random value for stack canary __guard_setup(apple); #if DYLD_INITIALIZER_SUPPORT // run all C++ initializers inside dyld runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple); #endif // now that we are done bootstrapping dyld, call dyld's main uintptr_t appsSlide = slideOfMainExecutable(appsMachHeader); return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue); } dyld的main()方法uintptr_t _main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue) { //1、保存可执行文件header，后面可以根据header访问其他信息 uintptr_t result = 0; sMainExecutableMachHeader = mainExecutableMH; //2、设置上下文信息 setContext(mainExecutableMH, argc, argv, envp, apple); //3、获取可执行文件的路径 sExecPath = _simple_getenv(apple, \"executable_path\"); } 0x05反汇编 Hopper Disassembler [Xclient下载Hopper Disassembler](https://xclie nt.info/s/hopper-disassembler.html#versions) 2、Mach-O文件 Mac 内核xnu 工具：MachOView 来源：C/OC/Swift -&gt; .O目标文件-&gt;Mach-O可执行文件 查看Mac内核中的Mach-O: xnu-6153.11.26-&gt;EXTERNAL_HEADERS-&gt;mach-o 2.1 常见Mach-OMH_EXECUTE-可执行文件 .app/xxx MH_OBJECT-目标文件或静态库 目标文件(.o) 静态库文件(.a)-静态库其实就是多个.o的集合 MH_DYLIB-动态库文件 .dylib .framework/xxx MH_DYLIKER-动态链接编辑器 /usr/lib/dyld MH_DSYM:存储着二进制文件符号信息 .dSYM/Contents/Resources/DWARF/XXX 11种mach-o格式 #define MH_OBJECT 0x1 /* relocatable object file */ #define MH_EXECUTE 0x2 /* demand paged executable file */ #define MH_FVMLIB 0x3 /* fixed VM shared library file */ #define MH_CORE 0x4 /* core file */ #define MH_PRELOAD 0x5 /* preloaded executable file */ #define MH_DYLIB 0x6 /* dynamically bound shared library */ #define MH_DYLINKER 0x7 /* dynamic link editor */ #define MH_BUNDLE 0x8 /* dynamically bound bundle file */ #define MH_DYLIB_STUB 0x9 /* shared library stub for static */ /* linking only, no section contents */ #define MH_DSYM 0xa /* companion file with only debug */ /* sections */ #define MH_KEXT_BUNDLE 0xb /* x86_64 kexts */ Mach-o的作用 The layout of the file depends on the filetype. For all but the MH_OBJECT file type the segments are padded out and aligned on a segment alignment boundary for efficient demand pageing. The MH_EXECUTE, MH_FVMLIB, MH_DYLIB,MH_DYLINKER and MH_BUNDLE file types also have the headers included as part of their first segment. Mach-O的布局取决于文件类型。除了MH_OBJECT以外的所有的文件类型将分段填充并在分段对齐时-对齐有效请求分页的边界。 MH_EXECUTE，MH_FVMLIB，MH_DYLIB，MH_DYLINKER和MH_BUNDLE这些文件也有headers作为它们第一个segment。 The file type MH_OBJECT is a compact format intended as output of the assembler and input (and possibly output) of the link editor (the .oformat). All sections are in one unnamed segment with no segment padding. This format is used as an executable format when the file is so small the segment padding greatly increases its size. 文件类型MH_OBJECT是一种紧凑格式，旨在作为汇编器和链接编辑器（.o的输入）（可能是输出格式）。所有sections都在一个未命名的segment中，没有segment的填充。 当文件太小时segment填充可以大大增加了它的size。此格式用作可执行格式。 The file type MH_PRELOAD is an executable format intended for things that are not executed under the kernel (proms, stand alones, kernels, etc). The format can be executed under the kernel but may demand paged it and not preload it before execution. 文件类型MH_PRELOAD是一种可执行格式，用于非kernel内核下执行。（proms, stand alones, kernels, etc） 格式可以在内核下执行，但可能需要分页而不是在执行之前预加载它。 A core file is in MH_CORE format and can be any in an arbritray legal Mach-O file. Constants for the filetype field of the mach_header 核心文件为MH_CORE格式，可以是任意格式的Mach-O文件。mach_header的文件类型是常量 生成通用二进制文件：Architectures.hpp// // Architectures // struct x86 { typedef Pointer32&lt;LittleEndian> P; }; struct x86_64 { typedef Pointer64&lt;LittleEndian> P; }; struct arm { typedef Pointer32&lt;LittleEndian> P; }; struct arm64 { typedef Pointer64&lt;LittleEndian> P; }; Universal Binary 通用二进制文件，包含多种不同架构的二进制文件，比单个架构的文件大，也叫Fat Binary 由于执行过程中，只是调用一部分代码，所以运行起来也不需要额外的内存。 Xcode生成Universal BinaryStandard architectures $(ARCHS_STANDARD) dyld_cache_format.h#define IPHONE_DYLD_SHARED_CACHE_DIR \"/System/Library/Caches/com.apple.dyld/\" #define DYLD_SHARED_CACHE_BASE_NAME \"dyld_shared_cache_\" FileAbstraction.hpptemplate &lt;typename _E> class Pointer32 { public: typedef uint32_t uint_t; typedef _E E; static uint64_t getP(const uint_t&amp; from) INLINE { return _E::get32(from); } static void setP(uint_t&amp; into, uint64_t value) INLINE { _E::set32(into, (uint32_t)value); } // Round to a P-size boundary template &lt;typename T> static T round_up(T value) { return (value+3) &amp; ~(T)3; } template &lt;typename T> static T round_down(T value) { return value &amp; ~(T)3; } }; template &lt;typename _E> class Pointer64 { public: typedef uint64_t uint_t; typedef _E E; static uint64_t getP(const uint_t&amp; from) INLINE { return _E::get64(from); } static void setP(uint_t&amp; into, uint64_t value) INLINE { _E::set64(into, value); } // Round to a P-size boundary template &lt;typename T> static T round_up(T value) { return (value+7) &amp; ~(T)7; } template &lt;typename T> static T round_down(T value) { return value &amp; ~(T)7; } }; 3、dyld与Mach-O的关系 dyld属于MH_DYLDLINKER类型的Mach-O文件 dyld负责加载三种类型Mach-O文件 可执行文件 动态库 Bundle mach-o loader：only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded // try mach-o loader if ( shortPage ) throw \"file too short\"; if ( isCompatibleMachO(firstPages, path) ) { // only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded const mach_header* mh = (mach_header*)firstPages; switch ( mh->filetype ) { case MH_EXECUTE: case MH_DYLIB: case MH_BUNDLE: break; default: throw \"mach-o, but wrong filetype\"; } uint32_t headerAndLoadCommandsSize = sizeof(macho_header) + mh->sizeofcmds; if ( headerAndLoadCommandsSize > MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE ) throwf(\"malformed mach-o: load commands size (%u) > %u\", headerAndLoadCommandsSize, MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE); if ( headerAndLoadCommandsSize > fileLength ) dyld::throwf(\"malformed mach-o: load commands size (%u) > mach-o file size (%llu)\", headerAndLoadCommandsSize, fileLength); if ( headerAndLoadCommandsSize > 4096 ) { // read more pages unsigned readAmount = headerAndLoadCommandsSize - 4096; if ( pread(fd, &amp;firstPages[4096], readAmount, fileOffset+4096) != readAmount ) throwf(\"pread of extra load commands past 4KB failed: %d\", errno); } // instantiate an image ImageLoader* image = ImageLoaderMachO::instantiateFromFile(path, fd, firstPages, headerAndLoadCommandsSize, fileOffset, fileLength, stat_buf, gLinkContext); // validate return checkandAddImage(image, context); } 4、符号地址符号地址= 基地址 - 偏移地址 获取基地址//获取基地址 uintptr_t get_load_address(void) { const struct mach_header *exe_header = NULL; for (uint32_t i = 0; i &lt; _dyld_image_count(); i++) { const struct mach_header *header = _dyld_get_image_header(i); if (header->filetype == MH_EXECUTE) { exe_header = header; break; } } //返回值即为加载地址 return (uintptr_t)exe_header; } 获取偏移地址uintptr_t get_slide_address(void) { uintptr_t vmaddr_slide = NULL; for (uint32_t i = 0; i &lt; _dyld_image_count(); i++) { const struct mach_header *header = _dyld_get_image_header(i); if (header->filetype == MH_EXECUTE) { vmaddr_slide = _dyld_get_image_vmaddr_slide(i); break; } } return (uintptr_t)vmaddr_slide; } dSYM文件 编译时添加选项：DWARF with dSYM File，在编译打包完成之后就会生成调试符号文件（Mach-O文件） 文件查找：找到.xcarchive文件→show package contents→…一直到DWARF→工程二进制文件 atos命令有了dSYM文件，就可以使用atos命令查找到具体代码行出现奔溃信息的地方 atos [-o executable] [-l loadAddress] [-arch architecture] [address ...] #-arch 选择框架arm64/arm32/x86_64 4、Crash收集KSCrashSentryCocoa SentryCrashDynamicLinker","categories":[{"name":"源码","slug":"源码","permalink":"https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://mingriweiji-github.github.io/tags/iOS/"}]},{"title":"iOS越狱初体验","slug":"iOS越狱初体验","date":"2020-01-15T02:13:45.000Z","updated":"2020-05-01T12:44:13.300Z","comments":true,"path":"2020/01/15/iOS越狱初体验/","link":"","permalink":"https://mingriweiji-github.github.io/2020/01/15/iOS%E8%B6%8A%E7%8B%B1%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"","text":"iOS越狱初体验iOS越狱能做到什么？ 查看 第三方APP UI 排版方式、布局实现技术 获取三方App内部资源 .assets/.plist/icon… 修改APP 功能重新打包 (EX: 去广告) 反编译推测原始工程代码内容 dump 出 .h 头文件 / keycahin / db 越狱环境macOS 版本：10.15 CatalinaiOS 版本：iPhone 5s (iOS 9.0.1/ 完美越狱***必要)**Cydia: Open SSH 逆向工程大致流程： 解密并导出应用程序、class-dump导出头文件 从当面界面入手，获取当前界面布局和控制器VC hook相关类，记录输出调用的顺序和参数 关键函数，查看调用堆栈，hook测试结果 静态分析+动态调试分析关键函数的实现逻辑 模拟或篡改函数调用逻辑 制作插件或移植到非越狱设备上 1、越狱环境搭建 完美越狱的5c手机iOS8-iOS8.4 or 完美越狱的5s系统iOS9-iOS9.1 Mac安装 iFunBox:管理文件系统 iPhone安装 爱思助手 Cydia 通过Cydia安装下面的源到越狱设备上 Apple File Conduit 2：可以访问整个iOS文件系统 iFile: 可以自由访问iOS文件系统 2、Mac远程登录到iPhone使用SSH（Secure Shell安全外壳协议）来远程登录iPhone 使用SSH将所有传输的数据加密，防止DNS欺骗和IP欺骗 使用OpenSSH协议让Mac远程登录到iPhone iPhone上通过Cydia来安装OpenSSH工具 Cydia搜索OpenSSH 安装Openssh Mac终端： ssh root@host 输入初始密码alpine 退出登录：exit $ ssh root@192.168.0.110 root@192.168.0.110's password: password for ssh root@host$ sudo -s $ passwd Changing password for root. New password: Retype new password: 报错：ImportError: No module named usbmux 重新下载 usbmuxd工具包 保留python-client 文件夹 变更服务器身份信息 删除公钥信息：ssh-keygen -R yourIPAddress 删除known_hosts文件：vim ~/.ssh/known_hosts SSH基于秘钥的客户端认证 在客户端生成一对秘钥：公钥+私钥 $: ssh-keygen 一路敲回车键（Enter）即可 OpenSSH默认生成的是RSA密钥，可以通过-t参数指定密钥类型 生成的公钥：~/.ssh/id_rsa.pub 生成的私钥：~/.ssh/id_rsa 将客户端的公钥追加到服务器的授权文件尾部:~/.ssh/authorized_keys ssh-copy-id root@yourIPAddressshell脚本文件 通过sh、bash、source命令执行sh脚本文件 sh和bash会在当前shell环境启动一个子进程来执行文件，执行后返回到父进程的shell环境 执行cd时，子进程会进入到cd的目录，但是父进程的环境并未改变-即目录没有改变 source 在当前shell环境执行脚本文件 执行cd后自动跳转到cd的目录 source可以用”.”代替，比如”.test.sh”使用source来执行shell脚本test.sh 基于秘钥登录 1、在客户端生成一对相关联的密钥，将客户端的公钥信息追加到服务器的授权文件尾部（~/.ssh/authorized_keys）: 生成秘钥：ssh-keygen 追加到服务器授权文件：ssh-copy-id root@手机IP地址 复制客户端的公钥：scp ~/.ssh/id_rsa.pub root@服务器主机地址:~ SSH登录服务器：ssh root@服务器主机地址 2、执行脚本: python ~/tcprelay.py -t 22:10086 利用usbmuxd编写的py脚本将Mac的10086端口连接到iPhone上的22端口上Mac登录到10086端口： ssh -p 10086 root@localhost 3、Mac登录到10086端口： ssh -p 10086 root@localhost 5s:~/.ssh root# cat authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDIoCG1j95eGXgui0R8JRMSe2AHGi3RV7L1SNU/06WK21pc4tqwgiUphPwnf+yQ1SlhV4KH6utZWDa4STugDdp+nuUpMF7HYC+4iGSqP6GCpgiV+3ehqHd5cYhPIPUWinISJNJkIYU8HBUTw1Ua9HqTxrrIhV+AbZhKymDDJ+1X3+dnhu0yNZ2W4HpFDwAT9OB4go2PTGROyneHEz72bvcTAqkDdbKjbKOPD61bzlbHJqBAb0wCeTPEYWNwxb+lRcvzFs61TwCuLXQJ+GCyAtKZYzU/I9DGgfhgWQ38xB04rGMPjqOeEDRI9T8j8r3q8wP+K0BJmTlaMhYfl70U1ZUDPbqgfD93IpL4h+Mb0nqvWwkcqaFB4NPgrwvJG5WYWmR1mgu37rzC2f9BDUDz4izwSyEQDk7PwaLuuBfJet6Ro/vdHXGwUhTXP01Tkg+Qj/qcN7aMvPMXHkWNS6v83urRHwFgSSqJ1QC6O3xZlHZeRfPFt7UhcqgAGEgs8K2aCAc= Seven@MLideMacBook-Pro.local 5s:~/.ssh root# cd /etc/ssh 5s:/etc/ssh root# ls -l total 272 -rw-r--r-- 1 root wheel 242153 May 4 2018 moduli -rw-r--r-- 1 root wheel 1526 May 4 2018 ssh_config -rw------- 1 root wheel 672 May 4 2018 ssh_host_dsa_key -rw-r--r-- 1 root wheel 590 May 4 2018 ssh_host_dsa_key.pub -rw------- 1 root wheel 965 May 4 2018 ssh_host_key -rw-r--r-- 1 root wheel 630 May 4 2018 ssh_host_key.pub -rw------- 1 root wheel 1679 May 4 2018 ssh_host_rsa_key -rw-r--r-- 1 root wheel 382 May 4 2018 ssh_host_rsa_key.pub -rw-r--r-- 1 root wheel 3227 May 4 2018 sshd_config 5s:/etc/ssh root# cat ssh_host_rsa_key.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDMQHoD19uC7fQpPXMN6GWR0YcGC7BlmLis4uyuu6hk7bqDADfHlXvU5cJ6gxSkrwjzFrWPcVD5JfyrAWEw2VGMxgtMoBTOjCRciDR+yJioTbeL85r8UdT5CtVDjGkiC+07SGopHnYt1x+45lMIMzdzVbLhKTv+DIm+OIawavJSIOvhHLlf4kFrrj0vuxkDOpV8fSRdnHLKMayQ6dmgFRlYJJSCLx10VLpUhgLA6g3m3wIq5bDSoR75uEYVUYny+itCQxVXFfydKsKncBAlxE2vKKh5Ry/pQaWFBff3jEDgfFtmqGtj5y3MlLjdtqn4zLTE3FwqCAEen63+gR8z4wof 5s:/etc/ssh root# 基于USB登录 下载usbmuxd工具包（下载v1.0.8版本，主要用到里面的一个python脚本：tcprelay.py）https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz 1、Mac登录到10010端口:python tcprelay.py -t 22:10010 2、将iPhone的22端口（SSH端口）映射到Mac本地的10010端口:ssh root@localhost -p 10010 $ python ~/pathto/python-client/tcprelay.py -t 22:10010 $ ssh root@localhost -p 10010 3、Cycript动态调试 它是Objective-C++、JavaScript、Java等语法的混合产物 用来修改和调试正在运行中的Mac/iOS 应用 官网：http://www.cycript.org/ Cydia安装Cycript后，即可在iPhone上调试运行中的App 1、Cycript安装问题$ cycript dyld: Library not loaded: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib Referenced from: /Users/mli/cycript_0.9.594//Cycript.lib/cycript-apl Reason: image not found [1] 8373 abort cycript 方式1：替换libruby.2.6.dylib解决方式一：由于我的MacOS是版本10.15.4 Catalina,自带ruby版本是2.6 如果你用homebrew已经安装过高版本的Ruby，那么你可以进到/usr/local/Cellar/ruby/2.6.0/lib这个目录下，将libruby.2.6.dylib拷贝一份，然后改名为libruby.2.0.0.dylib。并将改名后的文件拷贝到Cycript.lib目录下即可。 ~: $ source .bash_profile ~: $ cycript cy# 出现cy#表示成功了 control + D可以退出 Cycript。 如果是使用iTerm2+oh my zsh组合，可以在.zshrc配置文件中导入source .bash_profile，这样每次打开就不用手动执行了！ $ open ~/.zshrc 添加配置：source ~/.bash_profile 方式2:安装ruby2.0方式二：测试该方式对于MacOS Catalina无效，中文博客都是这种方式，brew install ruby@2.0 也无法在Catalina系统上通过，所以直接修改libruby.2.6.dylib为libruby.2.0.0.dylib是简单有效的方法 1、关闭Mac的SIP 电脑重启，听到咚的时候，按住command+R，进入恢复模式 打开终端，输入csrutil disable，重启 2、查看ruby版本安装ruby2.0$ cd /System/Library/Frameworks/Ruby.framework/Versions/ $ ls 2.6 Current $ brew install ruby@2.0 3、我的ruby版本是2.6直接把本机的ruby版本的复制一份，改为2.0即可 1、关闭系统的禁用新版SIP防护 电脑重启按住command+R，进入恢复模式 打开终端，输入csrutil disable，重启 如果想打开SIP，重复上两步，命令改为csrutil enable 2、禁用SIP之后，在终端输入sudo mount -uw /，然后重启finder之后就可以对文件夹进行复制了，复制之后，对文件夹和文件名称修改为2.0，就可以正常使用Cycript了 sudo mkdir -p /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ sudo ln -s /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/libruby.2.6.0.dylib /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib 2、Cycript使用进程名称/进程ID终端输入命令行： $ ps -A 启动越狱iPhone上的App如下： /var/mobile/Containers/Bundle/Application/AAB4F619-1565-4D60-98B7-9A5465674C0E/ElevenPlayer.app/ElevenPlayer /var/mobile/Containers/Bundle/Application/B15E42B6-EFF0-482A-A184-2E56E18BC096/Taobao4iPhone.app/Taobao4iPhone /var/mobile/Containers/Bundle/Application/6907C865-4845-4423-92BF-65D61F4B9816/DingTalk.app/DingTalk ElevenPlayer Taobao4iPhone DingTalk Cycript调试1、通过Cydia安装Cycript 2、终端输入： cycript -p Taobao4iPhone Cycript基本语法 UIApp: [UIApplication sharedApplication] var 变量名 = 变量值 通过内存地址获取内存中的对象: #内存地址 已经加载的所有OC类：ObjectiveC.classes 获取某个对象所有的成员变量：*对象名 递归打印view的所有子view: view.recursiveDescription().toString()等同于Xcode中的[view recursiveDescription] 筛选某种类型的对象: choose(UIViewController) choose(UITableViewCell) 5s:~ root# cycript -p 1856 cy# UIApp #\"&lt;UIApplication: 0x147e6db70>\" cy# var win = #0x147e6db70.keyWindow #\"&lt;UIWindow: 0x1490eba30; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x1490ed500>; layer = &lt;UIWindowLayer: 0x1490e3f50>>\" cy# UIApp.keyWindow.rootViewController #\"&lt;TBMainViewController: 0x14807b200>\" cy# choose(UICollectionViewCell) .... UIApp.keyWindow.recursiveDescription().toString()可以打印所有层级 3、使用mjcript.cy 基于Cycript实现的一些实用函数，下载地址：https://github.com/CoderMJLee/mjcript 1、下载mjcript库 2、将mjcript.cy文件拖到/usr/lib/cycript0.9 3、SSH连接iOS设备 4、使用Cycript监听APP，通过命令@import mjcript 导入 以前获取当前控制器 cy# UIApp.keyWindow.rootViewController.presentedViewController cy# #0x1483cb600.childViewControllers mjcript获取当前控制器cy# MJFrontVc() cy# MJVcSubviews(#0x12fe775e0) 获取实例方法和类方法cy# MJInstanceMethods(#0x12fe775e0) cy# MJClassMethods(#0x12fe775e0) python获取unicode$ python >>> unicode('开始使用','UTF-8') u'\\u5f00\\u59cb\\u4f7f\\u7528' 获取网易登录界面cy# MJFrontVc() #\"&lt;NTESNBLoginController: 0x12fe775e0>\" cy# MJFrontVcSubViews(#0x12fe775e0) cy# [#0x12fe775e0.view addSubview:view] 获取login相关方法cy# MJInstanceMethods(#0x12fe775e0,/login/) [{selector:@selector(loginEngine),type:&amp;\"@16@0:8\"},{selector:@selector(loginBtnDidClicked:),type:&amp;\"v24@0:8@16\"},{selector:@selector(loginDelegate),type:&amp;\"@16@0:8\"},{selector:@selector(loginBottomSafeAreaHeight),type:&amp;\"d16@0:8\"},{selector:@selector(loginStyleDesc),type:&amp;\"@16@0:8\"}] 获取login相关成员变量cy# MJIvars(#0x12fe775e0,/login/) {_loginEngine:#\"&lt;NTESNBLoginEngine: 0x12fd390e0>\",_loginDelegate:#\"&lt;NTESNBLoginService: 0x12f024f50>\",_loginStyleDesc:#\"&lt;UILabel: 0x12fe78000; frame = (25 155; 80 22.5); text = '\\xe6\\x89\\x8b\\xe6\\x9c\\xba\\xe5\\x8f\\xb7\\xe7\\x99\\xbb\\xe5\\xbd\\x95'; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x12dff5b80>>\"} 4、Reveal安装与使用安装 当前的Cydia中软件源-http://apt.so/codermjlee已连接不上，直接下载Reveal2Loader_1.0-3的deb文件 网盘链接: 提取码: gk6j 下载后直接把deb文件放在手机的Device/var/root路径下 安装之前需要先Cydia中安装Applist和RocketBootstrap Cydia中安装ExtensionList 安装reveal2load报错extensionlist is not installed.:5s:~ root# dpkg -i Reveal2Loader_1.0-3_iphoneos-arm.deb (Reading database ... 3159 files and directories currently installed.) Preparing to unpack Reveal2Loader_1.0-3_iphoneos-arm.deb ... Unpacking reveal2loader (1.0-3) over (1.0-3) ... dpkg: dependency problems prevent configuration of reveal2loader: reveal2loader depends on com.zidaneno5.extensionlist; however: Package com.zidaneno5.extensionlist is not installed. dpkg: error processing package reveal2loader (--install): dependency problems - leaving unconfigured Errors were encountered while processing: reveal2loader 解决方法： Cydia搜索并安装ExtensionList 1.0-1 再次执行 dpkg -i Reveal2Loader_1.0-3_iphoneos-arm.deb 5s:~ root# dpkg -i Reveal2Loader_1.0-3_iphoneos-arm.deb (Reading database ... 3164 files and directories currently installed.) Preparing to unpack Reveal2Loader_1.0-3_iphoneos-arm.deb ... Unpacking reveal2loader (1.0-3) over (1.0-3) ... Setting up reveal2loader (1.0-3) ... done *The operation couldn’t be completed. * The app is linked against an older version of the Reveal library. You may need to update the Reveal library in your app. Reveal破解版不可用 如有破解版Reveal可参考：https://www.jianshu.com/p/f37ea9b9d2f3 5、脱壳5.1 通过ipa获取Mach-O PP助手下载的ipa包是解密后的包 Apple Configurator 2下载的ipa包是加密包 使用Apple Configurator 2下载ipa 1、安装Apple Configurator 2 2、进入Finder：~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/ 获取ipa，记得复制出来，弹框消失后IPA文件也会消失 3、如果在解压ipa包时，出现“IPA已损坏 移除到垃圾篓”之类的提示，可以尝试把后缀名.ipa修改成.zip 4、解压zip包-&gt;进入Payload-&gt; 右键显示包内容-&gt;获取可执行文件如下 4中获取的可执行文件不能正常导出头文件的话，直接查找越狱设备的一下路径： /var/mobile/Containers/Bundle/Application/可以获取当前越狱设备中安装的应用的.app文件，直接拷贝到Mac的Desktop上 ps -A查看当前App也能看到上面这个路径 5.2 Class-dump1、下载地址：http://stevenygard.com/projects/class-dump/ 2、打开终端输入 open /usr/local/bin 3、把dmg文件中的class-dump文件复制到/usr/local/bin 4、更改权限：终端输入 sudo chmod 777 /usr/local/bin/class-dump 5、显示class-dump的用法和版本: class-dump --help 6、cd 到5.1获取的Mach-O文件所在目录 用终端输入命令 class-dump -H [MachO文件的路径] -o [输出文件夹路径],就可以得到所有的.h文件了 自己编译的项目没有加密，能够解析出来。class-dump不能直接将AppStore上的app的头文件导出来，你只会导出CDStructures.h这个头文件，而这里边基本是没有信息的。相当于Apple在app上加了一层壳（加密了），需要把这层壳砸破。 class-dump -H test.decrypted -o test，但是只能导出CDStructures.h，这个文件，但是 于是就使用class-dump -arch armv64 -H test.decrypted -o test 来导出，竟然能导出所有的头文件了。 5.2查看可执行文件是否加密？使用MachOView Load Commands -&gt; LC_ENCRYPTION_INFO -&gt; Crypt ID的值 0代表未加密 使用otoolotool -l machoFile | grep cycript 5.3、Clutch脱壳/usr/bin/Clutch Permission denied5s:~ root# Clutch -sh: /usr/bin/Clutch: Permission denied 权限不够，输入命令如下： 5s:~ root# chmod +x /usr/bin/Clutch 5s:~ root# Clutch Usage: Clutch [OPTIONS] -b --binary-dump &lt;value> Only dump binary files from specified bundleID -d --dump &lt;value> Dump specified bundleID into .ipa file -i --print-installed Print installed applications --clean Clean /var/tmp/clutch directory --version Display version and exit -? --help Display this help and exit -n --no-color Print with colors disabled Clutch -i 查看可以脱壳的App5s:~ root# Clutch -i Installed apps: 1: 知识星球 &lt;com.unnoo.quan> 2: 爱思加强版 &lt;com.pd.A4Player> 3: 饿了么 &lt;me.ele.ios.eleme> 4: 暴走漫画 &lt;goodluck.push.baozou> 5: 喜马拉雅「听书社区」电台有声小说相声评书 &lt;com.gemd.iting> 6: 微视 &lt;com.tencent.microvision> 7: 猿辅导-小学初中高中全科在线互动直播课 &lt;com.fenbi.tutor> 8: 今日头条 &lt;com.ss.iphone.article.News> 9: 手机淘宝 &lt;com.taobao.taobao4iphone> 10: 爱奇艺 &lt;com.qiyi.iphone> 11: 全民K歌 &lt;com.tencent.QQKSong> 12: 钉钉 &lt;com.laiwang.DingTalk> 13: 书旗小说 &lt;com.shuqicenter.reader> 14: QQ &lt;com.tencent.mqq> 15: 快手极速版 &lt;com.kuaishou.nebula> 16: 腾讯新闻 &lt;com.tencent.info> 17: 京东 &lt;com.360buy.jdmobile> 18: 腾讯视频 &lt;com.tencent.live4iphone> 19: 微信读书 &lt;com.tencent.weread> 20: 布卡漫画 &lt;bukaios.ibuka.com> 21: 支付宝 &lt;com.alipay.iphoneclient> 22: 快手 &lt;com.jiangjia.gif> 23: 网易新闻 &lt;com.netease.news> 24: 抖音短视频 &lt;com.ss.iphone.ugc.Aweme> Cluth -d 获取ipa文件5s:~ root# Clutch -d 4 Zipping BaoManReader.app Swapping architectures.. ASLR slide: 0xd0000 Dumping &lt;BaoManReader> (armv7) Patched cryptid (32bit segment) Writing new checksum ASLR slide: 0x100038000 Dumping &lt;BaoManReader> (arm64) Patched cryptid (64bit segment) Writing new checksum DONE: /private/var/mobile/Documents/Dumped/goodluck.push.baozou-iOS8.0-(Clutch-2.0.4).ipa Finished dumping goodluck.push.baozou in 29.4 seconds 脱壳后生成IPA文件 IPA生成后的路径: /var/mobile/Documents/Dumped/拷贝到桌面上查看当前的加密状态 $ otool -l BaoManReader_old | grep crypt cryptoff 16384 cryptsize 10403840 cryptid 1 cryptoff 16384 cryptsize 11370496 cryptid 1 存在加密id $ otool -l BaoManReader | grep crypt cryptoff 16384 cryptsize 10403840 cryptid 0 cryptoff 16384 cryptsize 11370496 cryptid 0 不存在加密的id class-dump导出头文件headers$ class-dump -H BaoManReader -o Headers","categories":[{"name":"源码","slug":"源码","permalink":"https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://mingriweiji-github.github.io/tags/iOS/"}]},{"title":"算法实战","slug":"2020算法实战100道","date":"2019-06-21T19:18:15.000Z","updated":"2020-05-01T12:51:26.234Z","comments":true,"path":"2019/06/22/2020算法实战100道/","link":"","permalink":"https://mingriweiji-github.github.io/2019/06/22/2020%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98100%E9%81%93/","excerpt":"","text":"为什么学算法？为什么要学习算法？ 算法是内功，决定你武功的高度 算法能让你更好更快理解一门语言系统的设计理念 算法能让你触类旁通 momo算法题：接雨水 反转链表II 旋转矩阵 主要算法 基础技巧：分治、二分、贪心 排序算法：快速排序、归并排序、计数排序 搜索算法：回溯算法、递归、深度优先遍历，BFS广度优先遍历，二叉搜索树等 图论：最短路径、最小生成树 动态规划：背包问题、最长子序列 数据结构 数组与链表：单 / 双向链表 栈与队列 哈希表 堆：最大堆 ／ 最小堆 树与图：最近公共祖先、并查集 字符串：前缀树（字典树） ／ 后缀树 1、常见数据结构数组 链表 栈 队列 树 有效的字母异位词 每K个一组翻转链表 数组中第K个最大元素 合法的括号 每日温度 滑动窗口最大值 二叉搜索树中第K小的元素 链表 0) 删除链表中的节点 1) 单链表反转 2) 环形链表 &amp; II 3) 合并两个有序的链表 4) 删除链表倒数第n个结点 5) 求链表的中间结点 1) 2. 两数相加 Meidum 2) 删除链表的倒数第N个节点 Medium 3) 两数相加 II Medium 4) 删除链表中的节点 Easy 5) 奇偶链表 6) 反转链表 Easy 7) 反转链表 II Medium 8) 两两交换链表中的节点 Medium方法1：非递归方法2：递归 9) 相交链表 Easy 10) 回文链表 Easy 11) 合并两个有序链表 Easy 12) 环形链表 Easy 13）环形链表 II Medium方法1：Hash方法2：快慢指针（Floyd 算法）方法3：快慢指针（普通法） 2、高级数据结构 优先队列：前K个高频单词 二叉树 [leetcode二叉树系列]1 二叉树的中序遍历 [leetcode二叉树系列]2 二叉树的层次遍历 [leetcode二叉树系列]5 二叉树翻转 图： 检测一个图是否为二部图 前缀树：单词查找II 线段树：计算后续较小元素的数量 树状数组：二位区域求和 3、排序 冒泡排序 插入排序 归并排序 快速排序 拓扑排序 4、递归与回溯 解码的方法 中心对称数 组合总数 N皇后 5、深度优先于广度优先搜索 深度优先于广度优先搜索递归实现 复杂度 LeetCode:寻找最短路径 6、动态规划 LeetCode:求最长的一个上升子序列 动态规划难点：递推公式 动态规划解题分类（一）：线性规划 LeetCode经典:不同路径 动态规划解题分类（二）：区间规划 LeetCode经典:最长的回文子序列 动态规划解题分类（三）：约束规划 LeetCode经典: 0-1背包问题 7、二分搜索与贪婪 34. 在排序数组中查找元素的第一个和最后一个位置 从有序数组中找第一个大于K的数 搜索旋转排序数组 日志查询 8、高频真题 无重复字符的最长子串 求两个排序树组的中位数 合并K个有序链表 合并区间 无重叠区间 火星字典 基本计算器 正规表达式匹配 柱状图中最大的矩形 实现strStr()-KMP算法 回文对 至多包含K个不同字符的最长子串 收集雨水II 9、字节Top50 1) 两数之和 2) 两数相加 3) 无重复字符的最长子串 4) 最长回文子串 5) 接雨水 6) 反转链表 7) 寻找两个有序数组的中位数 8) 盛最多水的容器 9) 两数之和 10) 合并两个有序链表 11) 最大子序和 12) LRU缓存机制 13) K 个一组翻转链表 14) 买卖股票的最佳时机 15) 分发糖果 16) 搜索旋转排序数组 17) 有效的括号 18) 合并K个排序链表 19) 合并区间 20) 整数反转 21) 字典序的第K小数字 22) 回文数 23) 数组中的第K个最大元素 24) 全排列 25) 删除链表的倒数第N个节点 26) 下一个排列 27) 编辑距离 28) 岛屿数量 29) 复原IP地址 30) 爬楼梯 31) 正则表达式匹配 32) 相交链表 33) 二叉树的中序遍历 34) 二叉树的层次遍历 35) 二叉树的锯齿形层次遍历 36) 对称二叉树 37) 二叉树的右视图 38) 零钱兑换 39) 螺旋矩阵 40) 字符串转换整数 (atoi) 41) 括号生成 42) 合并两个有序数组 43) 重排链表 44) 最长公共前缀 45) 二叉树的最大深度 46) 第二高的薪水 47) 最长有效括号 48) 两两交换链表中的节点 49) 单词搜索 50) 买卖股票的最佳时机 II 10、LeetCode top100top100","categories":[{"name":"算法","slug":"算法","permalink":"https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://mingriweiji-github.github.io/tags/swift/"}]},{"title":"算法基础","slug":"2020算法基础","date":"2019-06-21T18:18:15.000Z","updated":"2020-05-01T12:39:17.673Z","comments":true,"path":"2019/06/22/2020算法基础/","link":"","permalink":"https://mingriweiji-github.github.io/2019/06/22/2020%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"算法基础为什么要学习算法？ 算法是内功，决定你武功的高度 算法能让你更好更快理解一门语言系统的设计理念 算法能让你触类旁通 1 、数组 func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) { var p1 = m - 1, p2 = n - 1 var cur = m + n - 1 while (p2 >= 0) { if (p1 >= 0 &amp;&amp; nums1[p1] >= nums2[p2]) { nums1[cur] = nums1[p1] cur -= 1; p1 -= 1 } else { nums1[cur] = nums2[p2] cur -= 1; p2 -= 2 } } } 面试题 16.16. 部分排序func subSort(_ array: [Int]) -> [Int] { //1 从左往右扫描，应该越来越大，出现比max小的，记录下来 //2 从右往左扫描，应该越来越小，出现比min小的，记录下来 //临界条件（array.count &lt; 2） if array.count &lt; 2 { return [-1, -1] } var max = array[0], R = -1 for i in 0..&lt;array.count { let v = array[i] if v >= max { max = v } else { R = i } } //如果有序 if R == -1 { return [-1, -1] } var min = array[array.count - 1], L = -1 for i in (0...(array.count - 2)).reversed() { let v = array[i] if v &lt;= min { min = v } else { L = i } } return [L, R] } /* 75. 颜色分类 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 */ func setColors(_ nums: inout [Int]) { //1、遇到0 和 left交换，left++ cur++ //2、遇到1 cur++ //3、遇到2 和 right交换，right-- cur++ :更正交换后right--但是cur不能++，因为right的位置需要重新判断 //循环条件cur&lt;=right var cur = 0, left = 0, right = nums.count - 1 while cur &lt;= right { let curNum = nums[cur] if curNum == 0 { swapNum(&amp;nums, cur, left) cur += 1 left += 1 } else if curNum == 1 { cur += 1 } else { swapNum(&amp;nums, cur, right) //注意：遇到2和right交换值以后，right--需要重新判断cur的值，所以cur不能++ //cur += 1 right -= 1 } } } func swapNum(_ nums: inout [Int], _ i: Int, _ j: Int) { let temp = nums[i] nums[i] = nums[j] nums[j] = temp } 2、链表public class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } 1： 删除链表中的节点class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } 2：反转链表 题目描述：反转一个单链表。 Solution1: 递归法 public ListNode reverseList(ListNode head) { if(head == null) return head; if(head.next == null) return head; ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead; } Solotion2: 非递归-双指针（https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/） 正确示例 public ListNode reverseList(ListNode head) { if(head == null) return head; if(head.next == null) return head; ListNode newHead = null; while (head != null) { ListNode temp = head.next; head.next = newHead; newHead = head; head = temp; } return newHead; } 3：反转链表 II 题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 4：环形链表 第一步：找到快慢指针相遇的节点，如果找不到，证明没有环，返回null 第二步：head节出发与slow节点出发，相遇的节点为环的入口节点 public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode fast = head.next; ListNode slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; if (fast == slow) { return true; } } return fast == slow; } 5：环形链表II-寻找环的入口节点 问题描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 官方解读Gif 6：703. 数据流中的第K大元素public class KthLargest { private PriorityQueue queue; private int limit; public KthLargest(int k, int[] nums) { limit = k; queue = new PriorityQueue(k); for (int num : nums) { add(num); } } public int add(int val) { if (queue.size() < limit) { queue.add(val); } else if (val > queue.peek()) { queue.poll(); queue.add(val); } return queue.peek(); } } 3、栈和队列20. 有效的括号func isValid(_ s: String) -> Bool { var stack: [String] = [] let dic: [String: String] = [\")\": \"(\", \"}\": \"{\", \"]\": \"[\"] for c in s { let key = String(c) if !dic.keys.contains(key) { stack.append(key) } else if stack.count == 0 || dic[key] != stack.removeLast() { return false } } return stack.count == 0 } 232. 用栈实现队列225. 用队列实现栈4、优先队列 Heap (Binary, Binomial, Fibonacci) Binary Search Tree Heap Wiki • https://en.wikipedia.org/wiki/Heap_(data_structure) 239、滑动窗口最大值5、哈希表 与双指针法1. 两数之和1.1暴力循环 1.2一次哈希思路标签：哈希映射 这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n2) 由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度 遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值 如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止 如果最终都没有结果则抛出异常 时间复杂度：O(n) 15. 三数之和 (硅谷面试)给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 解题思路： 1、可以三重loops循环时间复杂度是O(n3) 2、可以两层循环得到a+b,然后在Set集合中查找符合-(a+b)的值是否存在，时间复杂度是O(n2) 3、先排序 后查找：时间复杂度为O(n2)，先排序后得到元素a, 元素b从数组下标1开始，元素c从数组下标array.length开始，检查（a + b + c）的值： 如果（a + b + c）&gt; 0, c– 如果 （a + b + c）&lt; 0, b++ 如果（a + b + c） == 0， 得到结果 整个过程时间复杂度是O(N * N) 解题思路3 public static List threeSum(int[] nums) { List ans = new ArrayList(); int len = nums.length; if(nums == null || len < 3) return ans; Arrays.sort(nums); // 排序 for (int i = 0; i < len ; i++) { if(nums[i] > 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环 if(i > 0 && nums[i] == nums[i-1]) continue; // 去重 int L = i+1; int R = len-1; while(L < R){ int sum = nums[i] + nums[L] + nums[R]; if(sum == 0){ ans.add(Arrays.asList(nums[i],nums[L],nums[R])); while (L [Int] { guard let root = root else { return[]} var res: [Int] = [] res.append(root.val) res += preorderTraversal(root.left) res += preorderTraversal(root.right) return res } 2、中序遍历中序遍历递归法：左子树-根节点-右子树 func inorderTraversal(_ root: TreeNode?) -> [Int] { guard let root = root else { return [] } var res: [Int] = [] res += inorderTraversal(root.left) res.append(root.val) res += inorderTraversal(root.right) return res } 3、后序遍历后序遍历递归法：左子树-右子树-根节点 func postorderTraversal(_ root: TreeNode?) -> [Int] { guard let root = root else { return [] } var result: [Int] = [] if let left = root.left { result += postorderTraversal(left) } if let right = root.right { result += postorderTraversal(right) } result.append(root.val) return result } 4.1、二叉树的层次遍历 图片来自网络，侵权删 实现思路：使用队列1.将根节点入队2.循环执行以下操作，直到队列为空 将队头节点A出队，进行访问 将A的左子节点入队 将A的右子节点入队 func levelOrder(_ root: TreeNode?) -> [[Int]] { guard let root = root else { return []} var result: [[Int]] = [] var queue: [TreeNode] = [] queue.append(root) while !queue.isEmpty { //创建存储当前level的数组 var level: [Int] = [] for _ in 0..&lt;queue.count { //remove队列头结点，并且把该头结点的left和right加入到队列中，循环到队列为空 let node = queue.removeFirst() level.append(node.val) if let left = node.left { queue.append(left) } if let right = node.right { queue.append(right)} } result.append(level) } return result } 4.2、二叉树的层次遍历 II从下到上依次返回每一层的结果，解决方案依然是使用队列的先进先出，node入队列的通知，node的左子树、右子树依次入队列，然后用一个temp数组来保存每一层的数值，插入到结果results数组下标位置为0的位置。 代码如下： func levelOrderBottom(_ root: TreeNode?) -> [[Int]] { guard let root = root else { return [] } var results: [[Int]] = [] var queue: [TreeNode] = [root] while !queue.isEmpty { var levelItems: [Int] = [] for _ in 0..&lt;queue.count { let node = queue.removeFirst() levelItems.append(node.val) if let left = node.left { queue.append(left) } if let right = node.right { queue.append(right) } } results.insert(levelItems, at: 0) } return results } 自底向上返回层次遍历的值与普通的层次遍历的唯一区别在于每一层的结果levelItems是插入到数组下标为0的位置上，利用swift中数组插入方法insert(levelItems,at: 0)即可。 4.2、迭代法解决前中后序递归和非递归的区别，无非是一个人为保存现场，一个代码底层自动保存现场。 前序遍历迭代法 利用栈实现1.将root入栈2.循环执行以下操作，直到栈为空 弹出栈顶节点top，进行访问 将top.right入栈 将top.left入栈 中序遍历迭代法利用栈实现1.设置node=root2.循环执行以下操作✓如果node!=null✓将node入栈✓设置node=node.left✓如果node==null✓如果栈为空，结束遍历✓如果栈不为空，弹出栈顶元素并赋值给node ​ ➢对node进行访问​ ➢设置node=node.right 后序遍历迭代法◼利用栈实现1.将root入栈2.循环执行以下操作，直到栈为空 如果栈顶节点是叶子节点或者上一次访问的节点是栈顶节点的子节点 ✓弹出栈顶节点，进行访问 否则✓将栈顶节点的right、left按顺序入栈 5、 二叉树的最大深度首先要明白什么是最大深度：二叉树最大深度是指根节点到最远的叶子节点最长路径上的节点数目 解法一：要求二叉树的最大深度按照递归思想也就是求max(leftHeight, rightHeight) + 1 //1、递归法：max(leftHeight, rightHeight) + 1 func maxDepth(_ root: TreeNode?) -> Int { if let root = root { var leftHeight = 0, rightHeight = 0 if let left = root.left { leftHeight = maxDepth(left) } if let right = root.right { rightHeight = maxDepth(right) } return max(leftHeight, rightHeight) + 1 } return 0 } 解放二：使用队列，分层遍历DFS，记录层数即可 //2、利用队列-和分层遍历类似 //只不过分层遍历是头结点出队列时，将头队列的值保存起来，这里求最大深度是depth += 1 func maxDepth(_ root: TreeNode?) -> Int { guard let root = root else { return 0 } var depth = 0 var queue: [TreeNode] = [root] while !queue.isEmpty { depth += 1 let size = queue.count for _ in 0..&lt;size { let node = queue.removeFirst() if let left = node.left { queue.append(left) } if let right = node.right { queue.append(right) } } } return depth 6、 二叉树最大宽度解题思路：求二叉树最大宽度，可以使用分层遍历 使用队列queue来记录每一层入队的结点current 使用数组list来记录当前层所有结点的索引index 将current的左节点入队列同时将其左孩子结点的索引 2 * index放到list中记录 同理current的右孩子结点right入队列queue的同时将右结点索引2 * index + 1放到list数组中记录，这样每一层的索引都被list数组记录 最后用maxLen记录当前层最大深度= list.last! - list.first! + 1 代码实现： func widthOfBinaryTree(_ root: TreeNode?) -> Int { guard let root = root else { return 0} var queue: [TreeNode] = [root] var list: [Int] = [1] var maxLen = 1 while !queue.isEmpty { let size = queue.count for _ in 0..&lt;size { let node = queue.removeFirst() let index = list.removeFirst() if let left = node.left { queue.append(left) list.append(2 &amp;* index) } if let right = node.right { queue.append(right) list.append(2 &amp;* index &amp;+ 1) } } if list.count >= 2 { //注意临界条件是大于等于2，因为count为1宽度也是1 maxLen = max(maxLen, list.last! &amp;- list.first! &amp;+ 1) } } return maxLen } 作者：mingriweiji-github 链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/fen-ceng-bian-li-shi-yong-dui-lie-qlai-ji-lu-mei-y/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码实现： guard let root = root else { return 0 } var queue: [(TreeNode, Int)] = [] queue.append((root, 1)) var maxLen = 1 while !queue.isEmpty { let count = queue.count for _ in 0 ..&lt; count { let curr = queue.removeFirst() let index = curr.1 if let left = curr.0.left { queue.append((left, index &amp;* 2)) } if let right = curr.0.right { queue.append((right, index &amp;* 2 + 1)) } } if !queue.isEmpty { maxLen = max(maxLen, queue.last!.1 &amp;- queue.first!.1 &amp;+ 1) } } return maxLen } 7、 验证二叉搜索树1、递归法 递归法解题的关键在于：maxLeft &lt; root.val &lt; minRight 1、临界条件:root==null 2、递归左子树，找到最大值max和根节点root.val进行比较，如果左子树的max大于等于根节点的值，返回false 3、递归右子树，找到右子树的最小值min和根节点root.val比较，如果右子树的min小于等于根节点，返回false public boolean helper(TreeNode root, Integer min, Integer max) { if (root == null) return true; if (min != null && min > root.val) return false; if (max != null && max < root.val) return true; return helper(root.left,min,root.val) && helper(root.right,root.val,max); } public boolean isValidBST(TreeNode root) { return helper(root,null,null); } 上面的help()方法不能通过测试用例[1,1]这种重复元素的数组，判断条件错误，修改如下： Java版本 public boolean helper(TreeNode root, Integer min, Integer max) { if (root == null) return true; if (min != null && min >= root.val) return false; if (max != null && max Bool { guard let root = root else { return true } return helper(root,nil,nil) } func helper(_ root: TreeNode?, _ min: Int?, _ max: Int?) -> Bool { guard let root = root else { return true } //左节点需要小于根节点值 if let min = min, min &lt;= root.val { return false } //右节点需要大于根节点 if let max = max, max >= root.val { return false } return helper(root.left, root.val,max) &amp;&amp; helper(root.right, min, root.val) } 8、对称二叉树解题思路：给定一个二叉树，看它是否镜像对称关键是1、左右子树的值相等 2、左子树的left和右子树的right是镜像对称，利用递归思想容易解决。 24ms代码实现如下: func isSymmetric(_ root: TreeNode?) -> Bool { return isMirror(root,root) } func isMirror(_ p: TreeNode?, _ q: TreeNode?) -> Bool{ //注意临界条件判断，先判断p、q均为空的情况 if p == nil &amp;&amp; q == nil { return true } if p == nil || q == nil { return false } return (p!.val == q!.val) &amp;&amp; isMirror(p!.left, q!.right) &amp;&amp; isMirror(p!.right, q!.left) } 20ms代码实现如下： func isSymmetric(_ root: TreeNode?) -> Bool { guard let root = root else { return true } return isMirror(root.left, root.right) } func isMirror(_ p: TreeNode?, _ q: TreeNode?) -> Bool { if p == nil, q == nil { return true } if let p = p, let q = q, p.val == q.val { return isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left) } return false } 第二遍： 执行用时 :16 ms, 在所有 swift 提交中击败了94.96%的用户 内存消耗 :19.9 MB, 在所有 swift 提交中击败了5.00%的用户 func isSymmetric(_ root: TreeNode?) -> Bool { guard let root = root else { return true } return isMirror(root.left, root.right) } func isMirror(_ p: TreeNode?, _ q: TreeNode?) -> Bool { if p == nil &amp;&amp; q == nil { return true } if let p = p,let q = q, p.val == q.val { return isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left) } return false } 9、翻转一颗二叉树迭代就要遍历二叉树，利用分层遍历用队列交换每个结点的左右子树。 8ms迭代法： func invertTree(_ root: TreeNode?) -> TreeNode? { //迭代法翻转二叉树,交换每一个结点的左右子树，我们用队列储存没有交换过的左右子树的结点，拿到current结点后，交换左右结点，然后再将该节点的左右结点加入到队列中。直到队列为空截止。 guard let root = root else { return nil } var queue: [TreeNode] = [root] while !queue.isEmpty { var node = queue.removeFirst() let temp = node.left node.left = node.right node.right = temp if let left = node.left { queue.append(left) } if let right = node.right { queue.append(right) } } return root } 16ms递归法： func invertTree(_ root: TreeNode?) -> TreeNode? { guard let root = root else { return nil } let temp = root.left root.left = root.right root.right = temp invertTree(root.left) invertTree(root.right) return root } 8ms递归法：同上面的区别是没有解包，解包耗时8ms? func invertTree(_ root: TreeNode?) -> TreeNode? { if root == nil { return nil } let temp = root?.left root?.left = root?.right root?.right = temp invertTree(root?.left) invertTree(root?.right) return root } 第二遍：分层遍历后不要把当前节点放入队列中，我们要的是翻转二叉树，不需要记录当前节点node 7、二叉树搜索树10道常见题目 验证二叉搜索树 二叉搜索树中的插入操作 二叉搜索树中的搜索 删除二叉搜索树中的节点 二叉搜索树的最小绝对差 二叉搜索树结点最小距离 将有序数组转换为二叉搜索树 * 二叉搜索树的范围和 * 二叉搜索树的最近公共祖先 * 二叉搜索树中第K小的元素 ** 二叉搜索树迭代器 ** 恢复二叉搜索树 平衡二叉树 8、合并21. 合并两个有序链表递归法 func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1!.val &lt; l2!.val { l1?.next = mergeTwoLists(l1?.next, l2) return l1 } else { l2?.next = mergeTwoLists(l1, l2?.next) return l2 } } 迭代法 func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? { var l1 = l1 var l2 = l2 let head = ListNode(-1) var cur = head while (l1 != nil &amp;&amp; l2 != nil) { //cur.next 记录当前的head if l1!.val &lt;= l2!.val { cur.next = l1 l1 = l1?.next } else { cur.next = l2 l2 = l2?.next } //cur后移 cur = cur.next! } //处理链表为空 cur.next = l1 == nil ? l2 : l1 return head.next }","categories":[{"name":"算法","slug":"算法","permalink":"https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://mingriweiji-github.github.io/tags/swift/"}]},{"title":"数据结构思想","slug":"2020数据结构","date":"2019-06-21T17:18:15.000Z","updated":"2020-05-01T12:39:01.190Z","comments":true,"path":"2019/06/22/2020数据结构/","link":"","permalink":"https://mingriweiji-github.github.io/2019/06/22/2020%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"第一篇数据结构数组和链表 思考题： 1.如何分别用链表和数组实现LRU缓冲淘汰策略？1）什么是缓存？ 缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。 什么是C CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。 2）为什么使用缓存？即缓存的特点 缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。 3）什么是缓存淘汰策略？ 指的是当缓存被用满时清理数据的优先顺序。 4）有哪些缓存淘汰策略？ 先进先出策略FIFO（First In，First Out） 最少使用策略LFU（Least Frenquently Used） 最近最少使用策略LRU（Least Recently Used）。 5）链表实现LRU缓存淘汰策略 我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。 如果此数据没有在缓存链表中，又可以分为两种情况： 如果此时缓存未满，则将此结点直接插入到链表的头部； 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。 6）数组实现LRU缓存淘汰策略 方式一 首位置保存最新访问数据，末尾位置优先清理 当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)； 当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。 缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。 方式二 首位置优先清理，末尾位置保存最新访问数据 当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)； 当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。 缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。） 2.如何通过单链表实现“判断某个字符串是否为回文字符串”？方法一：半栈法 １．用快慢两个指针遍历，同时用栈copy慢指针指向的data。 ２．完成后，慢指针指向中间节点，耗时为N/2. ３．最后用pop栈中的data和慢指针指向的data比较，耗时也是N/2. 所以时间复杂度为：Ｏ(N)，空间复杂度因栈额外存储了一半的data，故为O(N/2) 方法二：全栈法 1）前提：字符串以单个字符的形式存储在单链表中。 2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。 3）将链表中的字符倒序存储一份在另一个链表中。 4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是回文字串，否则，不是。 方法三：硬干法 一个指针从头取data，另一个指针遍历到底取data，比较二者 ２．删除尾部节点，重复１． 时间复杂度高达 O(N^2)，空间复杂度却最低Ｏ(1) 数据结构 动画| 什么是二分搜索树？ 动画| 二叉树有几种存储方式？ 动画| 二叉树在实际生活中的应用？ 红黑树 算法思想 什么是递归？ 什么是分支？ Hash算法原理及应用 动画 | 什么是快速排序？ 动画：面试官问我插入排序和冒泡排序哪个更牛逼？ 动画: 快速排序 | 如何求第 K 大元素？ 动画| 什么是堆排序？ 动画| 什么是希尔排序 算法题目推荐 初级算法 中级算法 高级算法","categories":[{"name":"算法","slug":"算法","permalink":"https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://mingriweiji-github.github.io/tags/java/"}]},{"title":"红黑树前世今生","slug":"红黑树前世今生","date":"2019-06-08T02:13:45.000Z","updated":"2020-05-01T13:42:10.222Z","comments":true,"path":"2019/06/08/红黑树前世今生/","link":"","permalink":"https://mingriweiji-github.github.io/2019/06/08/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/","excerpt":"","text":"红黑树前世今生关键词：二叉搜索树、前驱节点、后继节点、B树、红黑树 什么是B树前世B树是一种相对于来说特殊二叉搜索树，多用于数据库和文件搜索系统中。 n阶B树的性质 B树是一种平衡的多路搜索树，拥有平衡二叉树的一些特性，与平衡二叉树的最大区别在于每个节点不再是只能存储一个元素，而且每个节点可以拥有多个子节点而像二叉平衡树只能拥有两个。 B树每个节点最多可以存储超过2个元素，可以拥有超过2个子节点 B树每个子节点的子树高度一致 B树和二叉搜索树一样，左子树&lt;根节点&lt;右子树 根节点元素个数: 1≤ X ≤ n - 1 非根节点元素个数: n/2 - 1 ≤ x ≤ n - 1 (n/2 向上取整) 如果有子节点，子节点个数 y = x + 1, 根节点 2 ≤ y ≤ n非根节点 n / 2 ≤ y ≤ n (n/2 向上取整) 数据库中一般使用的是200-300阶B树 4阶B树元素个数为(2-3-4)，所以4阶B树也叫2-4树或者2-3-4树 5阶B树元素个数为 3-4-5 所以5阶B树叫（3，5）树 6阶B树元素个数3-4-5-6，所以6阶B树叫（3，6）树 7阶B树元素个数为4-5-6-7，所以7阶B树叫（4，7）树 B树 VS 二叉搜索树 B树与二叉搜索树逻辑上等价 n阶B树最多需要log2 N代合并 多代节点合并可以获得超节点 2代合并最多拥有4个子节点 3代合并最多拥有8个子节点 n代合并最多拥有2^n个子节点（至少是2^n阶B树） B树的添加与上溢上溢出（overflow）:添加元素到子节点后，该节点元素个数大于N时，我们称之为上溢出 B树的元素添加的位置一定是叶子节点 B树添加导致上溢 B树上溢最极端的情况是一直分裂到根节点 B树的删除与下溢删除 删除叶子节点的话直接删除 删除的非叶子节点的话：1、先找到前驱或后继节点元素，覆盖需要删除的值，2、把前驱或后继元素删除（说明：一个树的前驱在左子树的最后边，后驱在右子树的最左边。） 非叶子节点前驱或后继元素，必然是在叶子节点中，所以真正删除的元素都是叶子节点 下溢出（underflow）：叶子节点被删除一个元素后，元素个数可能会低于最低限制 （n/2 - 1 向上取整） 下溢出的解决方案是旋转，总体元素是哪个方向失衡往哪个方向转，子树大小顺序不能乱 4阶B树 4阶B树所有节点都能储存的元素个数x: 1 ≤ x ≤ 3 4阶B树非叶子节点的子节点个数：2 ≤ y ≤ 4 为什么需要红黑树?红黑树是在二叉搜索树的基础上对AVL树的改进，二叉搜索树顾名思义是对搜索算法的一种优化，能够大大减少我们元素对比的次数。红黑树在Java中的应用如HashSet(底层是数组单链表和红黑树)、数据库搜索也有应用。 什么是红黑树？红黑树是一种自平衡的二叉搜索树也叫平衡二叉B树 红黑树5个性质 节点分为红色与黑色 根节点是黑色 叶子节点是黑色 不能有两个连续的红色节点 从任意节点到叶子节点上所有路径的黑色节点数目必须相等 红黑树等价变换红黑树等价于4阶B树 红黑树添加失衡如何解决？添加失衡 Parrent节点为黑色时不需要处理 Parrent节点为红色（Double Red） Uncle节点不是red: LL/RR LR/RL Uncle节点是red: 红黑树删除节点失衡如何解决？红黑树 VS AVL树搜索性能添加删除实际应用Java8中的hashMap是使用数组+链表实现的，在解决哈希碰撞时使用了红黑树。","categories":[{"name":"算法","slug":"算法","permalink":"https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://mingriweiji-github.github.io/tags/java/"}]},{"title":"二叉树今生","slug":"二叉树前世今生","date":"2019-06-06T02:13:45.000Z","updated":"2020-05-01T12:39:39.893Z","comments":true,"path":"2019/06/06/二叉树前世今生/","link":"","permalink":"https://mingriweiji-github.github.io/2019/06/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/","excerpt":"","text":"二叉树今生为什么会有二叉树这种数据结构？ 思考一个问题：如果一个集合中有42亿个元素，让你从这42亿个元素中搜索某一个元素，你需要多少次操作？ 如果使用数组链表的话最多可能需要42亿次比较，而如果使用二叉树我们只需要32次比较即可，这就是二叉树存在的价值。Java中的HashSet使用的就是二叉树 前驱与后继前驱节点 若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode） 若一个节点没有左子树，那么判断该节点和其父节点的关系 2.1 若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。 2.2 若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点 后继节点 若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode） 若一个节点没有右子树，那么判断该节点和其父节点的关系2.1 若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点2.2 若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点 如何判断两个二叉树是否相同？ 递归法 static public bool IsSameTree(TreeNode root1, TreeNode root2) { if (root1 == null && root2 == null) { return true; } if ((root1 == null && root2 != null) || (root1 != null && root2 == null)) { return false; } if (root1.val != root2.val) {//判断每个节点的值是否相等，如果去除此判断，则判断两个二叉树是否结构相等 return false; } return IsSameTree(root1.left, root2.left) && IsSameTree(root1.right, root2.right); } 非递归法 bool BTreeCompare（BTreeNode_t *pRoot1, BTreeNode_t *pRoot2) { if( pRoot1 == NULL && pRoot2 == NULL ) return false; queue que1; queue que2; que1.push(pRoot1); que2.push(pRoot2); int curLevelNodeTotal1 = 0; int curLevelNodeTotal2 = 0; bool flag = true; //作为比较不一致时跳出标识 while( ( !que1.empty()) && ( !que2.empty())) //当两个队列均不为空时，才进行比较 { curLevelNodeTotal1 = que1.size(); //获取树1的当前层节点总数 curLevelNodeTotal2 = que2.size(); //获取树2的当前层节点总数 if( curLevelNodeTotal1 != curLevelNodeTotal2){ flag = false;//当前层节点总数都不一致，不需要比较了，直接跳出 break; } int cnt1 = 0;//遍历本层节点时的计数器 int cnt2 = 0; while( cnt1 < curLevelNodeTotal1 && cnt2 < curLevelNodeTotal2){ ++cnt1; ++cnt2; pRoot1 = que1.front(); que1.pop(); pRoot2 = que2.front(); que2.pop(); //比较当前节点中数据是否一致 if( pRoot1->m_pElemt != pRoot2->m_pElemt ){ flag = false; break; } //判断pRoot1和pRoot2左右节点结构是否相同 if( ( pRoot1->m_pLeft != NULL && pRoot2->m_pLeft == NULL ) || ( pRoot1->m_pLeft == NULL && pRoot2->m_pLeft != NULL ) || ( pRoot1->m_pRight != NULL && pRoot2->m_pRight == NULL ) || ( pRoot1->m_pRight == NULL && pRoot2->m_pRight != NULL ) ){ flag = false; break; } //将左右节点入队 if( pRoot1->m_pLeft != NULL ) que1.push( pRoot1->m_pLeft); if( pRoot1->m_pRight != NULL ) que1.push( pRoot1->m_pRight); if( pRoot2->m_pLeft != NULL ) que2.push( pRoot2->m_pLeft); if( pRoot2->m_pRight != NULL ) que2.push( pRoot2->m_pRight); } if( flag == false ) break; } //如果比较标志为false，则不相同 if( flag == false ){ while( !que1.empty() ) que1.pop(); while( !que2.empty()) que2.pop(); return false; } return true; }","categories":[{"name":"算法","slug":"算法","permalink":"https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://mingriweiji-github.github.io/tags/java/"}]},{"title":"iOS汇编基础","slug":"iOS汇编基础","date":"2018-12-02T03:15:40.000Z","updated":"2020-05-01T12:34:27.038Z","comments":true,"path":"2018/12/02/iOS汇编基础/","link":"","permalink":"https://mingriweiji-github.github.io/2018/12/02/iOS%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/","excerpt":"","text":"iOS汇编基础x86_64汇编X84中原有8个32位通用寄存器%eax，%ebx，%ecx，%edx，%esi，%edi，%ebp，%esp, X86_64中分别被扩展为64位，并且多了8个寄存器。因此X86_64的寄存器如下： rax, eax, ax, ah, al; rbx, ebx, bx, bh, bl; rcx, ecx, cx, ch, cl; rdx, edx, dx, dh, dl; rsi, esi, si; rdi, edi, di; rbp, ebp; rsp, esp; r8-r15; GCC中对这些寄存器的调用规则如下： %rax 作为函数返回值使用。 %rsp 栈指针寄存器，指向栈顶 %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。 %rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改 %r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值 ARM处理器架构ARM现在的智能手机 ARM指令集 armv7｜armv7s｜arm64都是ARM处理器的指令集 v7iPhone3GS、iPhone4、iPhone4S v7siPhone5、iPhone5C arm64iPhone5S、iPhone6、iPhone6 Plus、iPhone6S、iPhone6S PlusiPhoneSE、iPhone7、iPhone7 Plus、iPhone8、iPhone8 Plus、iPhoneXiPad5、iPad Air、iPad Air2、iPad Pro、iPad Pro2iPad mini with Retina display、iPad mini3、iPad mini4iPod Touch6 i386｜x86_64 是Mac处理器的指令集 模拟器32位处理器测试需要i386架构， 模拟器64位处理器测试需要x86_64架构， 真机32位处理器需要armv7,或者armv7s架构， 真机64位处理器需要arm64架构。 编译错误真机编译错误: No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=x86_64, VALID_ARCHS=i386) 模拟器上编译错误：No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7s, VALID_ARCHS=armv7 armv6) iOS汇编教程 来自公主号：高级页面仔 1、ARM64汇编基础 2、在Xcode工程中嵌入汇编代码 3、汇编中的 Section 与数据存取 通过dylib实现iOS运行时Native代码注入 基于 Mach-O 符号重排减少缺页中断次数来提升 iOS App 启动速度的可行性分析 4、基于 LLDB 动态调试快速分析系统函数 5、Objc Block 的内存布局和汇编表示 6、CPU 指令重排与内存屏障 7、ARM Exclusive - 互斥锁与读写一致性的底层实现原理 8、Relocation - 静态库链接时是如何保证对变量的相对寻址依然正确的？ 9、在 ARC 下对非 ObjC 类型的指针进行操作的编译器陷阱","categories":[{"name":"逆向","slug":"逆向","permalink":"https://mingriweiji-github.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://mingriweiji-github.github.io/tags/iOS/"}]},{"title":"iOS图像优化技巧","slug":"iOS图像处理","date":"2018-12-01T03:15:40.000Z","updated":"2020-05-01T12:41:59.460Z","comments":true,"path":"2018/12/01/iOS图像处理/","link":"","permalink":"https://mingriweiji-github.github.io/2018/12/01/iOS%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"iOS图像优化技巧 1、如何处理大尺寸图片？ 2、如何处理瀑布流图片占用大量内存的问题？ 3、如何处理多张图片上传和下载问题？ 1、处理大尺寸图片那么，什么时候对图像进行渲染优化才有意义呢？ 当它明显大于 UIImageView 显示尺寸的时候 想要完整渲染这张宽高为 12,000 px 的图片，需要高达 20 MB 的空间。对于当今的硬件来说，你可能不会在意这么少兆字节的占用。但那只是它压缩后的尺寸。要展示它，UIImageView 首先需要把 JPEG 数据解码成位图（bitmap），如果要在一个 UIImageView 上按原样设置这张全尺寸图片，你的应用内存占用将会激增到几百兆，对用户明显没有什么好处（毕竟，屏幕能显示的像素有限）。但只要在设置 UIImageView 的 image 属性之前，将图像渲染的尺寸调整成 UIImageView 的大小，你用到的内存就会少一个数量级： 内存消耗 (MB) 无下采样 220.2 下采样 23.7 这个技巧就是众所周知的下采样（downsampling），在这些情况下，它可以有效地优化你应用的性能表现。如果你想了解更多关于下采样的知识或者其它图形图像的最佳实践，请参照 来自 WWDC 2018 的精彩课程。 而现在，很少有应用程序会尝试一次性加载这么大的图像了，但是也跟我从设计师那里拿到的图片资源不会差太多。（认真的吗？一张颜色渐变的 PNG 图片要 3 MB?） 考虑到这一点，让我们来看看有什么不同的方法，可以让你用来对图像进行优化或者下采样。 不用说，这里所有从 URL 加载的示例图像都是针对本地文件。记住，在应用的主线程同步使用网络请求图像绝不是什么好主意。 图像渲染优化技巧优化图像渲染的方法有很多种，每种都有不同的功能和性能特性。我们在本文看到的这些例子，架构层次跨度上从底层的 Core Graphics、vImage、Image I/O 到上层的 Core Image 和 UIKit 都有。 绘制到 UIGraphicsImageRenderer 上 绘制到 Core Graphics Context 上 使用 Image I/O 创建缩略图像 使用 Core Image 进行 Lanczos 重采样 使用 vImage 优化图片渲染 下面的这些数字是多次迭代加载、优化、渲染之前那张 超大地球图片 的平均时间： 耗时 (seconds) 技巧 #1: UIKit 0.1420 技巧 #2: Core Graphics 1 0.1722 技巧 #3: Image I/O 0.1616 技巧 #4: Core Image 2 2.4983 技巧 #5: vImage 2.3126 1设置不同的 CGInterpolationQuality 值出来的结果是一致的，在性能上的差异可以忽略不计。 2若在 CIContext 创建时设置 kCIContextUseSoftwareRenderer 的值为 true，会导致耗时相比基础结果慢一个数量级。 使用CGContextDrawImage()异步解码图片 dispatch_async(dispatch_get_global_queue(0, 0), ^{ // 1、获取CGImage CGImageRef cgImage = [UIImage imageNamed:@\"img\"].CGImage; // alphaInfo CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage) & kCGBitmapAlphaInfoMask; BOOL hasAlpha = NO; if (alphaInfo == kCGImageAlphaPremultipliedLast || alphaInfo == kCGImageAlphaPremultipliedFirst || alphaInfo == kCGImageAlphaLast || alphaInfo == kCGImageAlphaFirst) { hasAlpha = YES; } // bitmapInfo CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; // size size_t width = CGImageGetWidth(cgImage); size_t height = CGImageGetHeight(cgImage); // 2、获取context CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo); //3、 draw CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage); // get CGImage cgImage = CGBitmapContextCreateImage(context); // into UIImage UIImage *newImage = [UIImage imageWithCGImage:cgImage]; // release CGContextRelease(context); CGImageRelease(cgImage); // back to the main thread dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = newImage; }); }); 技巧 #1: 绘制到 UIGraphicsImageRenderer 上图像渲染优化的最上层 API 位于 UIKit 框架中。给定一个 UIImage，你可以绘制到 UIGraphicsImageRenderer 的上下文（context）中以渲染缩小版本的图像： import UIKit // 技巧 #1 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { guard let image = UIImage(contentsOfFile: url.path) else { return nil } let renderer = UIGraphicsImageRenderer(size: size) return renderer.image { (context) in image.draw(in: CGRect(origin: .zero, size: size)) } }UIGraphicsImageRenderer 是一项相对较新的技术，在 iOS 10 中被引入，用以取代旧版本的 UIGraphicsBeginImageContextWithOptions / UIGraphicsEndImageContext API。你通过指定以 point 计量的 size 创建了一个 UIGraphicsImageRenderer。image 方法带有一个闭包参数，返回的是一个经过闭包处理后的位图。最终，原始图像便会在缩小到指定的范围内绘制。 技巧 #2：绘制到 Core Graphics Context 中Core Graphics / Quartz 2D 提供了一系列底层 API 让我们可以进行更多高级的配置。 给定一个 CGImage 作为暂时的位图上下文，使用 draw(_:in:) 方法来绘制缩放后的图像： import UIKit import CoreGraphics // 技巧 #2 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil), let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil) else { return nil } let context = CGContext(data: nil, width: Int(size.width), height: Int(size.height), bitsPerComponent: image.bitsPerComponent, bytesPerRow: image.bytesPerRow, space: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!, bitmapInfo: image.bitmapInfo.rawValue) context?.interpolationQuality = .high context?.draw(image, in: CGRect(origin: .zero, size: size)) guard let scaledImage = context?.makeImage() else { return nil } return UIImage(cgImage: scaledImage) }这个 CGContext 初始化方法接收了几个参数来构造一个上下文，包括了必要的宽高参数，还有在给出的色域范围内每个颜色通道所需要的内存大小。在这个例子中，这些参数都是通过 CGImage 这个对象获取的。下一步，设置 interpolationQuality 属性为 .high 指示上下文在保证一定的精度上填充像素。draw(_:in:) 方法则是在给定的宽高和位置绘制图像，可以让图片在特定的边距下裁剪，也可以适用于一些像是人脸识别之类的图像特性。最后 makeImage() 从上下文获取信息并且渲染到一个 CGImage 值上（之后会用来构造 UIImage 对象）。 技巧 #3：使用 Image I/O 创建缩略图像处理大分辨率图片时，往往容易出现OOM，原因是-[UIImage drawInRect:]在绘制时，先解码图片，再生成原始分辨率大小的bitmap，这是很耗内存的。 解决方法是使用更低层的ImageIO接口，避免中间bitmap产生： Image I/O 是一个强大（却鲜有人知）的图像处理框架。 它可以读写许多不同图像格式，访问图像的元数据，还有执行常规的图像处理操作。这个框架通过先进的缓存机制，提供了平台上最快的图片编码器和解码器，甚至可以增量加载图片。 这个重要的 CGImageSourceCreateThumbnailAtIndex 提供了一个带有许多不同配置选项的 API，比起在 Core Graphics 中等价的处理操作要简洁得多： import ImageIO // 技巧 #3 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { let options: [CFString: Any] = [ kCGImageSourceCreateThumbnailFromImageIfAbsent: true, kCGImageSourceCreateThumbnailWithTransform: true, kCGImageSourceShouldCacheImmediately: true, kCGImageSourceThumbnailMaxPixelSize: max(size.width, size.height) ] guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil), let image = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, options as CFDictionary) else { return nil } return UIImage(cgImage: image) }给定一个 CGImageSource 和一系列配置选项，CGImageSourceCreateThumbnailAtIndex(_:_:_:) 函数创建了一个图像的缩略图。优化尺寸大小的操作是通过 kCGImageSourceThumbnailMaxPixelSize 完成的，它根据图像原始宽高比指定的最大尺寸来缩放图像。通过设定 kCGImageSourceCreateThumbnailFromImageIfAbsent 或 kCGImageSourceCreateThumbnailFromImageAlways 选项，Image I/O 可以自动缓存优化后的结果以便后续调用。 总结 UIKit, Core Graphics, 和 Image I/O 都能很好地用于大部分图片的优化操作。 如果（在 iOS 平台，至少）要选择一个的话，UIGraphicsImageRenderer 是你最佳的选择。 Core Image 在图像优化渲染操作方面性能表现优越。实际上，根据 Apple 官方 Core Image 编程规范中的性能最佳实践单元，你应该使用 Core Graphics 或 Image I/O 对图像进行裁剪和下采样，而不是用 Core Image。 除非你已经在使用 vImage，否则在大多数情况下用到底层的 Accelerate API 所需的额外工作可能是不合理的。 本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 http://swift.gg。 2、同时处理大量图片UIScrollView滚动停止监测通过调查发现 UIScrollView 停止滚动的类型分为三种： 快速滚动，自然停止 快速滚动，手指按压突然停止 慢速上下滑动停止 第1种类型，比较简单，在 UIScrollView 的代理中就可以监听到。 - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; 而第2种类型和第3种类型，就没有方法让我们可以直接监听到了。但是只要是滑动了，就一定会触发 UIScrollView 的下面代理，然后通过 UIScrollView 部分属性的改变，我们就可以监听到滚动停止了，后面会详细介绍方法。 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; 监听UIScrollView停止滚动通过翻阅文档，我们可以看到 UIScrollView 有三个属性: tracking、dragging、decelerating。 // returns YES if user has touched. may not yet have started dragging @property(nonatomic,readonly,getter=isTracking) BOOL tracking; // returns YES if user has started scrolling. this may require some time and or distance to move to initiate dragging @property(nonatomic,readonly,getter=isDragging) BOOL dragging; // returns YES if user isn't dragging (touch up) but scroll view is still moving @property(nonatomic,readonly,getter=isDecelerating) BOOL decelerating; 在滚动和滚动结束时，这三个属性的值都不相同。我们利用这三个属性，完成对 UIScrollView 停止滚动的监听。 停止类型1：scrollViewDidEndDecelerating - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; tracking:0,dragging:0,decelerating:0 停止类型2：scrollViewDidEndDragging &amp; scrollViewDidEndDecelerating - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; tracking:1,dragging:0,decelerating:1 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; tracking:0,dragging:0,decelerating:0停止类型3：scrollViewDidEndDragging - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; tracking:1,dragging:0,decelerating:0通过上面的代码，可以发现，我们只需要对 UIScrollView 的这三个属性进行相应的组合，就可以监听到 UIScrollView 停止滚动的事件了。 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView { [self stoppedScrolling]; } - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { if (!decelerate) { [self stoppedScrolling]; } } - (void)stoppedScrolling { // ... NSLog(@\"停止滚动了！！！\"); } -(void)scrollViewDidScroll:(UIScrollView *)sender { [NSObject cancelPreviousPerformRequestsWithTarget:self]; [self performSelector:@selector(scrollViewDidEndScrollingAnimation:) withObject:nil afterDelay:0.1]; } -(void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView { [NSObject cancelPreviousPerformRequestsWithTarget:self]; } 3、处理多图上传下载问题？UI刷新问题layout的相关方法: layoutSubviews layoutIfNeeded setNeedsLayout setNeedsDisplay drawRect sizeThatFits sizeToFit layoutSubviews这个方法，默认没有做任何事情，需要子类进行重写 。 系统在很多时候会去调用这个方法： 1.初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发。2.addSubview会触发layoutSubviews3.设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化4.滚动一个UIScrollView会触发layoutSubviews5.旋转Screen会触发父UIView上的layoutSubviews事件6.改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件 You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。 反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。 setNeedsLayout 标记为需要重新布局，不立即刷新，但layoutSubviews一定会被调用 配合layoutIfNeeded立即更新 layoutIfNeeded 如果有需要刷新的标记，立即调用layoutSubviews进行布局","categories":[{"name":"图像","slug":"图像","permalink":"https://mingriweiji-github.github.io/categories/%E5%9B%BE%E5%83%8F/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://mingriweiji-github.github.io/tags/iOS/"}]},{"title":"Hexo使用指南","slug":"Hexo使用指南","date":"2018-06-25T08:23:44.000Z","updated":"2020-06-29T09:40:24.104Z","comments":true,"path":"2018/06/25/Hexo使用指南/","link":"","permalink":"https://mingriweiji-github.github.io/2018/06/25/Hexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"","text":"1、Hexo安装指南1.1安装Node.js首先下载稳定版Node.js。 安装选项全部默认，一路点击Next。 最后安装好之后，windows按Win+R打开命令提示符,mac打开命令行工具，输入node -v和npm -v，如果出现版本号，那么就安装成功了。 1.2添加国内镜像源如果没有梯子的话，可以使用阿里的国内镜像进行加速。 npm config set registry https://registry.npm.taobao.org 1.3安装Git为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git[下载地址]。 安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。 安装完成后在命令提示符中输入git --version验证是否安装成功。 1.4 注册Github账号接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。 打开https://github.com/，新建一个项目，如下所示：然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。名称一定要和你的github名字完全一样，比如你github名字叫abc，那么仓库名字一定要是abc.github.io。然后项目就建成了，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。然后等一会儿，再回到GitHub Pages，会变成下面这样：点击那个链接，就会出现自己的网页啦，效果如下： 1.5 安装Hexo在合适的地方新建一个文件夹，用来存放自己的博客文件，比如存放到~/Desktop/Dev/blog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。 定位到该目录下，输入npm i hexo-cli -g安装Hexo。会有几个报错，无视它就行。 安装报错：Mac install hexo use sudo but sitll permission denied参照hexo官网 Hexo 安装hexo时,使用命令 npm install hexo-cli -g 却报没有权限: $ npm install hexo-cli -g npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules npm ERR! path /usr/local/lib/node_modules npm ERR! code EACCES npm ERR! errno -13 npm ERR! syscall access npm ERR! Error: EACCES: permission denied, access '/usr/local/lib/node_modules' npm ERR! { Error: EACCES: permission denied, access '/usr/local/lib/node_modules' npm ERR! stack: 'Error: EACCES: permission denied, access \\'/usr/local/lib/node_modules\\'', npm ERR! errno: -13, npm ERR! code: 'EACCES', npm ERR! syscall: 'access', npm ERR! path: '/usr/local/lib/node_modules' } npm ERR! npm ERR! Please try running this command again as root/Administrator. npm ERR! A complete log of this run can be found in: npm ERR! /Users/xxx/.npm/_logs/2017-10-27T01_21_01_871Z-debug.log 解决permission denied方法第一步,赋予目录权限: $ sudo chown -R `whoami` /usr/local/lib/node_modules第二步,安装hexo: $ npm install hexo-cli -g 需要注意的点: 在安装hexo时,不要用 sudo 命令. 安装完后输入hexo -v验证是否安装成功。 出现 INFO Start blogging with Hexo! 表示成功安装hexo 然后初始化我们的网站，依次输入 $ hexo init blog $ cd blog $ npm install $ hexo g # 或者hexo generate $ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以看到我们的博客啦，效果如下： 按ctrl+c关闭本地服务器。 1.6连接Github与本地首先右键打开git bash，然后输入下面命令： git config --global user.name \"godweiyang\" git config --global user.email \"792321264@qq.com\" 用户名和邮箱根据你注册github的信息自行修改。 然后生成密钥SSH key： ssh-keygen -t rsa -C \"792321264@qq.com\" 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。 git bash中输入 cat ~/.ssh/id_rsa.pub 将输出的内容复制到框中，点击确定保存。 输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了。 打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。 修改最后一行的配置： deploy: type: git repository: https://github.com/godweiyang/godweiyang.github.io branch: master repository修改为你自己的github项目地址。 1.7 windows发布首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。 然后输入hexo new post &quot;article title&quot;，新建一篇文章。 然后打开D:\\study\\program\\blog\\source\\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。 编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。 1.8 Hexo命令行发布总结 hexo clean hexo g # 或者hexo generate hexo s # 或者hexo server，用浏览器打开http://localhost:4000/ 查看 hexo d 如何用post生成一篇博客的情况的详细说明。 总结Hexo发布就是三步： 执行hexo new post myBlog，在source/_post文件夹下生成一个 myBlog.md的文件。 编辑myBlog.md，书写自己的博客内容。 执行 hexo g生成静态页面； 执行 hexo s 启动本地服务器浏览器打开http://localhost:4000/ 预览效果； 执行 hexo d 将文章部署到github实现真正的网络博客。 1.9 Hexo博客主题推荐闪烁之狐 | Hexo博客主题之hexo-theme-matery的介绍 Vue风格的Typora主题 韦阳NPL|超详细Hexo+Github博客搭建小白教程 2.0 Hexo 修改主题 cd themes git clone https://github.com/aircloud/hexo-theme-aircloud 打开_config.yml，修改themes:hexo-theme-aircloud 2.1 Hexo 技术风 主题 - NexT.Pisces CleanBlog AirCloud ![](https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/20200509aircloud.png) JSimple Lights 2.2唯美文艺风 hexo-theme-matery | 文档 | 闪烁之狐 韦阳的博客 Icarus Archer ![](http://firework.studio/archer-demo/2017-08-14/hexo-theme-archer/snap.png) wikitten-wiki风格 ![](https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/20200509103151.png) 2.3 Hexo字体 Hexo博客之改字体 2.4 Hexo代码高亮swift语法高亮注意首字母不能大写2.5 报错1、Permission denied (publickey).将SSH访问修改为https访问，修改hexo根目录下的_config.yml文件如下： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git # repo: git@github.com:YourName/YourName.io.git repo: https://github.com/YourName/YourName.github.io.git branch: master 2、hexo g报错：can not read a block mapping entryhexo的文件配置是怎么样设置属性的： 在配置文件里面，都是按照属性名+英文冒号+英文空格+属性值，这个形式进行属性设置的。 3、hexo tags 404：方法一（在SOURCE目录下默认无CATEGORIES和TAGS子目录）：新建categories和tags子目录以及相应文件 hexo new page &quot;tags&quot;编辑source/tags/index.md文件,添加如下： type: &quot;tags&quot; layout: &quot;tags&quot;方法二：1. 编辑scaffolds/draft.md如下, hexo clean &amp;&amp; hexo d即可--- title: {{ title }} tags: {{ tags }} ---2、编辑scaffolds/post.md如下--- title: {{ title }} date: {{ date }} tags: {{ tags }} ---3、编辑tags/index.md如下--- title: xxx date: 2019-04-26 17:47:43 type: &quot;tags&quot; layout: &quot;tags&quot; ---2.6 设置tag标签 title: Tagcloud date: 2017-04-26 17:47:43 type: &quot;tags&quot; layout: &quot;tags&quot;2.7 主题类博客 动态博客系统Halo 2.8 Hexo+Github图床问题使用Github图床会遇到连接WiFi时上传失败的问题，决定看下网络延时到底是多少： 方法：ping raw.githubusercontent.com 对比WiFi和4G热点时分别延时ms 使用WiFi网络延迟最大延时388ms$ ping raw.githubusercontent.com PING github.map.fastly.net (151.101.76.133): 56 data bytes 64 bytes from 151.101.76.133: icmp_seq=0 ttl=48 time=168.698 ms 64 bytes from 151.101.76.133: icmp_seq=1 ttl=48 time=212.697 ms 64 bytes from 151.101.76.133: icmp_seq=2 ttl=48 time=129.252 ms 64 bytes from 151.101.76.133: icmp_seq=3 ttl=48 time=114.672 ms 64 bytes from 151.101.76.133: icmp_seq=4 ttl=48 time=174.627 ms 64 bytes from 151.101.76.133: icmp_seq=5 ttl=48 time=125.970 ms 64 bytes from 151.101.76.133: icmp_seq=6 ttl=48 time=163.915 ms 64 bytes from 151.101.76.133: icmp_seq=7 ttl=48 time=137.259 ms 64 bytes from 151.101.76.133: icmp_seq=8 ttl=48 time=186.289 ms 64 bytes from 151.101.76.133: icmp_seq=9 ttl=48 time=388.208 ms 64 bytes from 151.101.76.133: icmp_seq=10 ttl=48 time=284.400 ms 64 bytes from 151.101.76.133: icmp_seq=11 ttl=48 time=165.050 ms 64 bytes from 151.101.76.133: icmp_seq=12 ttl=48 time=135.364 ms 64 bytes from 151.101.76.133: icmp_seq=13 ttl=48 time=115.417 ms 64 bytes from 151.101.76.133: icmp_seq=14 ttl=48 time=180.937 ms 64 bytes from 151.101.76.133: icmp_seq=15 ttl=48 time=144.686 ms 64 bytes from 151.101.76.133: icmp_seq=16 ttl=48 time=222.246 ms 64 bytes from 151.101.76.133: icmp_seq=17 ttl=48 time=143.242 ms 64 bytes from 151.101.76.133: icmp_seq=18 ttl=48 time=265.539 ms 64 bytes from 151.101.76.133: icmp_seq=19 ttl=48 time=182.337 ms 使用4G流量最大延迟662ms-1006ms$ ping raw.githubusercontent.com PING github.map.fastly.net (151.101.108.133): 56 data bytes Request timeout for icmp_seq 0 64 bytes from 151.101.108.133: icmp_seq=1 ttl=49 time=116.657 ms 64 bytes from 151.101.108.133: icmp_seq=2 ttl=49 time=161.876 ms 64 bytes from 151.101.108.133: icmp_seq=3 ttl=49 time=251.359 ms Request timeout for icmp_seq 4 64 bytes from 151.101.108.133: icmp_seq=5 ttl=49 time=341.720 ms 64 bytes from 151.101.108.133: icmp_seq=6 ttl=49 time=163.188 ms 64 bytes from 151.101.108.133: icmp_seq=7 ttl=49 time=175.687 ms 64 bytes from 151.101.108.133: icmp_seq=8 ttl=49 time=559.466 ms 64 bytes from 151.101.108.133: icmp_seq=9 ttl=49 time=111.535 ms 64 bytes from 151.101.108.133: icmp_seq=10 ttl=49 time=250.328 ms 64 bytes from 151.101.108.133: icmp_seq=11 ttl=49 time=113.041 ms 64 bytes from 151.101.108.133: icmp_seq=12 ttl=49 time=110.778 ms 64 bytes from 151.101.108.133: icmp_seq=13 ttl=49 time=377.596 ms 64 bytes from 151.101.108.133: icmp_seq=14 ttl=49 time=143.109 ms 64 bytes from 151.101.108.133: icmp_seq=15 ttl=49 time=482.161 ms Request timeout for icmp_seq 16 64 bytes from 151.101.108.133: icmp_seq=17 ttl=49 time=279.151 ms 64 bytes from 151.101.108.133: icmp_seq=18 ttl=49 time=141.005 ms Request timeout for icmp_seq 19 64 bytes from 151.101.108.133: icmp_seq=20 ttl=49 time=662.214 ms 64 bytes from 151.101.108.133: icmp_seq=21 ttl=49 time=282.395 ms 64 bytes from 151.101.108.133: icmp_seq=22 ttl=49 time=149.982 ms 64 bytes from 151.101.108.133: icmp_seq=23 ttl=49 time=419.625 ms 64 bytes from 151.101.108.133: icmp_seq=24 ttl=49 time=641.557 ms 64 bytes from 151.101.108.133: icmp_seq=25 ttl=49 time=264.912 ms 64 bytes from 151.101.108.133: icmp_seq=26 ttl=49 time=106.156 ms 为什么使用4G热点能够成功通过PigGo上传？","categories":[{"name":"使用指南","slug":"使用指南","permalink":"https://mingriweiji-github.github.io/categories/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://mingriweiji-github.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"iOS多线程","slug":"iOS多线程","date":"2018-06-01T03:13:45.000Z","updated":"2020-05-01T12:41:19.853Z","comments":true,"path":"2018/06/01/iOS多线程/","link":"","permalink":"https://mingriweiji-github.github.io/2018/06/01/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"深入理解GCDdispatch_async 会把任务添加到队列的一个链表中，添加完后会唤醒队列，根据 vtable 中的函数指针，调用 wakeup 方法。 在 wakeup 方法中，从线程池里取出工作线程(如果没有就新建)，然后在工作线程中取出链表头部指向的 block 并执行。 dispatch_sync 的实现略简单一些，它不涉及线程池(因此一般都在当前线程执行)，而是利用与线程绑定的信号量来实现串行。 分发到不同队列时，代码进入的分支也不一样，比如 dispatch_async 到主队列的任务由 runloop 处理，而分发到其他队列的任务由线程池处理。 在当前串行队列中执行 dispatch_sync 时，由于 dq_running 属性(表示在运行的任务数量) 为 1，所以以下判断成立: if (slowpath(!dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1))) { return _dispatch_barrier_sync_f_slow(dq, ctxt, func); } 在 _dispatch_barrier_sync_f_slow 函数中使用了线程对应的信号量并且调用 wait 方法，从而导致线程死锁。 如果向其它队列同步提交 block，最终进入 _dispatch_barrier_sync_f_invoke，它只是保证了 block 执行的原子性，但没有使用线程对应的信号量。 对于信号量来说，它主要使用 signal 和 wait 这两个接口，底层分别调用了内核提供的方法。 在调用 wait 方法后，先将 value 减一，如果大于零立刻返回，否则陷入等待。signal 方法将信号量加一，如果 value 大于零立刻返回，否则说明唤醒了某一个等待线程，此时由系统决定哪个线程的等待方法可以返回。 dispatch_group 的本质就是一个 value 非常大的信号量，等待 group 完成实际上就是等待 value 恢复初始值。而 notify 的作用是将所有注册的回调组装成一个链表，在 dispatch_async 完成时判断 value 是不是恢复初始值，如果是则调用 dispatch_async 异步执行所有注册的回调。 dispatch_once 通过一个静态变量来标记 block 是否已被执行，同时使用信号量确保只有一个线程能执行，执行完 block 后会唤醒其他所有等待的线程。 dispatch_barrier_async 改变了 block 的 vtable 标记位，当它将要被取出执行时，会等待前面的 block 都执行完，然后在下一次循环中被执行。 dispatch_source 可以用来实现定时器。 所有的 source 会被提交到用户指定的队列，然后提交到 manager 队列中，按照触发时间排好序。 随后找到最近触发的定时器，调用内核的 select 方法等待。 等待结束后，依次唤醒 manager 队列和用户指定队列，最终触发一开始设置的回调 block。 GCD 中的对象用 do_suspend_cnt 来表示是否暂停。队列默认处于启动状态，而 dispatch_source 需要手动启动。 dispatch_after 函数依赖于 dispatch_source 定时器，它只是注册了一个定时器，然后在回调函数中执行 block。 GCD死锁案例分析 NSOperation案例分析 深入理解iOS开发中的锁 自旋锁的目的是为了确保临界区只有一个线程可以访问bool lock = false; // 一开始没有锁上，任何线程都可以申请锁 do { while(test_and_set(&lock); // test_and_set 是一个原子操作 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码 } 显然在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。 如果临界区的执行时间过长，使用自旋锁不是个好主意 信号量 首先会把信号量的值减一，并判断是否大于零。 如果大于零，说明不用等待，所以立刻返回。小于0等待signal唤醒线程 pthread_mutex互斥锁 互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。 pthread_mutexattr_t attr; pthread_mutexattr_init(&attr); pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL); // 定义锁的属性 pthread_mutex_t mutex; pthread_mutex_init(&mutex, &attr) // 创建锁 pthread_mutex_lock(&mutex); // 申请锁 // 临界区 pthread_mutex_unlock(&mutex); // 释放锁 一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。 假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。 然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。 NSLock NSLock 只是在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。 NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。 NSCondition NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。 条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程**，并等待某个数据就绪，随后唤醒线程**，比如常见的生产者-消费者模式。 NSCondition 其实是封装了一个互斥锁和条件变量， 它把前者的 lock 方法和后者的 wait/signal 统一在 NSCondition 对象中，暴露给使用者 它的加解锁过程与 NSLock 几乎一致，理论上来说耗时也应该一样(实际测试也是如此)。在图中显示它耗时略长，我猜测有可能是测试者在每次加解锁的前后还附带了变量的初始化和销毁操作。 NSRecursiveLock 递归锁也是通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器加一，锁的释放过程也是同理。 使用递归锁NSRecursiveLock NSLock *lock = [[NSLock alloc] init]; dispatch_async(dispatch_get_global_queue(0, 0), ^{ static void (^RecursiveMethod)(int); RecursiveMethod = ^(int value) { [lock lock];//递归调用时失败，NSLock不能被同一线程多次获取，多次获取使用NSRecursiveLock if (value > 0) { NSLog(@\"value = %d\", value); sleep(2); RecursiveMethod(value - 1); } [lock unlock]; }; RecursiveMethod(5); }); @synchronized这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。 你调用 sychronized 的每个对象，runtime 都会为其分配一个递归锁并存储在哈希表中。 如果在 sychronized 内部对象被释放或被设为 nil 看起来都 OK。不过这没在文档中说明，所以我不会再生产代码中依赖这条。 注意不要向你的 sychronized block 传入 nil！这将会从代码中移走线程安全。你可以通过在 objc_sync_nil 上加断点来查看是否发生了这样的事情。 1、你理解的多线程？并发和串行，同步和异步 同步和异步的区别: 是否开辟新的线程，同步只能在当前线程执行任务，异步可以再新的线程执行任务 串行和并发的区别:是任务执行的顺序，串行任务只能顺序执行，并发可以多个任务同时执行。 2、iOS多线程有哪些？常用哪个？ NSThread、GCD/NSOperationQueue 常用GCD/NSOperation 3、GCD 的队列类型有哪些？GCD的队列可以分为2大类型 并发队列（Concurrent Dispatch Queue） 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务） 并发功能只有在异步（dispatch_async）函数下才有效 串行队列（Serial Dispatch Queue） 让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务） 4、OperationQueue 和 GCD 的区别？ GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择； 在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)； NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行； 我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样子能比GCD更加有效地掌控我们执行的后台任务； 在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码； 我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。 总的来说，Operation queue 提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。 从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。 5、线程安全是什么？如何处理线程安全的问题？ 我们一般通过线程同步方案如加锁的方式来实现线程的安全 iOS锁的原理 | 深入浅出iOS系统内核-同步机制 os_unfair_lock：iOS10开始os_unfair_lock来替代OSSpinLock, 等待锁的线程会进入休眠不占用CPU资源， 这个os_unfair_lock解决了优先级翻转问题。 OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等一直占用着CPU资源 dispatch_semaphore：信号量为1的semaphore也可以看做是锁 pthread_mutex：跨平台的互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。 使用GCD的串行队列也可以实现锁的功能 NSLock是对metex互斥锁的封装，NSRecurisiveLock也是对metex的递归封装，API和NSLock一直。 NSCondition NSConditionLock @synchorized也是mutex的递归封装，@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作。 6、自旋锁和互斥锁如何选择？自旋锁OSSpinLock：当线程获取锁，其他等待锁的线程会忙等一直占用CPU,自旋锁有优先级翻转的可能性，所以苹果已经弃用自旋锁OSSpinLock改用os_unfair_lock. 互斥锁mutext：阻塞线程并休眠，其他线程才能正常访问，用互斥的方式来保证线程的安全。 递归锁：顾名思义，可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。 什么情况使用自旋锁比较划算？ 预计线程等待锁的时间很短 竞争情况很少发生，加锁的代码（临界区）经常被调用 CPU资源不紧张 多核处理器 什么情况使用互斥锁比较划算？ 预计线程等待锁的时间较长 临界区代码复杂或者循环量大 临界区竞争非常激烈 单核处理器 临界区有IO操作 追问二：使用以上锁需要注意哪些？ 追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！ 7、iOS线程同步方案性能比较性能从高到低排序: os_unfair_lock &gt; OSSpinLock &gt; dispatch_semaphore &gt; pthread_mutex &gt; dispatch_queue(DISPATCH_QUEUE_SERIAL) &gt; NSLock &gt; NSCondition &gt; pthread_mutex(recursive) &gt; NSRecursiveLock &gt; NSConditionLock &gt; @synchronized**8、如何用gcd实现并发执行1和2再执行任务3的方案？ 异步并发执行任务1、任务2 等任务1、任务2都执行完毕后，再回到主线程执行任务3 dispatch_group_notifydispatch_barrier_asyncdispatch_sempher(2) let group = DispatchGroup() let queue = DispatchQueue.init(label: \"handleAPIQueue\") group.enter() queue.async { print(\"任务1完成\") group.leave() } group.enter() queue.async { DispatchQueue.main.asyncAfter(deadline: .now() + 3) { print(\"任务2完成\") group.leave() //注意leave的位置必须在任务完成后 } } //group.leave() //如果leave放在这里的话，notify不会等待任务2完成就会触发 group.enter() queue.async { print(\"任务3完成\") group.leave() } group.notify(queue: queue) { print(\"所有任务都完成了\") } 网络请求应用实例 9、如何实现多度单写？dispatch_barrier_async 这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的 如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果 dispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.queue.concurrent\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(concurrentQueue, ^{ NSLog(@\"async_1\"); }); dispatch_async(concurrentQueue, ^{ NSLog(@\"async_2\"); }); dispatch_async(concurrentQueue, ^{ NSLog(@\"async_3\"); }); dispatch_barrier_async(concurrentQueue, ^{//dispatch_barrier_sync效果相同 NSLog(@\"dispatch_barrier_async\"); }); dispatch_async(concurrentQueue, ^{ NSLog(@\"async_4\"); }); /* 01-OC底层[25009:1007376] async_1 01-OC底层[25009:1007372] async_3 01-OC底层[25009:1007374] async_2 01-OC底层[25009:1007372] dispatch_barrier_async 01-OC底层[25009:1007372] async_4 */ 10、GCD实现暂停和继续注意什么？ dispatch_queue_t conQueue = dispatch_queue_create(\"com.seria.queue\", DISPATCH_QUEUE_CONCURRENT); size_t count = 5; dispatch_apply(5, conQueue, ^(size_t index) { NSLog(@\"numer is %zu\",index); if (index == 2) { // dispatch_suspend(concurrentQueue);// suspend并不能停止当前队列的任务，只能停止后面队列中的任务 } }); dispatch_suspend(conQueue); // dispatch_suspend 不能单独使用，和dispatch_resume配对使用 NSLog(@\"task1---\"); dispatch_async(conQueue, ^{ NSLog(@\"async1\"); }); NSLog(@\"task2---\"); dispatch_resume(conQueue); dispatch_async(conQueue, ^{ NSLog(@\"async2\"); }); NSLog(@\"task3---\"); 11、案例分析使用 Dispatch Source定时器Dispatch Source Timer利用 Dispatch Source 的 DISPATCH_SOURCE_TYPE_TIMER 类型，我们可以创建一个 跨线程的 定时器（我们平时使用的 NSTimer 是基于 Run Loop 的 timer 事件，只能在对应的线程里触发） dispatch_queue_t queue = dispatch_get_main_queue(); //1、创建一个 timer； self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); //2、配置 timer，从现在起，每两秒在主线程触发一次，精度为0s dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC, 0 * NSEC_PER_SEC); //3、timer 触发之后的回调 block dispatch_source_set_event_handler(self.timer, ^{ NSLog(@\"%ld\", self.count++); }); //4、启动 timer dispatch_resume(self.time);","categories":[{"name":"源码","slug":"源码","permalink":"https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://mingriweiji-github.github.io/tags/iOS/"}]},{"title":"Runloop","slug":"Runloop","date":"2018-06-01T02:13:45.000Z","updated":"2020-05-01T12:42:19.350Z","comments":true,"path":"2018/06/01/Runloop/","link":"","permalink":"https://mingriweiji-github.github.io/2018/06/01/Runloop/","excerpt":"","text":"Runloop1.讲讲 RunLoop，项目中有用到吗？ 事件循环，在程序运行中循环做一些事情 没有消息mach_msg()切换用户态到内核态线程休眠，有消息内核态切换到用户态 runloop相关： Timer、performSelector GCD、AutoreleasePool 事件响应、收拾识别、网络请求 runloop的应用： 线程包活 解决timer滑动停止问题 监听主线程卡顿 性能优化 2.runloop的6种状态和runloop内部实现逻辑？/* Run Loop Observer Activities */ typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出Loop kCFRunLoopAllActivities = 0x0FFFFFFFU }; source0 : 触摸事件、performSelectorOnThread: source1: 基于Port的线程间通讯，捕获到的系统事件 timers: NSTimer + performSelector:afterDelay: observers: 监听runloop的状态/autoreleasePool的创建和释放、UI的刷新 3.runloop和线程的关系？ 一一对应 保存在一个全局字典中，线程是key, runloop是value 子线程默认没有runloop，在第一次获取runloop时才会创建。 runloop在线程结束时销毁 4.timer 与 runloop 的关系？程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？5.runloop 是怎么响应用户操作的， 具体流程是什么样的？6.说说runLoop的几种状态7.runloop的mode作用是什么？ CFRunLoopModeRef代表RunLoop的运行模式 一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer RunLoop启动时只能选择其中一个Mode，作为currentMode 如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入 不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响 如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出 8.KVO实现原理?哪些情况下使用kvo会崩溃，怎么防护崩溃?9.如何手动关闭KVO?如何手动自己实现KVO说说思路10.通过KVC修改属性会触发KVO么","categories":[{"name":"源码","slug":"源码","permalink":"https://mingriweiji-github.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://mingriweiji-github.github.io/tags/iOS/"}]},{"title":"排序问题","slug":"排序问题","date":"2018-01-01T03:11:45.000Z","updated":"2020-05-01T12:40:15.172Z","comments":true,"path":"2018/01/01/排序问题/","link":"","permalink":"https://mingriweiji-github.github.io/2018/01/01/%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"带着问题去学习，是最有效的学习方法。所以按照惯例，我还是先给你出一个思考题： 问题一：为什么插入排序比冒泡排序更受欢迎？如何分析一个“排序算法”？ 最好情况、最坏情况、平均情况时间复杂度 时间复杂度的系数、常数、低阶 比较次数和交换次数 内存消耗 原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。(冒泡排序、插入排序) 稳定性 经过某种排序算法排序之后，如果两个相同数值的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法； 如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。 1、冒泡排序 冒泡排序只会操作相邻元素的两个数据 每次都是对相邻的两个元素比较大小，前面的元素大于后面的元素，交换前后元素，一轮循环后最后元素就是最大元素 第二轮循环后，倒数第二个元素就是第二大元素 直到所有元素都是有序的停止排序 冒泡排序图示： /// 冒泡排序 func bubbleSort&lt;T>(_ array: [T]) -> [T] where T: Comparable{ var array = array guard array.count > 1 else { return array } for i in 0..&lt;array.count { //提前退出标志 var flag: Bool = false for j in 0..&lt;array.count - i - 1 { if array[j] > array[j + 1] { array.swapAt(j + 1, j) //有数据交换 flag = true } } //没有数据交换-提前退出 if flag == false { break } } return array } 现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。 第一，冒泡排序是原地排序算法吗？冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。 第二，冒泡排序是稳定的排序算法吗？在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。 第三，冒泡排序的时间复杂度是多少？最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。平均时间复杂度也是O(n2) 2、插入排序 插入排序是将数组分成两个部分，已排序和未排序 初始化已排序部分只有一个元素就是数组第一个元素 插入排序的核心思想就是取出未排序部分的元素，在已排序区间中找到合适的插入位置插入，保证已排序区间的数据一直是有序的。 插入排序如下图： ///插入排序 func insertSort&lt;T>(_ elements: [T]) -> [T] where T: Comparable { var array = elements guard array.count > 1 else { return array } for i in 1..&lt;array.count { let value = array[i] var j = i - 1 //查找要插入的位置 for p in (0...j).reversed() { if array[p] > value { array[p+1] = array[p]//移动数据 } else { break } } array[j+1] = value// 插入数据 } return array } 插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。 对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度 = 满有序度-初始有序度。 现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。 第一，插入排序是原地排序算法吗？插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。 第二，插入排序是稳定的排序算法吗？在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。 第三，插入排序的时间复杂度是多少？ 如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。 如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。 还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n2)。 3、选择排序（Selection Sort）选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。 第一，选择排序是原地排序算法吗？选择排序的时间复杂度是O(1)所以是原地排序 第二，选择排序是稳定的排序算法吗？不是稳定排序，对于选择排序来说每次都是从未排序序列中找到最小的插入到已排序序列的末尾处，和前面的元素交换，这样会破坏稳定性 比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。\\ 第三，选择排序的时间复杂度是多少？选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。 总结三种时间复杂度是 O(n2) 的排序算法 这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高，所以我们更倾向于用下一节要讲的时间复杂度为 O(nlogn) 的排序算法。 问题二：如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素?1、归并排序 归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。 归并排序的核心是合并：依次合并N个堆得数据 1、在合并时，您需要两个索引来跟踪两个数组的进度。 2、这是合并后的数组。 它现在是空的，但是你将在下面的步骤中通过添加其他数组中的元素构建它。 3、这个while循环将比较左侧和右侧的元素，并将它们添加到orderedPile，同时确保结果保持有序。 4、如果前一个while循环完成，则意味着leftPile或rightPile中的一个的内容已经完全合并到orderedPile中。此时，您不再需要进行比较。只需依次添加剩下一个数组的其余内容到orderedPile。 归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。 从我刚才的描述，你有没有感觉到，分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。 所以归并排序的核心就是递归写法： 递推公式： merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r)) 终止条件： p &gt;= r 不用再继续分解 有了递推公式，转化成代码就简单多了: func merge(_ leftArray: [Int], _ rightArray: [Int]) -> [Int] { //1 var l = 0, r = 0 //2 var mergeArr: [Int] = [] //3 while l &lt; leftArray.count &amp;&amp; r &lt; rightArray.count { if leftArray[l] > rightArray[r] { mergeArr.append(rightArray[r]) r += 1 } else if leftArray[l] &lt; rightArray[r] { mergeArr.append(leftArray[l]) l += 1 } else { mergeArr.append(leftArray[l]) l += 1 mergeArr.append(rightArray[r]) r += 1 } } //4 while l &lt; leftArray.count { mergeArr.append(leftArray[l]) l += 1 } while r &lt; rightArray.count { mergeArr.append(rightArray[r]) r += 1 } return mergeArr } /* 1、如果数组为空或包含单个元素，则无法将其拆分为更小的部分，返回数组就行。 2、找到中间索引。 3、使用上一步中的中间索引，递归地分割数组的左侧。 4、递归地分割数组的右侧。 5、最后，将所有值合并在一起，确保它始终排序。 */ func mergeSort(_ array: Array&lt;Int>) -> Array&lt;Int> { //1 guard array.count > 1 else { return array } //2 let middle = array.count / 2 //3 let leftPart = mergeSort(Array(array[0..&lt;middle])) //4 let rightPart = mergeSort(Array(array[middle..&lt;array.count])) //5 return merge(leftPart, rightPart) } 2、快速排序快速排序是原地排序，也是递归实现，但快速排序不是稳定排序 归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。 快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。 快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。 我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。 直接递归： 1、设置中间位置元素为轴点元素pivot 2、分区：less equal more 3、递归合并分区 func quickSort&lt;T: Comparable>(_ array: [T]) -> [T]{ let pivot = array[array.count / 2] let less = array.filter { $0 &lt; pivot } let equal = array.filter { $0 == pivot } let more = array.filter { $0 > pivot } return quickSort(less) + equal + quickSort(more) } /* 1、从序列中选择中轴点pivot（假设选择位置为0的元素） 2、利用pivot中轴点把序列分成两个子序列 3、分别对左右子序列递归进行快速排序，直到元素不能分割位置 快速排序的本质是把每一个元素都转换成中轴点。 */ public func quickSortDutch&lt;T: Comparable>(_ a: inout [T], low: Int, high: Int) { if low &lt; high { let pivot = Int.random(in: low...high) let (p, q) = partationDutch(&amp;a, low: low, high: high, pivotIndex: pivot) quickSortDutch(&amp;a, low: low, high: p - 1) quickSortDutch(&amp;a, low: q + 1, high: high) } } Lomuto分区 Vs Hoare分区 Vs 荷兰国旗分区 Lomuto分区法:是用数组最后一个元素作为基准元素对数组分区，区域为[low…p-1] [p+1…high]，然后递归调用quickLomutoSort分别对左右区排序，一直到数组有序 Hoare分区：选择数组的first元素作为基准，数组划分区域为[low…p] [p+1…high]，然后递归调用quickSortHoare分别对左右区排序，一直到数组有序 /* 3 荷兰国旗分区：将前部和后部各排在数组的前边和后边，中部自然就排好了,分区函数返回(p, q) 设置两个标志位begin和end分别指向这个数组的开始和末尾，然后用一个标志位current从头开始进行遍历： 1）若遍历到的current &lt; pivot，于是就和begin位置进行交换，然后current向前进，begin也向前进（表示前边的已经都排好了）。 2）若遍历到current == pivot，则说明它一定属于中部，根据总思路，中部的我们都不动，然后current向前进。 3）若遍历到current > pivot，则说明它一定属于后部，于是就和end位置进行交换， 由于交换完毕后current指向的可能是属于前部的，若此时current前进则会导致该位置不能被交换到前部，所以此时current不前进。 end向后退1。 4) 返回分区（begin, end） */ func partationDutch&lt;T: Comparable>(_ a: inout [T], low: Int, high: Int, pivotIndex: Int) -> (Int, Int) { var begin = low, end = high var current = low, pivot = a[pivotIndex] while current &lt;= end { if a[current] &lt; pivot { a.swapAt(begin, current) begin += 1 current += 1 } else if a[current] == pivot { current += 1 } else { a.swapAt(current, end) end -= 1 } } return (begin, end) } 解答问题二： 快排核心思想就是分治和分区，我们可以利用分区的思想，来解答开这个问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。 我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。 如果 p+1=K，那 A[p]就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1]区间查找。 本文参考：王争-数据结构与算法之美","categories":[{"name":"算法","slug":"算法","permalink":"https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://mingriweiji-github.github.io/tags/java/"}]},{"title":"反转问题","slug":"反转问题","date":"2018-01-01T02:13:45.000Z","updated":"2020-05-01T12:39:48.376Z","comments":true,"path":"2018/01/01/反转问题/","link":"","permalink":"https://mingriweiji-github.github.io/2018/01/01/%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98/","excerpt":"","text":"字符串反转方法一：递归 原地反转字符串是否代表了空间复杂度为常数？不，原地反转字符串是一种不使用辅助数据结构的算法。 我们使用递归的方法去反转字符串，它是原地反转，但是空间复杂度却不是常数级空间，因为递归过程中使用了堆栈空间。 算法过程 我们实现递归函数 helper，它接受两个参数：left 左指针和 right 右指针。 如果 left&gt;=right，不做任何操作。 否则交换 s[left] 和 s[right] 和调用 helper(left + 1, right - 1)。 首次调用函数我们传递首尾指针反转整个字符串 return helper(0, len(s) - 1)。 public void helper(char[] s, int left, int right) { if (left >= right) return; char tmp = s[left]; s[left++] = s[right]; s[right--] = tmp; helper(s, left, right); } public void reverseString(char[] s) { helper(s, 0, s.length - 1); } 复杂度分析时间复杂度：\\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。 空间复杂度：\\mathcal{O}(N)O(N)，递归过程中使用的堆栈空间。 方法二：双指针法双指针法是使用两个指针，一个左指针 left，右指针 right，开始工作时 left 指向首元素，right 指向尾元素。交换两个指针指向的元素，并向中间移动，直到两个指针相遇。 算法过程 将 left 指向首元素，right 指向尾元素。 当 left&lt;right： 交换 s[left] 和 s[right]。 left++ right++ // 双指针 func reverseStr(_ s: inout [Character]) -> [Character]{ var left = 0, right = s.count - 1 while left &lt; right { (s[left],s[right]) = (s[right],s[left]) left += 1 right -= 1 } return s } 测试用例let str = \"123456abcdef\" var characters = Array(str) print(characters)//[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] print(reverseStr(&amp;characters))//[\"f\", \"e\", \"d\", \"c\", \"b\", \"a\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"] 复杂度分析时间复杂度：\\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。空间复杂度：\\mathcal{O}(1)O(1)，只使用了常数级空间。 反转链表双指针法 定义两个指针pre cur : pre在前 cur 在后 如果cur节点不为空，设置pre.next = cur 实现一次翻转 翻转后pre 、cur同步向前一步 当pre为空终止循环 func reverseList(_ head: ListNode?) -> ListNode? { if head == nil || head?.next == nil { return head } var pre = head, cur: ListNode? while pre != nil { let temp = pre?.next pre?.next = cur cur = pre! pre = temp } return cur } 递归法核心：reversList(head) = reverseList(head.next) func reverseList2(_ head: ListNode?) -> ListNode? { if head == nil || head?.next == nil { return nil } let newHead = reverseList2(head?.next) head?.next?.next = head head?.next = nil return newHead } 反转链表 II题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明:1 ≤ m ≤ n ≤ 链表长度 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL题解思路 第一步：找到待反转节点的前一个节点。第二步：反转m到n这部分。第三步：将反转的起点的next指向反转的后面一部分。第四步：将第一步找到的节点指向反转以后的头节点。 public ListNode reverseBetween(ListNode head, int m, int n) { ListNode res = new ListNode(0); res.next = head; ListNode node = res; //找到需要反转的那一段的上一个节点。 for (int i = 1; i &lt; m; i++) { node = node.next; } //node.next就是需要反转的这段的起点。 ListNode nextHead = node.next; ListNode next = null; ListNode pre = null; //反转m到n这一段 for (int i = m; i &lt;= n; i++) { next = nextHead.next; nextHead.next = pre; pre = nextHead; nextHead = next; } //将反转的起点的next指向next。 node.next.next = next; //需要反转的那一段的上一个节点的next节点指向反转后链表的头结点 node.next = pre; return res.next; }","categories":[{"name":"算法","slug":"算法","permalink":"https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://mingriweiji-github.github.io/tags/java/"}]},{"title":"老鼠毒药问题","slug":"老鼠毒药问题","date":"2018-01-01T02:13:45.000Z","updated":"2020-05-01T12:40:06.037Z","comments":true,"path":"2018/01/01/老鼠毒药问题/","link":"","permalink":"https://mingriweiji-github.github.io/2018/01/01/%E8%80%81%E9%BC%A0%E6%AF%92%E8%8D%AF%E9%97%AE%E9%A2%98/","excerpt":"","text":"老鼠毒药问题1、有两个水桶， 一个装 3L 的水， 一个可装 5L 的水， 问:如何利用这两个桶， 量出 4L 的水来？解法一加法：操作两次3L的桶，得到1L的水，然后倒入5L的桶里面，此时5L桶里有1L的水，再次用3L的桶倒入5L桶，1L+ 3L = 4L,一共操作3次3L桶 加法解法图示： 解法二减法：5L满水的桶倒入3L的桶，剩余2L，5L桶剩余的2L再次倒入3L桶，此时3L桶还有1L集满，5L桶再次装满后倒出来1L给3L桶里面，5L - 1L = 4L,连续操作3次5L桶 减法解法图示： 2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？首先2的6次方64，2的7次方128 &gt; 100因此我们可以用7个的二进制给100个瓶子编号，7只老鼠分别对应7个二进制位，如果瓶子编号出现1，老鼠喝下瓶子中的毒药，最后统计出被毒死老鼠的二进制数，转换为10进制就是有毒瓶子的编号。 解法图示：","categories":[{"name":"算法","slug":"算法","permalink":"https://mingriweiji-github.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://mingriweiji-github.github.io/tags/java/"}]}]}