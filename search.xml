<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dyld源码阅读</title>
      <link href="/2020/04/01/Dyld%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2020/04/01/Dyld%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Dyld源码阅读"><a href="#Dyld源码阅读" class="headerlink" title="Dyld源码阅读"></a>Dyld源码阅读</h1><ul><li>Version：<a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener"><strong>dyld-551.4</strong></a></li><li>Lauange：<strong>C++</strong></li><li>load()：3566行<ul><li><code>load()-&gt;loadPhase0()-&gt;loadPhase1()-&gt;loadPhase2()-&gt;loadPhase4()-&gt;loadPhase5()打开或检查已经存在的动态库：dyld3::findInSharedCacheImage</code></li><li><code>load()-&gt;loadPhase2cache()-&gt;loadPhase4()-&gt;loadPhase5()-&gt;loadPhase6()</code></li></ul></li></ul><h2 id="1、动态库路径"><a href="#1、动态库路径" class="headerlink" title="1、动态库路径"></a>1、动态库路径</h2><p><strong>iOS越狱手机</strong></p><ul><li><strong>在Mac\iOS中，是使用了<code>/usr/lib/dyld</code>程序来加载动态库</strong></li><li>UIKit路径：<code>/system/Library/Frameworks/UIKit.framework</code></li><li><strong>动态库共享缓存</strong>：<code>/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64</code></li></ul><h2 id="0x00-load"><a href="#0x00-load" class="headerlink" title="0x00 load()"></a>0x00 load()</h2><pre class=" language-c"><code class="language-c">ImageLoader<span class="token operator">*</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">const</span> LoadContext<span class="token operator">&amp;</span> context<span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token operator">&amp;</span> cacheIndex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// try all path permutations and check against existing loaded images</span>    ImageLoader<span class="token operator">*</span> image <span class="token operator">=</span> <span class="token function">loadPhase0</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> orgPath<span class="token punctuation">,</span> context<span class="token punctuation">,</span> cacheIndex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> image <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">CRSetCrashLogMessage2</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> image<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// try all path permutations and try open() until first success</span>    image <span class="token operator">=</span> <span class="token function">loadPhase0</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> orgPath<span class="token punctuation">,</span> context<span class="token punctuation">,</span> cacheIndex<span class="token punctuation">,</span> <span class="token operator">&amp;</span>exceptions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> image <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        image <span class="token operator">=</span> <span class="token function">loadPhase2cache</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> orgPath<span class="token punctuation">,</span> context<span class="token punctuation">,</span> cacheIndex<span class="token punctuation">,</span> <span class="token operator">&amp;</span>exceptions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token function">CRSetCrashLogMessage2</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="0x01-loadPhase2"><a href="#0x01-loadPhase2" class="headerlink" title="0x01 loadPhase2()"></a>0x01 loadPhase2()</h2><h2 id="0x02-loadPhase5"><a href="#0x02-loadPhase5" class="headerlink" title="0x02 loadPhase5"></a>0x02 loadPhase5</h2><h4 id="loadPhase5load（）"><a href="#loadPhase5load（）" class="headerlink" title="loadPhase5load（）"></a>loadPhase5load（）</h4><h4 id="loadPhase5check（）"><a href="#loadPhase5check（）" class="headerlink" title="loadPhase5check（）"></a>loadPhase5check（）</h4><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// open or check existing</span><span class="token keyword">static</span> ImageLoader<span class="token operator">*</span> <span class="token function">loadPhase5</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> orgPath<span class="token punctuation">,</span> <span class="token keyword">const</span> LoadContext<span class="token operator">&amp;</span> context<span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token operator">&amp;</span> cacheIndex<span class="token punctuation">,</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token operator">*</span> exceptions<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// check for specific dylib overrides</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>DylibOverride<span class="token operator">></span><span class="token punctuation">:</span><span class="token punctuation">:</span>iterator it <span class="token operator">=</span> sDylibOverrides<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> sDylibOverrides<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>it<span class="token operator">-></span>installName<span class="token punctuation">,</span> path<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            path <span class="token operator">=</span> it<span class="token operator">-></span>override<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> exceptions <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token function">loadPhase5load</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> orgPath<span class="token punctuation">,</span> context<span class="token punctuation">,</span> cacheIndex<span class="token punctuation">,</span> exceptions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">loadPhase5check</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> orgPath<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="0x03-findInSharedCacheImage"><a href="#0x03-findInSharedCacheImage" class="headerlink" title="0x03 findInSharedCacheImage"></a>0x03 findInSharedCacheImage</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> bool <span class="token function">findInSharedCacheImage</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> bool searchByPath<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> stat<span class="token operator">*</span> stat_buf<span class="token punctuation">,</span> <span class="token keyword">const</span> macho_header<span class="token operator">*</span><span class="token operator">*</span> mh<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> pathInCache<span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token operator">*</span> slide<span class="token punctuation">)</span><span class="token punctuation">{</span>    dyld3<span class="token punctuation">:</span><span class="token punctuation">:</span>SharedCacheFindDylibResults results<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> dyld3<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">findInSharedCacheImage</span><span class="token punctuation">(</span>sSharedCacheLoadInfo<span class="token punctuation">,</span> path<span class="token punctuation">,</span> <span class="token operator">&amp;</span>results<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>mh             <span class="token operator">=</span> <span class="token punctuation">(</span>macho_header<span class="token operator">*</span><span class="token punctuation">)</span>results<span class="token punctuation">.</span>mhInCache<span class="token punctuation">;</span>        <span class="token operator">*</span>pathInCache <span class="token operator">=</span> results<span class="token punctuation">.</span>pathInCache<span class="token punctuation">;</span>        <span class="token operator">*</span>slide         <span class="token operator">=</span> results<span class="token punctuation">.</span>slideInCache<span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span>bool <span class="token function">inSharedCache</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> dyld3<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">pathIsInSharedCacheImage</span><span class="token punctuation">(</span>sSharedCacheLoadInfo<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">imageSorter</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> l<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> ImageLoader<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ImageLoader<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> ImageLoader<span class="token operator">*</span> right<span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ImageLoader<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> left<span class="token operator">-></span><span class="token function">compare</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>findInSharedCacheImage</li><li>inSharedCache</li></ul><h2 id="0x04-Clang-编译dsc-extractor-cpp"><a href="#0x04-Clang-编译dsc-extractor-cpp" class="headerlink" title="0x04 Clang++编译dsc_extractor.cpp"></a>0x04 Clang++编译dsc_extractor.cpp</h2><h4 id="生成可执行文件dsc-extractor"><a href="#生成可执行文件dsc-extractor" class="headerlink" title="生成可执行文件dsc_extractor :"></a>生成可执行文件dsc_extractor :</h4><pre><code>$: clang++ -o dsc_extractor dsc_extractor.cpp </code></pre><img src="https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/20200401153405.png" style="zoom:50%;" /><h4 id="抽取动态共享缓存中的Mach-O"><a href="#抽取动态共享缓存中的Mach-O" class="headerlink" title="抽取动态共享缓存中的Mach-O"></a>抽取动态共享缓存中的Mach-O</h4><pre><code>$: cd xxx/com.apple.dyld$: ./dsc_extractor dyld_shared_cache_arm64 arm64_file</code></pre><img src="https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/截屏2020-04-01 下午3.35.35.png" style="zoom:50%;" /><p><strong>dsc_extractor.cpp内容如下:</strong></p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// test program</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stddef.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;dlfcn.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>extractor_proc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> shared_cache_file_path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> extraction_root_path<span class="token punctuation">,</span>                                                    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>progress<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> current<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> total<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> argc <span class="token operator">!=</span> <span class="token number">3</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: dsc_extractor &lt;path-to-cache-file> &lt;path-to-device-dir>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//void* handle = dlopen("/Volumes/my/src/dyld/build/Debug/dsc_extractor.bundle", RTLD_LAZY);</span>    <span class="token keyword">void</span><span class="token operator">*</span> handle <span class="token operator">=</span> <span class="token function">dlopen</span><span class="token punctuation">(</span><span class="token string">"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle"</span><span class="token punctuation">,</span> RTLD_LAZY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> handle <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"dsc_extractor.bundle could not be loaded\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    extractor_proc proc <span class="token operator">=</span> <span class="token punctuation">(</span>extractor_proc<span class="token punctuation">)</span><span class="token function">dlsym</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> <span class="token string">"dyld_shared_cache_extract_dylibs_progress"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> proc <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"dsc_extractor.bundle did not have dyld_shared_cache_extract_dylibs_progress symbol\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>proc<span class="token punctuation">)</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> c<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> total<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d/%d\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"dyld_shared_cache_extract_dylibs_progress() => %d\n"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="0x05反汇编-Hopper-Disassembler"><a href="#0x05反汇编-Hopper-Disassembler" class="headerlink" title="0x05反汇编 Hopper Disassembler"></a>0x05反汇编 Hopper Disassembler</h2><ul><li>[Xclient下载Hopper Disassembler](<a href="https://xclie" target="_blank" rel="noopener">https://xclie</a> nt.info/s/hopper-disassembler.html#versions)</li></ul><h4 id="反汇编分析Mach-O文件"><a href="#反汇编分析Mach-O文件" class="headerlink" title="反汇编分析Mach-O文件"></a>反汇编分析Mach-O文件</h4><h2 id="2、Mach-O文件"><a href="#2、Mach-O文件" class="headerlink" title="2、Mach-O文件"></a>2、Mach-O文件</h2><ul><li><a href="https://opensource.apple.com/tarballs/xnu/" target="_blank" rel="noopener">Mac 内核源码xnu</a></li><li>来源：C/OC/Swift -&gt; .O目标文件-&gt;Mach-O可执行文件</li><li>EXTERNAL_HEADERS-&gt;mach-o查看源码</li></ul><h4 id="2-1-常见Mach-O"><a href="#2-1-常见Mach-O" class="headerlink" title="2.1 常见Mach-O"></a>2.1 常见Mach-O</h4><h4 id="MH-OBJECT"><a href="#MH-OBJECT" class="headerlink" title="MH_OBJECT"></a>MH_OBJECT</h4><ul><li>目标文件(.o)</li><li>静态库文件(.a)-静态库其实就是多个.o的集合</li></ul><h4 id="MH-EXECUTE-可执行文件"><a href="#MH-EXECUTE-可执行文件" class="headerlink" title="MH_EXECUTE:可执行文件"></a>MH_EXECUTE:可执行文件</h4><ul><li>.app/xxx</li></ul><h4 id="MH-DYLib-动态库文件"><a href="#MH-DYLib-动态库文件" class="headerlink" title="MH_DYLib:动态库文件"></a>MH_DYLib:动态库文件</h4><ul><li>.dylib</li><li>.framework/xxx</li></ul><h4 id="MH-DYLIKER动态链接编辑器"><a href="#MH-DYLIKER动态链接编辑器" class="headerlink" title="MH_DYLIKER动态链接编辑器"></a>MH_DYLIKER动态链接编辑器</h4><ul><li>/usr/lib/dyld</li></ul><h4 id="MH-DSYM-存储着二进制文件符号信息"><a href="#MH-DSYM-存储着二进制文件符号信息" class="headerlink" title="MH_DSYM:存储着二进制文件符号信息"></a>MH_DSYM:存储着二进制文件符号信息</h4><ul><li>.dSYM/Contents/Resources/DWARF/XXX</li></ul><h4 id="11种mach-o格式"><a href="#11种mach-o格式" class="headerlink" title="11种mach-o格式"></a>11种mach-o格式</h4><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span>    MH_OBJECT    0x1        </span><span class="token comment" spellcheck="true">/* relocatable object file */</span><span class="token macro property">#<span class="token directive keyword">define</span>    MH_EXECUTE    0x2        </span><span class="token comment" spellcheck="true">/* demand paged executable file */</span><span class="token macro property">#<span class="token directive keyword">define</span>    MH_FVMLIB    0x3        </span><span class="token comment" spellcheck="true">/* fixed VM shared library file */</span><span class="token macro property">#<span class="token directive keyword">define</span>    MH_CORE        0x4        </span><span class="token comment" spellcheck="true">/* core file */</span><span class="token macro property">#<span class="token directive keyword">define</span>    MH_PRELOAD    0x5        </span><span class="token comment" spellcheck="true">/* preloaded executable file */</span><span class="token macro property">#<span class="token directive keyword">define</span>    MH_DYLIB    0x6        </span><span class="token comment" spellcheck="true">/* dynamically bound shared library */</span><span class="token macro property">#<span class="token directive keyword">define</span>    MH_DYLINKER    0x7        </span><span class="token comment" spellcheck="true">/* dynamic link editor */</span><span class="token macro property">#<span class="token directive keyword">define</span>    MH_BUNDLE    0x8        </span><span class="token comment" spellcheck="true">/* dynamically bound bundle file */</span><span class="token macro property">#<span class="token directive keyword">define</span>    MH_DYLIB_STUB    0x9        </span><span class="token comment" spellcheck="true">/* shared library stub for static */</span>                    <span class="token comment" spellcheck="true">/*  linking only, no section contents */</span><span class="token macro property">#<span class="token directive keyword">define</span>    MH_DSYM        0xa        </span><span class="token comment" spellcheck="true">/* companion file with only debug */</span>                    <span class="token comment" spellcheck="true">/*  sections */</span><span class="token macro property">#<span class="token directive keyword">define</span>    MH_KEXT_BUNDLE    0xb        </span><span class="token comment" spellcheck="true">/* x86_64 kexts */</span></code></pre><h4 id="Mach-o的作用"><a href="#Mach-o的作用" class="headerlink" title="Mach-o的作用"></a>Mach-o的作用</h4><ul><li>The layout of the file depends on the filetype.  For all but the MH_OBJECT file type the segments are padded out and aligned on a segment alignment boundary for efficient demand pageing.  </li><li>The MH_EXECUTE, MH_FVMLIB, MH_DYLIB,MH_DYLINKER and MH_BUNDLE file types also have the headers included as part of their first segment.</li><li>Mach-O的布局取决于文件类型。除了MH_OBJECT以外的所有的文件类型将分段填充并在分段对齐时-对齐有效请求分页的边界。</li><li>MH_EXECUTE，MH_FVMLIB，MH_DYLIB，MH_DYLINKER和MH_BUNDLE这些文件也有headers作为它们第一个segment。</li></ul><ul><li><p>The file type MH_OBJECT is a compact format intended as output of the assembler and input (and possibly output) of the link editor (the .oformat).  All sections are in one unnamed segment with no segment padding. </p><ul><li>This format is used as an executable format when the file is so small the segment padding greatly increases its size.</li></ul></li><li><p>文件类型MH_OBJECT是一种紧凑格式，旨在作为汇编器和链接编辑器（.o的输入）（可能是输出格式）。所有sections都在一个未命名的segment中，没有segment的填充。</p></li><li><p>当文件太小时segment填充可以大大增加了它的size。此格式用作可执行格式。</p></li></ul><ul><li><p>The file type MH_PRELOAD is an executable format intended for things that are not executed under the kernel (proms, stand alones, kernels, etc).  </p></li><li><p>The format can be executed under the kernel but may demand paged it and not preload it before execution.</p></li><li><p>文件类型MH_PRELOAD是一种可执行格式，用于非kernel内核下执行。（proms, stand alones, kernels, etc）</p></li><li><p>格式可以在内核下执行，但可能需要分页而不是在执行之前预加载它。</p></li></ul><ul><li>A core file is in MH_CORE format and can be any in an arbritray legal Mach-O file. Constants for the filetype field of the mach_header</li><li>核心文件为MH_CORE格式，可以是任意格式的Mach-O文件。mach_header的文件类型是常量</li></ul><h2 id="Architectures-hpp"><a href="#Architectures-hpp" class="headerlink" title="Architectures.hpp"></a>Architectures.hpp</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Architectures</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">struct</span> x86<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> Pointer32<span class="token operator">&lt;</span>LittleEndian<span class="token operator">></span>        P<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> x86_64<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> Pointer64<span class="token operator">&lt;</span>LittleEndian<span class="token operator">></span>        P<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> arm<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> Pointer32<span class="token operator">&lt;</span>LittleEndian<span class="token operator">></span>        P<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> arm64<span class="token punctuation">{</span>    <span class="token keyword">typedef</span> Pointer64<span class="token operator">&lt;</span>LittleEndian<span class="token operator">></span>        P<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="dyld-cache-format-h"><a href="#dyld-cache-format-h" class="headerlink" title="dyld_cache_format.h"></a>dyld_cache_format.h</h4><pre class=" language-objc"><code class="language-objc">#define IPHONE_DYLD_SHARED_CACHE_DIR    "/System/Library/Caches/com.apple.dyld/"#define DYLD_SHARED_CACHE_BASE_NAME        "dyld_shared_cache_"</code></pre><h4 id="FileAbstraction-hpp"><a href="#FileAbstraction-hpp" class="headerlink" title="FileAbstraction.hpp"></a>FileAbstraction.hpp</h4><pre class=" language-c"><code class="language-c">template <span class="token operator">&lt;</span>typename _E<span class="token operator">></span>class Pointer32<span class="token punctuation">{</span>public<span class="token punctuation">:</span>    <span class="token keyword">typedef</span> uint32_t    uint_t<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _E            E<span class="token punctuation">;</span>    <span class="token keyword">static</span> uint64_t    <span class="token function">getP</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint_t<span class="token operator">&amp;</span> from<span class="token punctuation">)</span>                INLINE <span class="token punctuation">{</span> <span class="token keyword">return</span> _E<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get32</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span>        <span class="token function">setP</span><span class="token punctuation">(</span>uint_t<span class="token operator">&amp;</span> into<span class="token punctuation">,</span> uint64_t value<span class="token punctuation">)</span>        INLINE <span class="token punctuation">{</span> _E<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">set32</span><span class="token punctuation">(</span>into<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Round to a P-size boundary</span>    template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>    <span class="token keyword">static</span> T <span class="token function">round_up</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>    <span class="token keyword">static</span> T <span class="token function">round_down</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>template <span class="token operator">&lt;</span>typename _E<span class="token operator">></span>class Pointer64<span class="token punctuation">{</span>public<span class="token punctuation">:</span>    <span class="token keyword">typedef</span> uint64_t    uint_t<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> _E            E<span class="token punctuation">;</span>    <span class="token keyword">static</span> uint64_t    <span class="token function">getP</span><span class="token punctuation">(</span><span class="token keyword">const</span> uint_t<span class="token operator">&amp;</span> from<span class="token punctuation">)</span>                INLINE <span class="token punctuation">{</span> <span class="token keyword">return</span> _E<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get64</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span>        <span class="token function">setP</span><span class="token punctuation">(</span>uint_t<span class="token operator">&amp;</span> into<span class="token punctuation">,</span> uint64_t value<span class="token punctuation">)</span>        INLINE <span class="token punctuation">{</span> _E<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">set64</span><span class="token punctuation">(</span>into<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Round to a P-size boundary</span>    template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>    <span class="token keyword">static</span> T <span class="token function">round_up</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token number">7</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>    <span class="token keyword">static</span> T <span class="token function">round_down</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token number">7</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="3、符号地址"><a href="#3、符号地址" class="headerlink" title="3、符号地址"></a>3、符号地址</h2><p>符号地址= 基地址 - 偏移地址</p><h4 id="获取基地址"><a href="#获取基地址" class="headerlink" title="获取基地址"></a>获取基地址</h4><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//获取基地址</span>uintptr_t <span class="token function">get_load_address</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> mach_header <span class="token operator">*</span>exe_header <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>uint32_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">_dyld_image_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">struct</span> mach_header <span class="token operator">*</span>header <span class="token operator">=</span> <span class="token function">_dyld_get_image_header</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>header<span class="token operator">-></span>filetype <span class="token operator">==</span> MH_EXECUTE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            exe_header <span class="token operator">=</span> header<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//返回值即为加载地址</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>exe_header<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="获取偏移地址"><a href="#获取偏移地址" class="headerlink" title="获取偏移地址"></a>获取偏移地址</h4><pre class=" language-c"><code class="language-c">uintptr_t <span class="token function">get_slide_address</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    uintptr_t vmaddr_slide <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>uint32_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">_dyld_image_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">struct</span> mach_header <span class="token operator">*</span>header <span class="token operator">=</span> <span class="token function">_dyld_get_image_header</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>header<span class="token operator">-></span>filetype <span class="token operator">==</span> MH_EXECUTE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            vmaddr_slide <span class="token operator">=</span> <span class="token function">_dyld_get_image_vmaddr_slide</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>vmaddr_slide<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="dSYM文件"><a href="#dSYM文件" class="headerlink" title="dSYM文件"></a>dSYM文件</h4><ul><li>编译时添加选项：DWARF with dSYM File，在编译打包完成之后就会生成调试符号文件（Mach-O文件）</li><li>文件查找：找到.xcarchive文件→show package contents→…一直到DWARF→工程二进制文件</li></ul><h4 id="atos命令"><a href="#atos命令" class="headerlink" title="atos命令"></a>atos命令</h4><p>有了dSYM文件，就可以使用atos命令查找到具体代码行出现奔溃信息的地方</p><pre class=" language-c"><code class="language-c">atos <span class="token punctuation">[</span><span class="token operator">-</span>o executable<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>l loadAddress<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>arch architecture<span class="token punctuation">]</span> <span class="token punctuation">[</span>address <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>#<span class="token operator">-</span>arch 选择框架arm64<span class="token operator">/</span>arm32<span class="token operator">/</span>x86_64</code></pre><h2 id="4、Crash收集"><a href="#4、Crash收集" class="headerlink" title="4、Crash收集"></a>4、Crash收集</h2><h4 id="KSCrash"><a href="#KSCrash" class="headerlink" title="KSCrash"></a><a href="https://github.com/kstenerud/KSCrash" target="_blank" rel="noopener">KSCrash</a></h4><h4 id="SentryCocoa"><a href="#SentryCocoa" class="headerlink" title="SentryCocoa"></a><a href="https://github.com/getsentry/sentry-cocoa" target="_blank" rel="noopener">SentryCocoa</a></h4><ul><li><h5 id="SentryCrashDynamicLinker"><a href="#SentryCrashDynamicLinker" class="headerlink" title="SentryCrashDynamicLinker"></a><a href="https://github.com/getsentry/sentry-cocoa/blob/master/Sources/SentryCrash/Recording/Tools/SentryCrashDynamicLinker.c" target="_blank" rel="noopener">SentryCrashDynamicLinker</a></h5></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一颗太阳</title>
      <link href="/2020/03/18/%E4%B8%80%E9%A2%97%E5%A4%AA%E9%98%B3/"/>
      <url>/2020/03/18/%E4%B8%80%E9%A2%97%E5%A4%AA%E9%98%B3/</url>
      
        <content type="html"><![CDATA[<p>激情岁月</p><h2 id="一颗太阳"><a href="#一颗太阳" class="headerlink" title="一颗太阳"></a>一颗太阳</h2><h2 id="一千颗太阳"><a href="#一千颗太阳" class="headerlink" title="一千颗太阳"></a>一千颗太阳</h2><p><strong>1967年6月17日</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序问题</title>
      <link href="/2020/03/15/%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/15/%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>带着问题去学习，是最有效的学习方法。所以按照惯例，我还是先给你出一个思考题：</p><h3 id="问题一：为什么插入排序比冒泡排序更受欢迎？"><a href="#问题一：为什么插入排序比冒泡排序更受欢迎？" class="headerlink" title="问题一：为什么插入排序比冒泡排序更受欢迎？"></a>问题一：为什么插入排序比冒泡排序更受欢迎？</h3><h4 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h4><hr><ul><li><p>最好情况、最坏情况、平均情况时间复杂度</p></li><li><p>时间复杂度的系数、常数、低阶</p></li><li><p>比较次数和交换次数</p></li></ul><h4 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h4><hr><p>原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。(冒泡排序、插入排序)</p><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><ul><li>经过某种排序算法排序之后，如果两个相同数值的前后顺序没有改变，那我们就把这种排序算法叫作<strong>稳定的排序算法</strong>；</li><li>如果前后顺序发生变化，那对应的排序算法就叫作不稳定的<strong>排序算法</strong>。</li></ul><h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><ul><li>冒泡排序只会操作相邻元素的两个数据</li><li>每次都是对相邻的两个元素比较大小，前面的元素大于后面的元素，交换前后元素，一轮循环后最后元素就是最大元素</li><li>第二轮循环后，倒数第二个元素就是第二大元素</li><li>直到所有元素都是有序的停止排序</li></ul><p><strong>冒泡排序图示：</strong><br><img src="https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg" alt=""></p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">/// 冒泡排序</span><span class="token keyword">func</span> bubbleSort<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> array<span class="token punctuation">:</span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token keyword">where</span> T<span class="token punctuation">:</span> <span class="token builtin">Comparable</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> array <span class="token operator">=</span> array    <span class="token keyword">guard</span> array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> array    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//提前退出标志</span>        <span class="token keyword">var</span> flag<span class="token punctuation">:</span> <span class="token builtin">Bool</span> <span class="token operator">=</span> <span class="token boolean">false</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>                array<span class="token punctuation">.</span><span class="token function">swapAt</span><span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//有数据交换</span>                flag <span class="token operator">=</span> <span class="token boolean">true</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//没有数据交换-提前退出</span>        <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> array<span class="token punctuation">}</span></code></pre><p>现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。</p><h4 id="第一，冒泡排序是原地排序算法吗？"><a href="#第一，冒泡排序是原地排序算法吗？" class="headerlink" title="第一，冒泡排序是原地排序算法吗？"></a>第一，冒泡排序是原地排序算法吗？</h4><p><strong>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</strong></p><h4 id="第二，冒泡排序是稳定的排序算法吗？"><a href="#第二，冒泡排序是稳定的排序算法吗？" class="headerlink" title="第二，冒泡排序是稳定的排序算法吗？"></a>第二，冒泡排序是稳定的排序算法吗？</h4><p><strong>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</strong></p><h4 id="第三，冒泡排序的时间复杂度是多少？"><a href="#第三，冒泡排序的时间复杂度是多少？" class="headerlink" title="第三，冒泡排序的时间复杂度是多少？"></a>第三，冒泡排序的时间复杂度是多少？</h4><p><strong>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。平均时间复杂度也是O(n2)</strong></p><h2 id="2、插入排序"><a href="#2、插入排序" class="headerlink" title="2、插入排序"></a>2、插入排序</h2><ul><li>插入排序是将数组分成两个部分，已排序和未排序</li><li>初始化已排序部分只有一个元素就是数组第一个元素</li><li>插入排序的核心思想就是<strong>取出未排序部分的元素</strong>，在已排序区间中找到<strong>合适的插入位置插入，保证已排序区间的数据一直是有序的。</strong></li></ul><h4 id="插入排序如下图："><a href="#插入排序如下图：" class="headerlink" title="插入排序如下图："></a>插入排序如下图：</h4><p><img src="https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg" alt=""></p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">///插入排序</span><span class="token keyword">func</span> insertSort<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> elements<span class="token punctuation">:</span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token keyword">where</span> T<span class="token punctuation">:</span> <span class="token builtin">Comparable</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> array <span class="token operator">=</span> elements    <span class="token keyword">guard</span> array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> array    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> value <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">var</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true">//查找要插入的位置</span>        <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> array<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">></span> value <span class="token punctuation">{</span>                array<span class="token punctuation">[</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token comment" spellcheck="true">//移动数据</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token comment" spellcheck="true">// 插入数据</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> array<span class="token punctuation">}</span></code></pre><blockquote><p>插入排序也包含两种操作，一种是<strong>元素的比较</strong>，一种是<strong>元素的移动</strong>。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p></blockquote><blockquote><p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，<strong>移动操作的次数总是固定的，就等于逆序度 = 满有序度-初始有序度</strong>。</p></blockquote><p>现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。</p><h4 id="第一，插入排序是原地排序算法吗？"><a href="#第一，插入排序是原地排序算法吗？" class="headerlink" title="第一，插入排序是原地排序算法吗？"></a>第一，插入排序是原地排序算法吗？</h4><p><strong>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。</strong></p><h4 id="第二，插入排序是稳定的排序算法吗？"><a href="#第二，插入排序是稳定的排序算法吗？" class="headerlink" title="第二，插入排序是稳定的排序算法吗？"></a>第二，插入排序是稳定的排序算法吗？</h4><p><strong>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</strong></p><h4 id="第三，插入排序的时间复杂度是多少？"><a href="#第三，插入排序的时间复杂度是多少？" class="headerlink" title="第三，插入排序的时间复杂度是多少？"></a>第三，插入排序的时间复杂度是多少？</h4><ul><li>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。</li><li>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。</li><li>还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n2)。</li></ul><h2 id="3、选择排序（Selection-Sort）"><a href="#3、选择排序（Selection-Sort）" class="headerlink" title="3、选择排序（Selection Sort）"></a>3、选择排序（Selection Sort）</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从<strong>未排序区间中找到最小的元素，将其放到已排序区间的末尾。</strong></p><p><img src="https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg" alt=""></p><h4 id="第一，选择排序是原地排序算法吗？"><a href="#第一，选择排序是原地排序算法吗？" class="headerlink" title="第一，选择排序是原地排序算法吗？"></a>第一，选择排序是原地排序算法吗？</h4><p>选择排序的时间复杂度是O(1)所以是原地排序</p><h4 id="第二，选择排序是稳定的排序算法吗？"><a href="#第二，选择排序是稳定的排序算法吗？" class="headerlink" title="第二，选择排序是稳定的排序算法吗？"></a>第二，选择排序是稳定的排序算法吗？</h4><p><strong>不是稳定排序，对于选择排序来说每次都是从未排序序列中找到最小的插入到已排序序列的末尾处，和前面的元素交换，这样会破坏稳定性</strong></p><blockquote><p>比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。\</p></blockquote><h4 id="第三，选择排序的时间复杂度是多少？"><a href="#第三，选择排序的时间复杂度是多少？" class="headerlink" title="第三，选择排序的时间复杂度是多少？"></a>第三，选择排序的时间复杂度是多少？</h4><p><strong>选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。</strong></p><h2 id="总结三种时间复杂度是-O-n2-的排序算法"><a href="#总结三种时间复杂度是-O-n2-的排序算法" class="headerlink" title="总结三种时间复杂度是 O(n2) 的排序算法"></a>总结三种时间复杂度是 O(n2) 的排序算法</h2><blockquote><p>这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高，所以我们更倾向于用下一节要讲的时间复杂度为 O(nlogn) 的排序算法。</p></blockquote><p><img src="https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg" alt=""></p><hr><hr><h3 id="问题二：如何在-O-n-的时间复杂度内查找一个无序数组中的第-K-大元素"><a href="#问题二：如何在-O-n-的时间复杂度内查找一个无序数组中的第-K-大元素" class="headerlink" title="问题二：如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素?"></a>问题二：如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素?</h3><h2 id="1、归并排序"><a href="#1、归并排序" class="headerlink" title="1、归并排序"></a>1、归并排序</h2><blockquote><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p></blockquote><p><strong>归并排序的核心是合并：依次合并N个堆得数据</strong></p><ul><li>1、在合并时，您需要两个索引来跟踪两个数组的进度。</li><li>2、这是合并后的数组。 它现在是空的，但是你将在下面的步骤中通过添加其他数组中的元素构建它。</li><li>3、这个while循环将比较左侧和右侧的元素，并将它们添加到orderedPile，同时确保结果保持有序。</li><li>4、如果前一个while循环完成，则意味着leftPile或rightPile中的一个的内容已经完全合并到orderedPile中。此时，您不再需要进行比较。只需依次添加剩下一个数组的其余内容到orderedPile。</li></ul><p><img src="https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg" alt=""></p><ul><li>归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</li><li>从我刚才的描述，你有没有感觉到，分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。</strong></li></ul><p>所以归并排序的核心就是递归写法：</p><pre><code>递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))终止条件：p &gt;= r 不用再继续分解</code></pre><p>有了递推公式，转化成代码就简单多了:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token number">_</span> leftArray<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">_</span> rightArray<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1</span>    <span class="token keyword">var</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">//2</span>    <span class="token keyword">var</span> mergeArr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">//3</span>    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> leftArray<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> rightArray<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> leftArray<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> rightArray<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token punctuation">{</span>            mergeArr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>rightArray<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            r <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> leftArray<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rightArray<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token punctuation">{</span>            mergeArr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>leftArray<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span>            l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            mergeArr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>leftArray<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span>            l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>            mergeArr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>rightArray<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            r <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//4</span>    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> leftArray<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token punctuation">{</span>        mergeArr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>leftArray<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span>        l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> r <span class="token operator">&lt;</span> rightArray<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token punctuation">{</span>        mergeArr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>rightArray<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>        r <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> mergeArr<span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 1、如果数组为空或包含单个元素，则无法将其拆分为更小的部分，返回数组就行。 2、找到中间索引。 3、使用上一步中的中间索引，递归地分割数组的左侧。 4、递归地分割数组的右侧。 5、最后，将所有值合并在一起，确保它始终排序。 */</span><span class="token keyword">func</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token number">_</span> array<span class="token punctuation">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1</span>    <span class="token keyword">guard</span> array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> array    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//2</span>    <span class="token keyword">let</span> middle <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">/</span> <span class="token number">2</span>    <span class="token comment" spellcheck="true">//3</span>    <span class="token keyword">let</span> leftPart <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token function">Array</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>middle<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//4</span>    <span class="token keyword">let</span> rightPart <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token function">Array</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>middle<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>array<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//5</span>    <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span>leftPart<span class="token punctuation">,</span> rightPart<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h2><p><a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Quicksort" target="_blank" rel="noopener">快速排序是原地排序，也是递归实现，但快速排序不是稳定排序</a></p><blockquote><p>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。<br>归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。<br> 快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p></blockquote><blockquote><p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p></blockquote><blockquote><p>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p></blockquote><p><img src="https://static001.geekbang.org/resource/image/4d/81/4d892c3a2e08a17f16097d07ea088a81.jpg" alt=""><br> 直接递归：<br> 1、设置中间位置元素为轴点元素pivot<br> 2、分区：less equal more<br> 3、递归合并分区</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> quickSort<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Comparable</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> array<span class="token punctuation">:</span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> pivot <span class="token operator">=</span> array<span class="token punctuation">[</span>array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span>    <span class="token keyword">let</span> less <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">&lt;</span> pivot <span class="token punctuation">}</span>    <span class="token keyword">let</span> <span class="token builtin">equal</span> <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">==</span> pivot <span class="token punctuation">}</span>    <span class="token keyword">let</span> more <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">></span> pivot <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>less<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">equal</span> <span class="token operator">+</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>more<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 1、从序列中选择中轴点pivot（假设选择位置为0的元素） 2、利用pivot中轴点把序列分成两个子序列 3、分别对左右子序列递归进行快速排序，直到元素不能分割位置   快速排序的本质是把每一个元素都转换成中轴点。 */</span><span class="token keyword">public</span> <span class="token keyword">func</span> quickSortDutch<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Comparable</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> a<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> low <span class="token operator">&lt;</span> high <span class="token punctuation">{</span>        <span class="token keyword">let</span> pivot <span class="token operator">=</span> <span class="token builtin">Int</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token keyword">in</span><span class="token punctuation">:</span> low<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>        <span class="token keyword">let</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> q<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">partationDutch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> low<span class="token punctuation">:</span> low<span class="token punctuation">,</span> high<span class="token punctuation">:</span> high<span class="token punctuation">,</span> pivotIndex<span class="token punctuation">:</span> pivot<span class="token punctuation">)</span>        <span class="token function">quickSortDutch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> low<span class="token punctuation">:</span> low<span class="token punctuation">,</span> high<span class="token punctuation">:</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">quickSortDutch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> low<span class="token punctuation">:</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">:</span> high<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="Lomuto分区-Vs-Hoare分区-Vs-荷兰国旗分区"><a href="#Lomuto分区-Vs-Hoare分区-Vs-荷兰国旗分区" class="headerlink" title="Lomuto分区 Vs Hoare分区 Vs 荷兰国旗分区"></a>Lomuto分区 Vs Hoare分区 Vs 荷兰国旗分区</h4><blockquote><p>Lomuto分区法:是用数组最后一个元素作为基准元素对数组分区，区域为[low…p-1] [p+1…high]，然后递归调用quickLomutoSort分别对左右区排序，一直到数组有序</p></blockquote><hr><blockquote><p>Hoare分区：选择数组的first元素作为基准，数组划分区域为[low…p] [p+1…high]，然后递归调用quickSortHoare分别对左右区排序，一直到数组有序</p></blockquote><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">/* 3 荷兰国旗分区：将前部和后部各排在数组的前边和后边，中部自然就排好了,分区函数返回(p, q) 设置两个标志位begin和end分别指向这个数组的开始和末尾，然后用一个标志位current从头开始进行遍历： 1）若遍历到的current &lt; pivot，于是就和begin位置进行交换，然后current向前进，begin也向前进（表示前边的已经都排好了）。 2）若遍历到current == pivot，则说明它一定属于中部，根据总思路，中部的我们都不动，然后current向前进。 3）若遍历到current > pivot，则说明它一定属于后部，于是就和end位置进行交换，    由于交换完毕后current指向的可能是属于前部的，若此时current前进则会导致该位置不能被交换到前部，所以此时current不前进。    end向后退1。 4) 返回分区（begin, end） */</span><span class="token keyword">func</span> partationDutch<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Comparable</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> a<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> pivotIndex<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> begin <span class="token operator">=</span> low<span class="token punctuation">,</span> end <span class="token operator">=</span> high    <span class="token keyword">var</span> current <span class="token operator">=</span> low<span class="token punctuation">,</span> pivot <span class="token operator">=</span> a<span class="token punctuation">[</span>pivotIndex<span class="token punctuation">]</span>    <span class="token keyword">while</span> current <span class="token operator">&lt;=</span> end <span class="token punctuation">{</span>        <span class="token keyword">if</span> a<span class="token punctuation">[</span>current<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot <span class="token punctuation">{</span>            a<span class="token punctuation">.</span><span class="token function">swapAt</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> current<span class="token punctuation">)</span>            begin <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>            current <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> a<span class="token punctuation">[</span>current<span class="token punctuation">]</span> <span class="token operator">==</span> pivot <span class="token punctuation">{</span>            current <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            a<span class="token punctuation">.</span><span class="token function">swapAt</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> end<span class="token punctuation">)</span>            end <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>解答问题二：</p><ul><li><p>快排核心思想就是分治和分区，我们可以利用分区的思想，来解答开这个问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。</p></li><li><p>我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p></li><li><p>如果 p+1=K，那 A[p]就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1]区间查找。</p></li></ul><p>本文参考：<a href="https://time.geekbang.org/column/article/41913" target="_blank" rel="noopener">王争-数据结构与算法之美</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反转问题</title>
      <link href="/2020/03/15/%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/15/%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><blockquote><p>原地反转字符串是否代表了空间复杂度为常数？<br>不，原地反转字符串是一种不使用辅助数据结构的算法。</p></blockquote><blockquote><p>我们使用递归的方法去反转字符串，它是原地反转，但是空间复杂度却不是常数级空间，因为递归过程中使用了堆栈空间。</p></blockquote><h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><ul><li><p>我们实现递归函数 helper，它接受两个参数：left 左指针和 right 右指针。</p></li><li><p>如果 left&gt;=right，不做任何操作。</p></li><li><p>否则交换 s[left] 和 s[right] 和调用 helper(left + 1, right - 1)。</p></li><li><p>首次调用函数我们传递首尾指针反转整个字符串 return helper(0, len(s) - 1)。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> tmp <span class="token operator">=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>  s<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>  s<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token function">helper</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverseString</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">helper</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度：\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。</strong></p><p><strong>空间复杂度：\mathcal{O}(N)O(N)，递归过程中使用的堆栈空间。</strong></p><h3 id="方法二：双指针法"><a href="#方法二：双指针法" class="headerlink" title="方法二：双指针法"></a>方法二：双指针法</h3><p><strong>双指针法是使用两个指针，一个左指针 left，右指针 right，开始工作时 left 指向首元素，right 指向尾元素。交换两个指针指向的元素，并向中间移动，直到两个指针相遇。</strong></p><h4 id="算法过程-1"><a href="#算法过程-1" class="headerlink" title="算法过程"></a>算法过程</h4><ul><li>将 left 指向首元素，right 指向尾元素。</li><li>当 left&lt;right：</li><li>交换 s[left] 和 s[right]。</li><li>left++</li><li>right++</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// 双指针</span><span class="token keyword">func</span> <span class="token function">reverseStr</span><span class="token punctuation">(</span><span class="token number">_</span> s<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token punctuation">[</span><span class="token builtin">Character</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Character</span><span class="token punctuation">]</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> <span class="token keyword">left</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">right</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> <span class="token keyword">left</span> <span class="token operator">&lt;</span> <span class="token keyword">right</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token keyword">left</span><span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span><span class="token keyword">right</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token keyword">right</span><span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span><span class="token keyword">left</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">left</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">right</span> <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">}</span></code></pre><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">"123456abcdef"</span><span class="token keyword">var</span> characters <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>characters<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//["1", "2", "3", "4", "5", "6", "a", "b", "c", "d", "e", "f"]</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">reverseStr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>characters<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//["f", "e", "d", "c", "b", "a", "6", "5", "4", "3", "2", "1"]</span></code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度：\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。</strong><br><strong>空间复杂度：\mathcal{O}(1)O(1)，只使用了常数级空间。</strong></p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><ul><li>定义两个指针pre cur : pre在前 cur 在后</li><li>如果cur节点不为空，设置pre.next = cur 实现一次翻转</li><li>翻转后pre 、cur同步向前一步</li><li>当pre为空终止循环</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token number">_</span> head<span class="token punctuation">:</span> <span class="token builtin">ListNode</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">ListNode</span><span class="token operator">?</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> head <span class="token operator">==</span> <span class="token constant">nil</span> <span class="token operator">||</span> head<span class="token operator">?</span><span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token constant">nil</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> head <span class="token punctuation">}</span>    <span class="token keyword">var</span> pre <span class="token operator">=</span> head<span class="token punctuation">,</span> cur<span class="token punctuation">:</span> <span class="token builtin">ListNode</span><span class="token operator">?</span>    <span class="token keyword">while</span> pre <span class="token operator">!=</span> <span class="token constant">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> temp <span class="token operator">=</span> pre<span class="token operator">?</span><span class="token punctuation">.</span>next        pre<span class="token operator">?</span><span class="token punctuation">.</span>next <span class="token operator">=</span> cur        cur <span class="token operator">=</span> pre<span class="token operator">!</span>        pre <span class="token operator">=</span> temp    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cur<span class="token punctuation">}</span></code></pre><pre class=" language-swift"><code class="language-swift"> 递归法核心：<span class="token function">reversList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">reverseList2</span><span class="token punctuation">(</span><span class="token number">_</span> head<span class="token punctuation">:</span> <span class="token builtin">ListNode</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">ListNode</span><span class="token operator">?</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> head <span class="token operator">==</span> <span class="token constant">nil</span> <span class="token operator">||</span> head<span class="token operator">?</span><span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token constant">nil</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token constant">nil</span> <span class="token punctuation">}</span>    <span class="token keyword">let</span> newHead <span class="token operator">=</span> <span class="token function">reverseList2</span><span class="token punctuation">(</span>head<span class="token operator">?</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span>    head<span class="token operator">?</span><span class="token punctuation">.</span>next<span class="token operator">?</span><span class="token punctuation">.</span>next <span class="token operator">=</span> head    head<span class="token operator">?</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">nil</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">}</span></code></pre><h2 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h2><h4 id="题目描述：反转从位置-m-到-n-的链表。请使用一趟扫描完成反转。说明-1-≤-m-≤-n-≤-链表长度"><a href="#题目描述：反转从位置-m-到-n-的链表。请使用一趟扫描完成反转。说明-1-≤-m-≤-n-≤-链表长度" class="headerlink" title="题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明:1 ≤ m ≤ n ≤ 链表长度"></a>题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明:1 ≤ m ≤ n ≤ 链表长度</h4><ul><li>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</li><li>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL<h4 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h4></li></ul><p>第一步：找到待反转节点的前一个节点。<br>第二步：反转m到n这部分。<br>第三步：将反转的起点的next指向反转的后面一部分。<br>第四步：将第一步找到的节点指向反转以后的头节点。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode node <span class="token operator">=</span> res<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找到需要反转的那一段的上一个节点。</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//node.next就是需要反转的这段的起点。</span>        ListNode nextHead <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        ListNode next <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//反转m到n这一段</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            next <span class="token operator">=</span> nextHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            nextHead<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> nextHead<span class="token punctuation">;</span>            nextHead <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将反转的起点的next指向next。</span>        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//需要反转的那一段的上一个节点的next节点指向反转后链表的头结点</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>智力题</title>
      <link href="/2020/03/15/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
      <url>/2020/03/15/%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h1><h2 id="1、有两个水桶，-一个装-3L-的水，-一个可装-5L-的水，-问-如何利用这两个桶，-量出-4L-的水来？"><a href="#1、有两个水桶，-一个装-3L-的水，-一个可装-5L-的水，-问-如何利用这两个桶，-量出-4L-的水来？" class="headerlink" title="1、有两个水桶， 一个装 3L 的水， 一个可装 5L 的水， 问:如何利用这两个桶， 量出 4L 的水来？"></a>1、有两个水桶， 一个装 3L 的水， 一个可装 5L 的水， 问:如何利用这两个桶， 量出 4L 的水来？</h2><p>解法一加法：操作两次3L的桶，得到1L的水，然后倒入5L的桶里面，此时5L桶里有1L的水，再次用3L的桶倒入5L桶，1L+ 3L = 4L,一共操作3次3L桶</p><p><strong>加法解法图示：</strong><br><img src="https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/plus.jpg" alt=""></p><p>解法二减法：5L满水的桶倒入3L的桶，剩余2L，5L桶剩余的2L再次倒入3L桶，此时3L桶还有1L集满，5L桶再次装满后倒出来1L给3L桶里面，5L - 1L = 4L,连续操作3次5L桶</p><p><strong>减法解法图示：</strong><br><img src="https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/%E5%87%8F%E6%B3%95.jpg" alt=""></p><h2 id="2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？"><a href="#2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？" class="headerlink" title="2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？"></a>2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？</h2><p><strong>首先2的6次方64，2的7次方128 &gt; 100<br>因此我们可以用7个的二进制给100个瓶子编号，7只老鼠分别对应7个二进制位，如果瓶子编号出现1，老鼠喝下瓶子中的毒药，最后统计出被毒死老鼠的二进制数，转换为10进制就是有毒瓶子的编号。</strong></p><p><strong>解法图示：</strong></p><p><img src="https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/%E8%80%81%E9%BC%A0%E9%97%AE%E9%A2%98.JPG" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Runloop</title>
      <link href="/2020/03/11/Runloop/"/>
      <url>/2020/03/11/Runloop/</url>
      
        <content type="html"><![CDATA[<h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><h2 id="1-讲讲-RunLoop，项目中有用到吗？"><a href="#1-讲讲-RunLoop，项目中有用到吗？" class="headerlink" title="1.讲讲 RunLoop，项目中有用到吗？"></a>1.讲讲 RunLoop，项目中有用到吗？</h2><ul><li>事件循环，在程序运行中循环做一些事情</li><li>没有消息mach_msg()切换用户态到内核态线程休眠，有消息内核态切换到用户态</li></ul><h3 id="runloop相关："><a href="#runloop相关：" class="headerlink" title="runloop相关："></a>runloop相关：</h3><ul><li>Timer、performSelector</li><li>GCD、AutoreleasePool</li><li>事件响应、收拾识别、网络请求</li></ul><h3 id="runloop的应用："><a href="#runloop的应用：" class="headerlink" title="runloop的应用："></a>runloop的应用：</h3><ul><li>线程包活</li><li>解决timer滑动停止问题</li><li>监听主线程卡顿</li><li>性能优化</li></ul><h2 id="2-runloop的6种状态和runloop内部实现逻辑？"><a href="#2-runloop的6种状态和runloop内部实现逻辑？" class="headerlink" title="2.runloop的6种状态和runloop内部实现逻辑？"></a>2.runloop的6种状态和runloop内部实现逻辑？</h2><pre><code>/* Run Loop Observer Activities */typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {    kCFRunLoopEntry = (1UL &lt;&lt; 0),           // 即将进入Loop    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),    //即将处理Timer    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),   //即将处理Source    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),   //即将进入休眠    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),    //刚从休眠中唤醒    kCFRunLoopExit = (1UL &lt;&lt; 7),            //即将退出Loop    kCFRunLoopAllActivities = 0x0FFFFFFFU};</code></pre><ul><li><strong>source0 : 触摸事件、performSelectorOnThread:</strong></li><li><strong>source1: 基于Port的线程间通讯，捕获到的系统事件</strong></li><li><strong>timers: NSTimer + performSelector:afterDelay:</strong></li><li><strong>observers: 监听runloop的状态/autoreleasePool的创建和释放、UI的刷新</strong></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/3/5/170a9f4968fe6f59?w=1012&h=858&f=png&s=146946" alt="img"></p><h2 id="3-runloop和线程的关系？"><a href="#3-runloop和线程的关系？" class="headerlink" title="3.runloop和线程的关系？"></a>3.runloop和线程的关系？</h2><ul><li>一一对应</li><li>保存在一个全局字典中，线程是key, runloop是value</li><li>子线程默认没有runloop，在第一次获取runloop时才会创建。</li><li>runloop在线程结束时销毁</li></ul><h2 id="4-timer-与-runloop-的关系？"><a href="#4-timer-与-runloop-的关系？" class="headerlink" title="4.timer 与 runloop 的关系？"></a>4.timer 与 runloop 的关系？</h2><h2 id="程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？"><a href="#程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？" class="headerlink" title="程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？"></a>程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？</h2><h2 id="5-runloop-是怎么响应用户操作的，-具体流程是什么样的？"><a href="#5-runloop-是怎么响应用户操作的，-具体流程是什么样的？" class="headerlink" title="5.runloop 是怎么响应用户操作的， 具体流程是什么样的？"></a>5.runloop 是怎么响应用户操作的， 具体流程是什么样的？</h2><h2 id="6-说说runLoop的几种状态"><a href="#6-说说runLoop的几种状态" class="headerlink" title="6.说说runLoop的几种状态"></a>6.说说runLoop的几种状态</h2><h2 id="7-runloop的mode作用是什么？"><a href="#7-runloop的mode作用是什么？" class="headerlink" title="7.runloop的mode作用是什么？"></a>7.runloop的mode作用是什么？</h2><ul><li><p>CFRunLoopModeRef代表<strong>RunLoop的运行模式</strong></p></li><li><p>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer</p></li><li><p>RunLoop启动时只能选择其中一个Mode，作为<strong>currentMode</strong></p></li><li><p>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入</p></li><li><p><strong>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</strong></p></li><li><p><strong>如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出</strong></p></li></ul><h2 id="8-KVO实现原理-哪些情况下使用kvo会崩溃，怎么防护崩溃"><a href="#8-KVO实现原理-哪些情况下使用kvo会崩溃，怎么防护崩溃" class="headerlink" title="8.KVO实现原理?哪些情况下使用kvo会崩溃，怎么防护崩溃?"></a>8.KVO实现原理?哪些情况下使用kvo会崩溃，怎么防护崩溃?</h2><h2 id="9-如何手动关闭KVO-如何手动自己实现KVO说说思路"><a href="#9-如何手动关闭KVO-如何手动自己实现KVO说说思路" class="headerlink" title="9.如何手动关闭KVO?如何手动自己实现KVO说说思路"></a>9.如何手动关闭KVO?如何手动自己实现KVO说说思路</h2><h2 id="10-通过KVC修改属性会触发KVO么"><a href="#10-通过KVC修改属性会触发KVO么" class="headerlink" title="10.通过KVC修改属性会触发KVO么"></a>10.通过KVC修改属性会触发KVO么</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS多线程</title>
      <link href="/2020/03/11/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/03/11/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="深入理解GCD"><a href="#深入理解GCD" class="headerlink" title="深入理解GCD"></a><a href="https://bestswifter.com/deep-gcd/" target="_blank" rel="noopener">深入理解GCD</a></h2><p><strong><code>dispatch_async</code> 会把任务添加到队列的一个链表中，添加完后会唤醒队列，根据 vtable 中的函数指针，调用 wakeup 方法。</strong></p><ul><li>在 wakeup 方法中，从线程池里取出工作线程(如果没有就新建)，然后在工作线程中取出链表头部指向的 block 并执行。</li></ul><p><strong><code>dispatch_sync</code> 的实现略简单一些，它不涉及线程池(因此一般都在当前线程执行)，而是利用与线程绑定的信号量来实现串行。</strong></p><p>分发到不同队列时，代码进入的分支也不一样，比如 <code>dispatch_async</code> 到主队列的任务由 runloop 处理，而分发到其他队列的任务由线程池处理。</p><p>在当前串行队列中执行 <code>dispatch_sync</code> 时，由于 <code>dq_running</code> 属性(表示在运行的任务数量) 为 1，所以以下判断成立:</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">slowpath</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">dispatch_atomic_cmpxchg2o</span><span class="token punctuation">(</span>dq<span class="token punctuation">,</span> dq_running<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">_dispatch_barrier_sync_f_slow</span><span class="token punctuation">(</span>dq<span class="token punctuation">,</span> ctxt<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在 <code>_dispatch_barrier_sync_f_slow</code> 函数中使用了线程对应的信号量并且调用 <code>wait</code> 方法，从而导致线程死锁。</p><p>如果向其它队列同步提交 block，最终进入 <code>_dispatch_barrier_sync_f_invoke</code>，它只是保证了 block 执行的原子性，但没有使用线程对应的信号量。</p><p><strong>对于信号量来说，它主要使用 <code>signal</code> 和 <code>wait</code> 这两个接口，底层分别调用了内核提供的方法。</strong></p><ul><li>在调用 wait 方法后，先将 value 减一，如果大于零立刻返回，否则陷入等待。<code>signal</code> 方法将信号量加一，如果 value 大于零立刻返回，否则说明唤醒了某一个等待线程，此时由系统决定哪个线程的等待方法可以返回。</li></ul><p><strong><code>dispatch_group</code> 的本质就是一个 value 非常大的信号量，等待 group 完成实际上就是等待 value 恢复初始值。</strong>而</p><ul><li>notify 的作用是将所有注册的回调组装成一个链表，在 <code>dispatch_async</code> 完成时判断 value 是不是恢复初始值，如果是则调用 <code>dispatch_async</code> 异步执行所有注册的回调。</li></ul><p><strong><code>dispatch_once</code> 通过一个静态变量来标记 block 是否已被执行，同时使用信号量确保只有一个线程能执行，执行完 block 后会唤醒其他所有等待的线程。</strong></p><p><strong><code>dispatch_barrier_async</code> 改变了 block 的 <code>vtable</code> 标记位，当它将要被取出执行时，会等待前面的 block 都执行完，然后在下一次循环中被执行。</strong></p><p><strong><code>dispatch_source</code> 可以用来实现定时器。</strong></p><ul><li>所有的 source 会被提交到用户指定的队列，然后提交到 manager 队列中，按照触发时间排好序。</li><li>随后找到最近触发的定时器，调用内核的 <code>select</code> 方法等待。</li><li>等待结束后，依次唤醒 manager 队列和用户指定队列，最终触发一开始设置的回调 block。</li></ul><p><strong>GCD 中的对象用 <code>do_suspend_cnt</code> 来表示是否暂停。队列默认处于启动状态，而 <code>dispatch_source</code> 需要手动启动。</strong></p><p><strong><code>dispatch_after</code> 函数依赖于 <code>dispatch_source</code> 定时器，它只是注册了一个定时器，然后在回调函数中执行 block。</strong></p><p><a href="https://www.cnblogs.com/beckwang0912/p/7146833.html" target="_blank" rel="noopener">GCD死锁案例分析</a></p><p><a href="https://juejin.im/post/5ab4a4466fb9a028d14107ff#heading-31" target="_blank" rel="noopener">NSOperation案例分析</a></p><h2 id="深入理解iOS开发中的锁"><a href="#深入理解iOS开发中的锁" class="headerlink" title="深入理解iOS开发中的锁"></a><a href="https://bestswifter.com/ios-lock/" target="_blank" rel="noopener">深入理解iOS开发中的锁</a></h2><p><img src="http://images.bestswifter.com/lock_benchmark.png" alt=""></p><h4 id="自旋锁的目的是为了确保临界区只有一个线程可以访问"><a href="#自旋锁的目的是为了确保临界区只有一个线程可以访问" class="headerlink" title="自旋锁的目的是为了确保临界区只有一个线程可以访问"></a>自旋锁的目的是为了确保临界区只有一个线程可以访问</h4><pre class=" language-objc"><code class="language-objc">bool lock = false; // 一开始没有锁上，任何线程都可以申请锁  do {      while(test_and_set(&lock); // test_and_set 是一个原子操作        Critical section  // 临界区    lock = false; // 相当于释放锁，这样别的线程可以进入临界区        Reminder section // 不需要锁保护的代码        }</code></pre><ul><li>显然在 while 循环中，<strong>线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。</strong></li><li>如果临界区的执行时间过长，使用自旋锁不是个好主意</li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>首先会把信号量的值减一，并判断是否大于零。</li><li>如果大于零，说明不用等待，所以立刻返回。小于0等待signal唤醒线程</li></ul><h4 id="pthread-mutex互斥锁"><a href="#pthread-mutex互斥锁" class="headerlink" title="pthread_mutex互斥锁"></a>pthread_mutex互斥锁</h4><ul><li>互斥锁的实现原理与信号量非常相似，不是使用忙等，而是<strong>阻塞线程并睡眠，需要进行上下文切换。</strong></li></ul><pre class=" language-objc"><code class="language-objc">pthread_mutexattr_t attr;  pthread_mutexattr_init(&attr);  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);  // 定义锁的属性pthread_mutex_t mutex;  pthread_mutex_init(&mutex, &attr) // 创建锁pthread_mutex_lock(&mutex); // 申请锁      // 临界区pthread_mutex_unlock(&mutex); // 释放锁 </code></pre><ul><li>一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。</li><li>假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。</li><li>然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 <code>pthread_mutex</code> 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 <code>PTHREAD_MUTEX_RECURSIVE</code> 即可。</li></ul><h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><ul><li><p><code>NSLock</code> 只是在内部封装了一个 <code>pthread_mutex</code>，属性为 <code>PTHREAD_MUTEX_ERRORCHECK</code>，它会损失一定性能换来错误提示。</p></li><li><p><code>NSLock</code> 比 <code>pthread_mutex</code> 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。</p></li></ul><h4 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h4><ul><li><p><code>NSCondition</code> 的底层是通过条件变量(condition variable) <code>pthread_cond_t</code> 来实现的。</p></li><li><p><strong>条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程**</strong>，并等待某个数据就绪，随后唤醒线程**，比如常见的生产者-消费者模式。</p></li><li><p><code>NSCondition</code> 其实是封装了一个互斥锁和条件变量， 它把前者的 <code>lock</code> 方法和后者的 <code>wait/signal</code> 统一在 <code>NSCondition</code> 对象中，暴露给使用者</p></li><li><p>它的加解锁过程与 <code>NSLock</code> 几乎一致，理论上来说耗时也应该一样(实际测试也是如此)。在图中显示它耗时略长，我猜测有可能是测试者在每次加解锁的前后还附带了变量的初始化和销毁操作。</p></li></ul><h4 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a><a href="https://bestswifter.com/ios-lock/#nsrecursivelock" target="_blank" rel="noopener">NSRecursiveLock</a></h4><ul><li><p>递归锁也是通过 <code>pthread_mutex_lock</code> 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器加一，锁的释放过程也是同理。</p><p><strong>使用递归锁NSRecursiveLock</strong></p><pre class=" language-objc"><code class="language-objc">    NSLock *lock = [[NSLock alloc] init];    dispatch_async(dispatch_get_global_queue(0, 0), ^{        static void (^RecursiveMethod)(int);        RecursiveMethod = ^(int value) {            [lock lock];//递归调用时失败，NSLock不能被同一线程多次获取，多次获取使用NSRecursiveLock            if (value > 0) {                NSLog(@"value = %d", value);                sleep(2);                RecursiveMethod(value - 1);            }            [lock unlock];        };        RecursiveMethod(5);    });</code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4></li></ul><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">@synchronized</a></h4><p>这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。</p><ol><li>你调用 <code>sychronized</code> 的每个对象，runtime 都会为其分配一个递归锁并存储在哈希表中。</li><li>如果在 <code>sychronized</code> 内部对象被释放或被设为 <code>nil</code> 看起来都 OK。不过这没在文档中说明，所以我不会再生产代码中依赖这条。</li><li>注意不要向你的 <code>sychronized</code> block 传入 <code>nil</code>！这将会从代码中移走线程安全。你可以通过在 <code>objc_sync_nil</code> 上加断点来查看是否发生了这样的事情。</li></ol><h2 id="1、你理解的多线程？并发和串行，同步和异步"><a href="#1、你理解的多线程？并发和串行，同步和异步" class="headerlink" title="1、你理解的多线程？并发和串行，同步和异步"></a>1、<strong>你理解的多线程？并发和串行，同步和异步</strong></h2><ul><li>同步和异步的区别: <strong>是否开辟新的线程</strong>，同步只能在当前线程执行任务，异步可以再新的线程执行任务</li><li>串行和并发的区别:是<strong>任务执行的顺序</strong>，串行任务只能顺序执行，并发可以多个任务同时执行。</li></ul><h2 id="2、iOS多线程有哪些？常用哪个？"><a href="#2、iOS多线程有哪些？常用哪个？" class="headerlink" title="2、iOS多线程有哪些？常用哪个？"></a>2、iOS多线程有哪些？常用哪个？</h2><ul><li>NSThread、GCD/NSOperationQueue</li><li>常用GCD/NSOperation</li></ul><p><img src="https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/20200314043637.png" alt="pthread NSThread GCD NSoperatio"></p><h2 id="3、GCD-的队列类型有哪些？"><a href="#3、GCD-的队列类型有哪些？" class="headerlink" title="3、GCD 的队列类型有哪些？"></a><strong>3、GCD 的队列类型有哪些？</strong></h2><p>GCD的队列可以分为2大类型</p><ul><li>并发队列（Concurrent Dispatch Queue）<ul><li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</li><li>并发功能只有在异步（dispatch_async）函数下才有效</li></ul></li><li>串行队列（Serial Dispatch Queue）<ul><li>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</li></ul></li></ul><h2 id="4、OperationQueue-和-GCD-的区别？"><a href="#4、OperationQueue-和-GCD-的区别？" class="headerlink" title="4、OperationQueue 和 GCD 的区别？"></a><strong>4、OperationQueue 和 GCD 的区别？</strong></h2><ol><li>GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择；</li><li>在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)；</li><li>NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行；</li><li>我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样子能比GCD更加有效地掌控我们执行的后台任务；</li><li>在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码；</li><li>我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。</li></ol><p><strong>总的来说，Operation queue 提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。</strong></p><p><strong>从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。</strong></p><h2 id="5、线程安全是什么？如何处理线程安全的问题？"><a href="#5、线程安全是什么？如何处理线程安全的问题？" class="headerlink" title="5、线程安全是什么？如何处理线程安全的问题？"></a><strong>5、线程安全是什么？如何处理线程安全的问题？</strong></h2><blockquote><p>我们一般通过线程同步方案如加锁的方式来实现线程的安全</p><p><a href="https://bestswifter.com/ios-lock/" target="_blank" rel="noopener">iOS锁的原理</a> |   <a href="https://www.jianshu.com/p/e56c3d28e77d" target="_blank" rel="noopener">深入浅出iOS系统内核-同步机制</a></p></blockquote><ul><li><strong>os_unfair_lock：iOS10开始os_unfair_lock来替代OSSpinLock, 等待锁的线程会进入休眠不占用CPU资源， 这个os_unfair_lock解决了优先级翻转问题。</strong></li><li><strong>OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等一直占用着CPU资源</strong></li><li><strong>dispatch_semaphore：信号量为1的semaphore也可以看做是锁</strong></li><li><strong>pthread_mutex：跨平台的互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。</strong></li><li><strong>使用GCD的串行队列也可以实现锁的功能</strong></li><li><strong>NSLock是对metex互斥锁的封装，NSRecurisiveLock也是对metex的递归封装，API和NSLock一直。</strong></li><li>NSCondition</li><li>NSConditionLock</li><li><strong>@synchorized也是mutex的递归封装，@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作。</strong></li></ul><h2 id="6、自旋锁和互斥锁如何选择？"><a href="#6、自旋锁和互斥锁如何选择？" class="headerlink" title="6、自旋锁和互斥锁如何选择？"></a><strong>6、自旋锁和互斥锁如何选择？</strong></h2><p><strong>自旋锁OSSpinLock：当线程获取锁，其他等待锁的线程会忙等一直占用CPU,自旋锁有优先级翻转的可能性，所以苹果已经弃用自旋锁OSSpinLock改用os_unfair_lock.</strong></p><p><strong>互斥锁mutext：阻塞线程并休眠，其他线程才能正常访问，用互斥的方式来保证线程的安全。</strong></p><p><strong>递归锁：顾名思义，可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。</strong></p><ul><li><strong>什么情况使用自旋锁比较划算？</strong> <ul><li>预计线程等待锁的<strong>时间很短</strong> </li><li><strong>竞争情况很少</strong>发生，加锁的代码（临界区）经常被调用</li><li><strong>CPU资源不紧张</strong> 多核处理器</li></ul></li><li><strong>什么情况使用互斥锁比较划算？</strong> <ul><li>预计线程等待锁的<strong>时间较长</strong> </li><li>临界区<strong>代码复杂或者循环量大</strong> </li><li><strong>临界区竞争非常激烈</strong> </li><li>单核处理器 临界区有IO操作 </li></ul></li></ul><ul><li><strong>追问二：使用以上锁需要注意哪些？</strong> </li><li><strong>追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！</strong></li></ul><h2 id="7、iOS线程同步方案性能比较"><a href="#7、iOS线程同步方案性能比较" class="headerlink" title="7、iOS线程同步方案性能比较"></a>7、iOS线程同步方案<strong>性能</strong>比较</h2><p><strong>性能从高到低排序:</strong></p><pre><code>os_unfair_lock &gt; OSSpinLock &gt; dispatch_semaphore &gt; pthread_mutex &gt; dispatch_queue(DISPATCH_QUEUE_SERIAL) &gt; NSLock &gt; NSCondition &gt; pthread_mutex(recursive) &gt; NSRecursiveLock &gt; NSConditionLock &gt; @synchronized</code></pre><h2 id="8、如何用gcd实现并发执行1和2再执行任务3的方案？"><a href="#8、如何用gcd实现并发执行1和2再执行任务3的方案？" class="headerlink" title="**8、如何用gcd实现并发执行1和2再执行任务3的方案？"></a>**8、如何用gcd实现并发执行1和2再执行任务3的方案？</h2><ul><li><strong>异步并发执行任务1、任务2</strong> </li><li><strong>等任务1、任务2都执行完毕后，再回到主线程执行任务3</strong></li></ul><h4 id="dispatch-group-notify"><a href="#dispatch-group-notify" class="headerlink" title="dispatch_group_notify"></a>dispatch_group_notify</h4><h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><h4 id="dispatch-sempher-2"><a href="#dispatch-sempher-2" class="headerlink" title="dispatch_sempher(2)"></a>dispatch_sempher(2)</h4><pre class=" language-swift"><code class="language-swift">    <span class="token keyword">let</span> group <span class="token operator">=</span> <span class="token function">DispatchGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>label<span class="token punctuation">:</span> <span class="token string">"handleAPIQueue"</span><span class="token punctuation">)</span>    group<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    queue<span class="token punctuation">.</span>async <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"任务1完成"</span><span class="token punctuation">)</span>        group<span class="token punctuation">.</span><span class="token function">leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    group<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    queue<span class="token punctuation">.</span>async <span class="token punctuation">{</span>        <span class="token builtin">DispatchQueue</span><span class="token punctuation">.</span>main<span class="token punctuation">.</span><span class="token function">asyncAfter</span><span class="token punctuation">(</span>deadline<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"任务2完成"</span><span class="token punctuation">)</span>            group<span class="token punctuation">.</span><span class="token function">leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//注意leave的位置必须在任务完成后</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//group.leave() //如果leave放在这里的话，notify不会等待任务2完成就会触发</span>    group<span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    queue<span class="token punctuation">.</span>async <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"任务3完成"</span><span class="token punctuation">)</span>        group<span class="token punctuation">.</span><span class="token function">leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    group<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span>queue<span class="token punctuation">:</span> queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"所有任务都完成了"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><p><a href="https://blog.csdn.net/die_word/article/details/80797329" target="_blank" rel="noopener">网络请求应用实例</a></p><h2 id="9、如何实现多度单写？"><a href="#9、如何实现多度单写？" class="headerlink" title="9、如何实现多度单写？"></a><code>9、如何实现多度单写？</code></h2><p><strong>dispatch_barrier_async</strong></p><ul><li>这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的 </li><li>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果</li></ul><pre class=" language-swift"><code class="language-swift">  dispatch_queue_t concurrentQueue <span class="token operator">=</span> <span class="token function">dispatch_queue_create</span><span class="token punctuation">(</span><span class="token string">"com.queue.concurrent"</span><span class="token punctuation">,</span> <span class="token constant">DISPATCH_QUEUE_CONCURRENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">dispatch_async</span><span class="token punctuation">(</span>concurrentQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>      <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"async_1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">dispatch_async</span><span class="token punctuation">(</span>concurrentQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>      <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"async_2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">dispatch_async</span><span class="token punctuation">(</span>concurrentQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>         <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"async_3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">dispatch_barrier_async</span><span class="token punctuation">(</span>concurrentQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//dispatch_barrier_sync效果相同</span>      <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"dispatch_barrier_async"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">dispatch_async</span><span class="token punctuation">(</span>concurrentQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>      <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"async_4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*01-OC底层[25009:1007376] async_101-OC底层[25009:1007372] async_301-OC底层[25009:1007374] async_201-OC底层[25009:1007372] dispatch_barrier_async01-OC底层[25009:1007372] async_4*/</span></code></pre><h2 id="10、GCD实现暂停和继续注意什么？"><a href="#10、GCD实现暂停和继续注意什么？" class="headerlink" title="10、GCD实现暂停和继续注意什么？"></a>10、GCD实现暂停和继续注意什么？</h2><pre class=" language-swift"><code class="language-swift">        dispatch_queue_t conQueue <span class="token operator">=</span> <span class="token function">dispatch_queue_create</span><span class="token punctuation">(</span><span class="token string">"com.seria.queue"</span><span class="token punctuation">,</span> <span class="token constant">DISPATCH_QUEUE_CONCURRENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    size_t <span class="token builtin">count</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">dispatch_apply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> conQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">(</span>size_t index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"numer is %zu"</span><span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//            dispatch_suspend(concurrentQueue);// suspend并不能停止当前队列的任务，只能停止后面队列中的任务</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatch_suspend</span><span class="token punctuation">(</span>conQueue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// dispatch_suspend 不能单独使用，和dispatch_resume配对使用</span>    <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"task1---"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatch_async</span><span class="token punctuation">(</span>conQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>        <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"async1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"task2---"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatch_resume</span><span class="token punctuation">(</span>conQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dispatch_async</span><span class="token punctuation">(</span>conQueue<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>        <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"async2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"task3---"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="11、案例分析"><a href="#11、案例分析" class="headerlink" title="11、案例分析"></a>11、案例分析</h2><h4 id="使用-Dispatch-Source定时器"><a href="#使用-Dispatch-Source定时器" class="headerlink" title="使用 Dispatch Source定时器"></a>使用 Dispatch Source定时器</h4><h4 id="Dispatch-Source-Timer"><a href="#Dispatch-Source-Timer" class="headerlink" title="Dispatch Source Timer"></a>Dispatch Source Timer</h4><p>利用 Dispatch Source 的 DISPATCH_SOURCE_TYPE_TIMER 类型，我们可以创建一个 跨线程的 定时器（我们平时使用的 NSTimer 是基于 Run Loop 的 timer 事件，只能在对应的线程里触发）</p><pre class=" language-objective-c"><code class="language-objective-c">    dispatch_queue_t queue = dispatch_get_main_queue();    //1、创建一个 timer；    self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);    //2、配置 timer，从现在起，每两秒在主线程触发一次，精度为0s    dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);    //3、timer 触发之后的回调 block    dispatch_source_set_event_handler(self.timer, ^{        NSLog(@"%ld", self.count++);    });    //4、启动 timer    dispatch_resume(self.time); </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树前世今生</title>
      <link href="/2019/12/30/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2019/12/30/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树前世今生"><a href="#红黑树前世今生" class="headerlink" title="红黑树前世今生"></a>红黑树前世今生</h1><p>关键词：二叉搜索树、前驱节点、后继节点、B树、红黑树</p><h2 id="什么是B树"><a href="#什么是B树" class="headerlink" title="什么是B树"></a>什么是B树</h2><h3 id="前世"><a href="#前世" class="headerlink" title="前世"></a>前世</h3><p>B树是一种相对于来说特殊二叉搜索树，多用于数据库和文件搜索系统中。</p><h3 id="n阶B树的性质"><a href="#n阶B树的性质" class="headerlink" title="n阶B树的性质"></a>n阶B树的性质</h3><blockquote><p>B树是一种平衡的多路搜索树，拥有平衡二叉树的一些特性，与平衡二叉树的最大区别在于每个节点不再是只能存储一个元素，而且每个节点可以拥有多个子节点而像二叉平衡树只能拥有两个。</p></blockquote><ol><li>B树每个节点最多可以存储超过2个元素，可以拥有超过2个子节点</li><li>B树每个子节点的子树高度一致</li><li>B树和二叉搜索树一样，左子树&lt;根节点&lt;右子树</li><li>根节点元素个数:   1≤ X ≤ n - 1</li><li>非根节点元素个数:  n/2 - 1 ≤ x ≤ n - 1 (n/2 向上取整)</li><li>如果有子节点，子节点个数 y = x + 1,</li><li>根节点 2 ≤ y ≤ n<br><strong>非根节点 n / 2 ≤ y ≤ n</strong> (n/2 向上取整)</li></ol><blockquote><p>数据库中一般使用的是200-300阶B树</p><p>4阶B树元素个数为(2-3-4)，所以4阶B树也叫2-4树或者2-3-4树</p><p>5阶B树元素个数为 3-4-5 所以5阶B树叫（3，5）树</p><p>6阶B树元素个数3-4-5-6，所以6阶B树叫（3，6）树</p><p>7阶B树元素个数为4-5-6-7，所以7阶B树叫（4，7）树</p></blockquote><h3 id="B树-VS-二叉搜索树"><a href="#B树-VS-二叉搜索树" class="headerlink" title="B树 VS 二叉搜索树"></a>B树 VS 二叉搜索树</h3><ol><li>B树与二叉搜索树逻辑上等价</li><li>n阶B树最多需要log2 N代合并</li><li>多代节点合并可以获得超节点<ul><li>2代合并最多拥有4个子节点</li><li>3代合并最多拥有8个子节点</li><li>n代合并最多拥有2^n个子节点（至少是2^n阶B树）</li></ul></li></ol><h3 id="B树的添加与上溢"><a href="#B树的添加与上溢" class="headerlink" title="B树的添加与上溢"></a>B树的添加与上溢</h3><p><strong>上溢出（overflow）:添加元素到子节点后，该节点元素个数大于N时，我们称之为上溢出</strong></p><p>B树的元素添加的位置一定是叶子节点</p><p>B树添加导致上溢</p><p>B树上溢最极端的情况是一直分裂到根节点</p><h3 id="B树的删除与下溢"><a href="#B树的删除与下溢" class="headerlink" title="B树的删除与下溢"></a>B树的删除与下溢</h3><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li><p>删除叶子节点的话直接删除</p><p><img src="B%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.assets/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-15%20%E4%B8%8A%E5%8D%889.49.17.png" alt="屏幕快照 2019-12-15 上午9.49.17"></p></li><li><p>删除的非叶子节点的话：1、先找到前驱或后继节点元素，覆盖需要删除的值，2、把前驱或后继元素删除（说明：一个树的前驱在左子树的最后边，后驱在右子树的最左边。）</p></li></ul><p><img src="B%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.assets/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-15%20%E4%B8%8A%E5%8D%889.48.06.png" alt="屏幕快照 2019-12-15 上午9.48.06"></p><ul><li>非叶子节点前驱或后继元素，必然是在叶子节点中，所以真正删除的元素都是叶子节点</li></ul><p><img src="B%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.assets/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-15%20%E4%B8%8A%E5%8D%889.50.50.png" alt="屏幕快照 2019-12-15 上午9.50.50"></p><p><strong>下溢出（underflow）：叶子节点被删除一个元素后，元素个数可能会低于最低限制 （n/2 - 1 向上取整）</strong></p><p><strong>下溢出的解决方案是旋转</strong>，总体元素是哪个方向失衡往哪个方向转，子树大小顺序不能乱</p><h2 id="4阶B树"><a href="#4阶B树" class="headerlink" title="4阶B树"></a>4阶B树</h2><ul><li>4阶B树所有节点都能储存的元素个数x: 1 ≤ x ≤ 3</li><li>4阶B树非叶子节点的子节点个数：2 ≤ y ≤ 4</li></ul><h2 id="为什么需要红黑树"><a href="#为什么需要红黑树" class="headerlink" title="为什么需要红黑树?"></a>为什么需要红黑树?</h2><p>红黑树是在二叉搜索树的基础上对AVL树的改进，二叉搜索树顾名思义是对搜索算法的一种优化，能够大大减少我们元素对比的次数。红黑树在Java中的应用如HashSet(底层是数组单链表和红黑树)、数据库搜索也有应用。</p><h2 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h2><p><strong>红黑树是一种自平衡的二叉搜索树也叫平衡二叉B树</strong></p><h3 id="红黑树5个性质"><a href="#红黑树5个性质" class="headerlink" title="红黑树5个性质"></a>红黑树5个性质</h3><ol><li>节点分为红色与黑色</li><li>根节点是黑色</li><li>叶子节点是黑色</li><li><strong>不能有两个连续的红色节点</strong></li><li>从任意节点到叶子节点上所有路径的<strong>黑色节点数目必须相等</strong></li></ol><h3 id="红黑树等价变换"><a href="#红黑树等价变换" class="headerlink" title="红黑树等价变换"></a>红黑树等价变换</h3><p>红黑树等价于4阶B树</p><h3 id="红黑树添加失衡如何解决？"><a href="#红黑树添加失衡如何解决？" class="headerlink" title="红黑树添加失衡如何解决？"></a>红黑树添加失衡如何解决？</h3><h4 id="添加失衡"><a href="#添加失衡" class="headerlink" title="添加失衡"></a>添加失衡</h4><ul><li>Parrent节点为黑色时不需要处理</li><li>Parrent节点为红色（Double Red）</li><li>Uncle节点不是red:  <strong>LL/RR    LR/RL</strong></li><li>Uncle节点是red:  </li></ul><h3 id="红黑树删除节点失衡如何解决？"><a href="#红黑树删除节点失衡如何解决？" class="headerlink" title="红黑树删除节点失衡如何解决？"></a>红黑树删除节点失衡如何解决？</h3><h2 id="红黑树-VS-AVL树"><a href="#红黑树-VS-AVL树" class="headerlink" title="红黑树 VS AVL树"></a>红黑树 VS AVL树</h2><h3 id="搜索性能"><a href="#搜索性能" class="headerlink" title="搜索性能"></a>搜索性能</h3><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>Java8中的hashMap是使用数组+链表实现的，在解决哈希碰撞时使用了红黑树。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树前世今生</title>
      <link href="/2019/12/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2019/12/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树今生"><a href="#二叉树今生" class="headerlink" title="二叉树今生"></a>二叉树今生</h1><p>为什么会有二叉树这种数据结构？</p><p>思考一个问题：如果一个集合中有42亿个元素，让你从这42亿个元素中搜索某一个元素，你需要多少次操作？</p><p><strong>如果使用数组链表的话最多可能需要42亿次比较，而如果使用二叉树我们只需要32次比较即可，这就是二叉树存在的价值。Java中的HashSet使用的就是二叉树</strong></p><h2 id="前驱与后继"><a href="#前驱与后继" class="headerlink" title="前驱与后继"></a>前驱与后继</h2><h3 id="前驱节点"><a href="#前驱节点" class="headerlink" title="前驱节点"></a>前驱节点</h3><ol><li><p>若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode）</p></li><li><p>若一个节点没有左子树，那么判断该节点和其父节点的关系 </p><p>2.1 若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。 </p><p>2.2 若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点</p></li></ol><h3 id="后继节点"><a href="#后继节点" class="headerlink" title="后继节点"></a>后继节点</h3><ol><li>若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode）</li><li>若一个节点没有右子树，那么判断该节点和其父节点的关系<br>2.1 若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点<br>2.2 若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点</li></ol><p>如何判断两个二叉树是否相同？</p><p><strong>递归法</strong></p><pre class=" language-Java"><code class="language-Java">static public bool IsSameTree(TreeNode root1, TreeNode root2) {    if (root1 == null && root2 == null) {        return true;    }    if ((root1 == null && root2 != null) || (root1 != null && root2 == null)) {        return false;    }    if (root1.val != root2.val) {//判断每个节点的值是否相等，如果去除此判断，则判断两个二叉树是否结构相等        return false;    }    return IsSameTree(root1.left, root2.left) && IsSameTree(root1.right, root2.right);}</code></pre><p><strong>非递归法</strong></p><pre class=" language-Java"><code class="language-Java">bool  BTreeCompare（BTreeNode_t *pRoot1, BTreeNode_t *pRoot2)  {      if( pRoot1 == NULL && pRoot2 == NULL )          return false;      queue <BTreeNode_t *> que1;      queue <BTreeNode_t *> que2;      que1.push(pRoot1);      que2.push(pRoot2);      int curLevelNodeTotal1 = 0;      int curLevelNodeTotal2 = 0;      bool flag = true; //作为比较不一致时跳出标识      while( ( !que1.empty()) && ( !que2.empty())) //当两个队列均不为空时，才进行比较      {          curLevelNodeTotal1 = que1.size();  //获取树1的当前层节点总数          curLevelNodeTotal2 = que2.size(); //获取树2的当前层节点总数          if( curLevelNodeTotal1 != curLevelNodeTotal2){              flag = false;//当前层节点总数都不一致，不需要比较了，直接跳出              break;          }          int cnt1 = 0;//遍历本层节点时的计数器          int cnt2 = 0;          while( cnt1 < curLevelNodeTotal1  && cnt2 < curLevelNodeTotal2){              ++cnt1;              ++cnt2;              pRoot1 = que1.front();              que1.pop();              pRoot2 = que2.front();              que2.pop();              //比较当前节点中数据是否一致              if( pRoot1->m_pElemt != pRoot2->m_pElemt ){                  flag = false;                  break;              }              //判断pRoot1和pRoot2左右节点结构是否相同              if( ( pRoot1->m_pLeft != NULL && pRoot2->m_pLeft == NULL )    ||                  ( pRoot1->m_pLeft == NULL && pRoot2->m_pLeft != NULL )    ||                  ( pRoot1->m_pRight != NULL && pRoot2->m_pRight == NULL )    ||                  ( pRoot1->m_pRight == NULL && pRoot2->m_pRight != NULL )              ){                  flag = false;                  break;              }              //将左右节点入队              if( pRoot1->m_pLeft != NULL )                  que1.push( pRoot1->m_pLeft);              if( pRoot1->m_pRight != NULL )                  que1.push( pRoot1->m_pRight);              if( pRoot2->m_pLeft != NULL )                  que2.push( pRoot2->m_pLeft);              if( pRoot2->m_pRight != NULL )                  que2.push( pRoot2->m_pRight);          }          if( flag == false )              break;      }      //如果比较标志为false，则不相同      if( flag == false ){          while( !que1.empty() )              que1.pop();          while( !que2.empty())              que2.pop();          return false;      }      return true;  }</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS图像处理</title>
      <link href="/2019/12/30/iOS%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2019/12/30/iOS%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS图像优化技巧"><a href="#iOS图像优化技巧" class="headerlink" title="iOS图像优化技巧"></a><a href="https://swift.gg/2019/11/01/image-resizing/" target="_blank" rel="noopener">iOS图像优化技巧</a></h1><ul><li><p>1、如何处理大尺寸图片？</p></li><li><p>2、如何处理瀑布流图片占用大量内存的问题？</p></li><li><p>3、如何处理多张图片上传和下载问题？</p></li></ul><h1 id="1、处理大尺寸图片"><a href="#1、处理大尺寸图片" class="headerlink" title="1、处理大尺寸图片"></a>1、处理大尺寸图片</h1><p>那么，什么时候对图像进行渲染优化才有意义呢？</p><p><strong>当它明显大于</strong> <strong><code>UIImageView</code></strong> <strong>显示尺寸的时候</strong></p><p>想要完整渲染这张宽高为 12,000 px 的图片，需要高达 20 MB 的空间。对于当今的硬件来说，你可能不会在意这么少兆字节的占用。但那只是它压缩后的尺寸。要展示它，<code>UIImageView</code> 首先需要把 JPEG 数据解码成位图（bitmap），如果要在一个 <code>UIImageView</code> 上按原样设置这张全尺寸图片，你的应用内存占用将会激增到<strong>几百兆</strong>，对用户明显没有什么好处（毕竟，屏幕能显示的像素有限）。但只要在设置 <code>UIImageView</code> 的 <code>image</code> 属性之前，将图像渲染的尺寸调整成 <code>UIImageView</code> 的大小，你用到的内存就会少一个数量级：</p><table><thead><tr><th align="left"></th><th align="left">内存消耗 <em>(MB)</em></th></tr></thead><tbody><tr><td align="left">无下采样</td><td align="left">220.2</td></tr><tr><td align="left">下采样</td><td align="left">23.7</td></tr></tbody></table><p>这个技巧就是众所周知的<em>下采样（downsampling）</em>，在这些情况下，它可以有效地优化你应用的性能表现。如果你想了解更多关于下采样的知识或者其它图形图像的最佳实践，请参照 <a href="https://developer.apple.com/videos/play/wwdc2018/219/" target="_blank" rel="noopener">来自 WWDC 2018 的精彩课程</a>。</p><p>而现在，很少有应用程序会尝试一次性加载这么大的图像了，但是也跟我从设计师那里拿到的图片资源不会差<em>太</em>多。<em>（认真的吗？一张颜色渐变的</em> <em>PNG</em> <em>图片要</em> <em>3</em> <em>MB?）</em> 考虑到这一点，让我们来看看有什么不同的方法，可以让你用来对图像进行优化或者下采样。</p><blockquote><p>不用说，这里所有从 URL 加载的示例图像都是针对<strong>本地</strong>文件。记住，在应用的主线程同步使用网络请求图像<strong>绝不</strong>是什么好主意。</p></blockquote><h2 id="图像渲染优化技巧"><a href="#图像渲染优化技巧" class="headerlink" title="图像渲染优化技巧"></a>图像渲染优化技巧</h2><p>优化图像渲染的方法有很多种，每种都有不同的功能和性能特性。我们在本文看到的这些例子，架构层次跨度上从底层的 Core Graphics、vImage、Image I/O 到上层的 Core Image 和 UIKit 都有。</p><ol><li><a href="https://swift.gg/2019/11/01/image-resizing/#technique-1-drawing-to-a-uigraphicsimagerenderer" target="_blank" rel="noopener">绘制到 UIGraphicsImageRenderer 上</a></li><li><a href="https://swift.gg/2019/11/01/image-resizing/#technique-2-drawing-to-a-core-graphics-context" target="_blank" rel="noopener">绘制到 Core Graphics Context 上</a></li><li><a href="https://swift.gg/2019/11/01/image-resizing/#technique-3-creating-a-thumbnail-with-image-io" target="_blank" rel="noopener">使用 Image I/O 创建缩略图像</a></li><li><a href="https://swift.gg/2019/11/01/image-resizing/#technique-4-lanczos-resampling-with-core-image" target="_blank" rel="noopener">使用 Core Image 进行 Lanczos 重采样</a></li><li><a href="https://swift.gg/2019/11/01/image-resizing/#technique-5-image-scaling-with-vimage" target="_blank" rel="noopener">使用 vImage 优化图片渲染</a></li></ol><p>下面的这些数字是多次迭代加载、优化、渲染之前那张 <a href="https://visibleearth.nasa.gov/view.php?id=78314" target="_blank" rel="noopener">超大地球图片</a> 的平均时间：</p><table><thead><tr><th align="left"></th><th align="left">耗时 <em>(seconds)</em></th></tr></thead><tbody><tr><td align="left">技巧 #1: <code>UIKit</code></td><td align="left">0.1420</td></tr><tr><td align="left">技巧 #2: <code>Core Graphics</code> 1</td><td align="left">0.1722</td></tr><tr><td align="left">技巧 #3: <code>Image I/O</code></td><td align="left">0.1616</td></tr><tr><td align="left">技巧 #4: <code>Core Image</code> 2</td><td align="left">2.4983</td></tr><tr><td align="left">技巧 #5: <code>vImage</code></td><td align="left">2.3126</td></tr></tbody></table><p>1<br>设置不同的 <code>CGInterpolationQuality</code> 值出来的结果是一致的，在性能上的差异可以忽略不计。</p><p>2<br>若在 <code>CIContext</code> 创建时设置 <code>kCIContextUseSoftwareRenderer</code> 的值为 <code>true</code>，会导致耗时相比基础结果慢一个数量级。</p><h2 id="使用CGContextDrawImage"><a href="#使用CGContextDrawImage" class="headerlink" title="使用CGContextDrawImage()"></a>使用CGContextDrawImage()</h2><h2 id="异步解码图片"><a href="#异步解码图片" class="headerlink" title="异步解码图片"></a>异步解码图片</h2><pre class=" language-objc"><code class="language-objc">    dispatch_async(dispatch_get_global_queue(0, 0), ^{        // 1、获取CGImage        CGImageRef cgImage = [UIImage imageNamed:@"img"].CGImage;        // alphaInfo        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage) & kCGBitmapAlphaInfoMask;        BOOL hasAlpha = NO;        if (alphaInfo == kCGImageAlphaPremultipliedLast ||            alphaInfo == kCGImageAlphaPremultipliedFirst ||            alphaInfo == kCGImageAlphaLast ||            alphaInfo == kCGImageAlphaFirst) {            hasAlpha = YES;        }        // bitmapInfo        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;        // size        size_t width = CGImageGetWidth(cgImage);        size_t height = CGImageGetHeight(cgImage);        // 2、获取context        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo);        //3、 draw        CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage);        // get CGImage        cgImage = CGBitmapContextCreateImage(context);        // into UIImage        UIImage *newImage = [UIImage imageWithCGImage:cgImage];        // release        CGContextRelease(context);        CGImageRelease(cgImage);        // back to the main thread        dispatch_async(dispatch_get_main_queue(), ^{            self.imageView.image = newImage;        });    });</code></pre><h3 id="技巧-1-绘制到-UIGraphicsImageRenderer-上"><a href="#技巧-1-绘制到-UIGraphicsImageRenderer-上" class="headerlink" title="技巧 #1: 绘制到 UIGraphicsImageRenderer 上"></a>技巧 #1: 绘制到 UIGraphicsImageRenderer 上</h3><p>图像渲染优化的最上层 API 位于 UIKit 框架中。给定一个 <code>UIImage</code>，你可以绘制到 <code>UIGraphicsImageRenderer</code> 的上下文（context）中以渲染缩小版本的图像：</p><pre><code>import UIKit// 技巧 #1func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? {    guard let image = UIImage(contentsOfFile: url.path) else {        return nil    }    let renderer = UIGraphicsImageRenderer(size: size)    return renderer.image { (context) in        image.draw(in: CGRect(origin: .zero, size: size))    }}</code></pre><p><a href="https://developer.apple.com/documentation/uikit/uigraphicsimagerenderer" target="_blank" rel="noopener"><code>UIGraphicsImageRenderer</code></a> 是一项相对较新的技术，在 iOS 10 中被引入，用以取代旧版本的 <code>UIGraphicsBeginImageContextWithOptions</code> / <code>UIGraphicsEndImageContext</code> API。你通过指定以 <code>point</code> 计量的 <code>size</code> 创建了一个 <code>UIGraphicsImageRenderer</code>。<strong><code>image</code> 方法带有一个闭包参数，返回的是一个经过闭包处理后的位图。最终，原始图像便会在缩小到指定的范围内绘制。</strong></p><h3 id="技巧-2：绘制到-Core-Graphics-Context-中"><a href="#技巧-2：绘制到-Core-Graphics-Context-中" class="headerlink" title="技巧 #2：绘制到 Core Graphics Context 中"></a>技巧 #2：绘制到 Core Graphics Context 中</h3><p>Core Graphics / Quartz 2D 提供了一系列底层 API 让我们可以进行更多高级的配置。</p><p>给定一个 <code>CGImage</code> 作为暂时的位图上下文，使用 <code>draw(_:in:)</code> 方法来绘制缩放后的图像：</p><pre><code>import UIKitimport CoreGraphics// 技巧 #2func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? {    guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),        let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil)    else {        return nil    }    let context = CGContext(data: nil,                            width: Int(size.width),                            height: Int(size.height),                            bitsPerComponent: image.bitsPerComponent,                            bytesPerRow: image.bytesPerRow,                            space: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!,                            bitmapInfo: image.bitmapInfo.rawValue)    context?.interpolationQuality = .high    context?.draw(image, in: CGRect(origin: .zero, size: size))    guard let scaledImage = context?.makeImage() else { return nil }    return UIImage(cgImage: scaledImage)}</code></pre><p>这个 <code>CGContext</code> 初始化方法接收了几个参数来构造一个上下文，包括了必要的宽高参数，还有在给出的色域范围内每个颜色通道所需要的内存大小。在这个例子中，这些参数都是通过 <code>CGImage</code> 这个对象获取的。下一步，设置 <code>interpolationQuality</code> 属性为 <code>.high</code> 指示上下文在保证一定的精度上填充像素。<code>draw(_:in:)</code> 方法则是在给定的宽高和位置绘制图像，可以让图片在特定的边距下裁剪，也可以适用于一些像是人脸识别之类的图像特性。最后 <code>makeImage()</code> 从上下文获取信息并且渲染到一个 <code>CGImage</code> 值上（之后会用来构造 <code>UIImage</code> 对象）。</p><h3 id="技巧-3：使用-Image-I-O-创建缩略图像"><a href="#技巧-3：使用-Image-I-O-创建缩略图像" class="headerlink" title="技巧 #3：使用 Image I/O 创建缩略图像"></a>技巧 #3：使用 Image I/O 创建缩略图像</h3><p>处理大分辨率图片时，往往容易出现OOM，<strong>原因是-[UIImage drawInRect:]在绘制时，先解码图片，再生成原始分辨率大小的bitmap，这是很耗内存的。</strong></p><p>解决方法是使用更低层的ImageIO接口，避免中间bitmap产生：</p><p>Image I/O 是一个强大（却鲜有人知）的图像处理框架。</p><p><strong>它可以读写许多不同图像格式，访问图像的元数据，还有执行常规的图像处理操作。这个框架通过先进的缓存机制，提供了平台上最快的图片编码器和解码器，甚至可以增量加载图片。</strong></p><p>这个重要的 <code>CGImageSourceCreateThumbnailAtIndex</code> 提供了一个带有许多不同配置选项的 API，比起在 Core Graphics 中等价的处理操作要简洁得多：</p><pre><code>import ImageIO// 技巧 #3func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? {    let options: [CFString: Any] = [        kCGImageSourceCreateThumbnailFromImageIfAbsent: true,        kCGImageSourceCreateThumbnailWithTransform: true,        kCGImageSourceShouldCacheImmediately: true,        kCGImageSourceThumbnailMaxPixelSize: max(size.width, size.height)    ]    guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),        let image = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, options as CFDictionary)    else {        return nil    }    return UIImage(cgImage: image)}</code></pre><p>给定一个 <code>CGImageSource</code> 和一系列配置选项，<code>CGImageSourceCreateThumbnailAtIndex(_:_:_:)</code> 函数创建了一个图像的缩略图。优化尺寸大小的操作是通过 <code>kCGImageSourceThumbnailMaxPixelSize</code> 完成的，它根据图像原始宽高比指定的最大尺寸来缩放图像。通过设定 <code>kCGImageSourceCreateThumbnailFromImageIfAbsent</code> 或 <code>kCGImageSourceCreateThumbnailFromImageAlways</code> 选项，Image I/O 可以自动缓存优化后的结果以便后续调用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>UIKit</strong>, <strong>Core</strong> <strong>Graphics</strong>, 和 <strong>Image</strong> <strong>I/O</strong> 都能很好地用于大部分图片的优化操作。</li><li>如果（在 iOS 平台，至少）要选择一个的话，<code>UIGraphicsImageRenderer</code> 是你最佳的选择。</li><li><strong>Core</strong> <strong>Image</strong> 在图像优化渲染操作方面性能表现优越。实际上，根据 Apple 官方 <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/Conceptual/CoreImaging/ci_performance/ci_performance.html#//apple_ref/doc/uid/TP30001185-CH10-SW1" target="_blank" rel="noopener"><em>Core</em> <em>Image</em> <em>编程规范中的性能最佳实践单元</em></a>，你应该使用 Core Graphics 或 Image I/O 对图像进行裁剪和下采样，而不是用 Core Image。</li><li>除非你已经在使用 <strong><code>vImage</code></strong>，否则在大多数情况下用到底层的 Accelerate API 所需的额外工作可能是不合理的。</li></ul><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg/" target="_blank" rel="noopener">http://swift.gg</a>。</p></blockquote><h1 id="2、同时处理大量图片"><a href="#2、同时处理大量图片" class="headerlink" title="2、同时处理大量图片"></a>2、同时处理大量图片</h1><h3 id="UIScrollView滚动停止监测"><a href="#UIScrollView滚动停止监测" class="headerlink" title="UIScrollView滚动停止监测"></a><a href="https://www.codeleading.com/article/6664657606/" target="_blank" rel="noopener">UIScrollView滚动停止监测</a></h3><p>通过调查发现 <code>UIScrollView</code> 停止滚动的类型分为三种：</p><ol><li>快速滚动，自然停止</li><li>快速滚动，手指按压突然停止</li><li>慢速上下滑动停止</li></ol><p>第1种类型，比较简单，在 <code>UIScrollView</code> 的代理中就可以监听到。</p><pre class=" language-objc"><code class="language-objc">- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;</code></pre><p>而第2种类型和第3种类型，就没有方法让我们可以直接监听到了。但是只要是滑动了，就一定会触发 <code>UIScrollView</code> 的下面代理，然后通过 <code>UIScrollView</code> 部分属性的改变，我们就可以监听到滚动停止了，后面会详细介绍方法。</p><pre class=" language-objc"><code class="language-objc">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;</code></pre><h3 id="监听UIScrollView停止滚动"><a href="#监听UIScrollView停止滚动" class="headerlink" title="监听UIScrollView停止滚动"></a>监听UIScrollView停止滚动</h3><p>通过翻阅文档，我们可以看到 <code>UIScrollView</code> 有三个属性: <strong>tracking、dragging、decelerating。</strong></p><pre class=" language-objc"><code class="language-objc">// returns YES if user has touched. may not yet have started dragging@property(nonatomic,readonly,getter=isTracking) BOOL tracking;// returns YES if user has started scrolling. this may require some time and or distance to move to initiate dragging@property(nonatomic,readonly,getter=isDragging) BOOL dragging;// returns YES if user isn't dragging (touch up) but scroll view is still moving@property(nonatomic,readonly,getter=isDecelerating) BOOL decelerating;</code></pre><p>在滚动和滚动结束时，这三个属性的值都不相同。我们利用这三个属性，完成对 <code>UIScrollView</code> 停止滚动的监听。</p><p><strong>停止类型1：scrollViewDidEndDecelerating</strong></p><pre class=" language-objc"><code class="language-objc">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;tracking:0,dragging:0,decelerating:0</code></pre><p><strong>停止类型2：scrollViewDidEndDragging &amp; scrollViewDidEndDecelerating</strong></p><pre><code>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;tracking:1,dragging:0,decelerating:1- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;tracking:0,dragging:0,decelerating:0</code></pre><p><strong>停止类型3：scrollViewDidEndDragging</strong></p><pre><code>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;tracking:1,dragging:0,decelerating:0</code></pre><p>通过上面的代码，可以发现，我们只需要对 <code>UIScrollView</code> 的这三个属性进行相应的组合，就可以监听到 <code>UIScrollView</code> 停止滚动的事件了。</p><pre class=" language-objc"><code class="language-objc">- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView {    [self stoppedScrolling];}- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate {    if (!decelerate) {        [self stoppedScrolling];    }}- (void)stoppedScrolling {    // ...      NSLog(@"停止滚动了！！！");}</code></pre><pre class=" language-objc"><code class="language-objc">-(void)scrollViewDidScroll:(UIScrollView *)sender{    [NSObject cancelPreviousPerformRequestsWithTarget:self];    [self performSelector:@selector(scrollViewDidEndScrollingAnimation:) withObject:nil afterDelay:0.1];}-(void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView{    [NSObject cancelPreviousPerformRequestsWithTarget:self];}</code></pre><h1 id="3、处理多图上传下载问题？"><a href="#3、处理多图上传下载问题？" class="headerlink" title="3、处理多图上传下载问题？"></a>3、处理多图上传下载问题？</h1><h1 id="UI刷新问题"><a href="#UI刷新问题" class="headerlink" title="UI刷新问题"></a>UI刷新问题</h1><h4 id="layout的相关方法"><a href="#layout的相关方法" class="headerlink" title="layout的相关方法:"></a>layout的相关方法:</h4><ul><li>layoutSubviews</li><li>layoutIfNeeded</li><li>setNeedsLayout</li><li>setNeedsDisplay</li><li>drawRect</li><li>sizeThatFits</li><li>sizeToFit</li></ul><h4 id="layoutSubviews"><a href="#layoutSubviews" class="headerlink" title="layoutSubviews"></a>layoutSubviews</h4><p>这个方法，默认没有做任何事情，需要子类进行重写 。 系统在很多时候会去调用这个方法：</p><p>1.初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发。<br>2.addSubview会触发layoutSubviews<br>3.设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化<br>4.滚动一个UIScrollView会触发layoutSubviews<br>5.旋转Screen会触发父UIView上的layoutSubviews事件<br>6.改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</p><blockquote><p> You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews,</p><p> 当我们在某个类的内部调整子视图位置时，需要调用。</p><p> 反过来的意思就是说：<strong>如果你想要在外部设置subviews的位置，就不要重写</strong>。</p></blockquote><h4 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout"></a>setNeedsLayout</h4><ul><li>标记为需要重新布局，不立即刷新，但layoutSubviews一定会被调用</li><li>配合layoutIfNeeded立即更新</li></ul><h4 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded"></a>layoutIfNeeded</h4><ul><li><strong>如果有需要刷新的标记，立即调用layoutSubviews进行布局</strong></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift备忘录</title>
      <link href="/2019/12/07/Swift%E5%A4%87%E5%BF%98%E5%BD%95/"/>
      <url>/2019/12/07/Swift%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="SwiftTip"><a href="#SwiftTip" class="headerlink" title="SwiftTip"></a>SwiftTip</h1><a id="more"></a><h4 id="Swift访问控制权限"><a href="#Swift访问控制权限" class="headerlink" title="Swift访问控制权限"></a>Swift访问控制权限</h4><p>Swift的访问权限管理依赖于两个概念：module和文件。module是一个完整的代码单元，</p><p>它可以是一个或多个框架（Framework），或者是一个App Bundle，可以被import导入到工程中。</p><p>文件指的就是<code>Swift File</code>，它通常属于一个module。</p><p>Swift 为代码中的实体提供了5种不同的访问级别:open、public、<strong>internal</strong>、fileprivate、private。</p><table><thead><tr><th align="left">访问级别</th><th align="left">定义</th></tr></thead><tbody><tr><td align="left">open</td><td align="left">这个属性允许在 app 内或 app 外重写和访问。在开发框架的时候，会应用到这个访问修饰符。</td></tr><tr><td align="left">public</td><td align="left">可以访问自己模块中源文件里的任何实体，别人也可以通过引入该模块来访问源文件里的所有实体。</td></tr><tr><td align="left">internal</td><td align="left">默认权限可以访问自己module中源文件里的任何实体</td></tr><tr><td align="left">fileprivate</td><td align="left"><strong>只能在当前源文件中使用。</strong></td></tr><tr><td align="left">private</td><td align="left"><strong>只允许实体在定义的类以及相同源文件内的 extension 中访问</strong></td></tr></tbody></table><p><strong>Open 为最高级访问级别，private 为最低级访问级别。</strong></p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span>   <span class="token punctuation">}</span></code></pre><p>*<em>如果希望<code>name</code>仅在当前文件中可访问，可以使用<code>private</code>修饰 *</em></p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">)</span> <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">}</span></code></pre><p><strong>如果希望外部可以读取，但不可以修改。这也是为了保证类型的封装和安全，在内部提供可读可写，而外部仅仅可读</strong></p><ul><li>这种写法相当于把<code>setter</code>设置为<code>private</code>，而<code>getter</code>仍然是默认的<code>internal</code></li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">private</span><span class="token punctuation">(</span><span class="token keyword">set</span><span class="token punctuation">)</span> <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">}</span></code></pre><p><strong>如果既想要外部可读，又想仅内部可写，可以为<code>getter</code>加上<code>public</code>：</strong></p><h4 id="声明关键字"><a href="#声明关键字" class="headerlink" title="声明关键字"></a><a href="https://swift.gg/2019/08/22/Swift-Keywords/#more" target="_blank" rel="noopener">声明关键字</a></h4><p><strong>associatedtype</strong>：在协议中，定义一个类型的占位符名称。直到协议被实现，该占位符才会被指定具体的类型。</p><pre class=" language-swift"><code class="language-swift">protocol <span class="token builtin">Entertainment</span>  <span class="token punctuation">{</span>      associatedtype <span class="token builtin">MediaType</span>  <span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">:</span> <span class="token builtin">Entertainment</span>  <span class="token punctuation">{</span>      <span class="token keyword">typealias</span> <span class="token builtin">MediaType</span> <span class="token operator">=</span> <span class="token builtin">String</span> <span class="token comment" spellcheck="true">//可以指定任意类型</span><span class="token punctuation">}</span></code></pre><p><strong>class</strong>：通用、灵活的结构体，是程序的基础组成部分。与 struct 类似，不同之处在于：</p><ul><li>允许一个类继承另一个类的特性。</li><li>类型转换，允许在运行时检查和指定一个类的实际类型。</li><li>析构方法允许类的实例释放所有资源。</li><li>引用计数允许多个引用指向一个实例。</li></ul><p><strong>struct</strong>：通用、灵活的结构体，是程序的基础组成部分，并提供了默认初始化方法。与 class 不同，当 struct 在代码中被传递时，是被拷贝的，并不使用引用计数。除此之外，struct 没有下面的这些功能：</p><ul><li>使用继承。</li><li>运行时的类型转换。</li><li>使用析构方法。</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Person</span>  <span class="token punctuation">{</span>      <span class="token keyword">var</span> name<span class="token punctuation">:</span><span class="token builtin">String</span>      <span class="token keyword">var</span> age<span class="token punctuation">:</span><span class="token builtin">Int</span>      <span class="token keyword">var</span> gender<span class="token punctuation">:</span><span class="token builtin">String</span>  <span class="token punctuation">}</span></code></pre><p><strong>extension</strong>：允许给已有的类、结构体、枚举、协议类型，添加新功能。</p><p><strong>NSError</strong>：<a href="https://nshipster.cn/nserror/" target="_blank" rel="noopener">code</a>、domin、userInfo</p><p><a href="https://onevcat.com/2017/10/swift-error-category/" target="_blank" rel="noopener">Swift Error分类</a></p><ul><li>domain error</li><li>Recoverable error</li><li>Universal error</li><li>Logic error</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Result</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token function">Success</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>    <span class="token keyword">case</span> <span class="token function">Failure</span><span class="token punctuation">(</span><span class="token builtin">NSError</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><strong>try!表示强制执行，如果发生异常程序crash</strong></p><p><strong>try?返回可选项，如果发生异常返回nil否则返回正常结果</strong></p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> E<span class="token punctuation">:</span> <span class="token builtin">Error</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token builtin">Negative</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">methodThrowsWhenPassingNegative</span><span class="token punctuation">(</span>number<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> number <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> E<span class="token punctuation">.</span><span class="token builtin">Negative</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> number<span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> <span class="token function">methodThrowsWhenPassingNegative</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token keyword">dynamicType</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"failed"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="autoclosure作用：将表达式自动封装成一个闭包"><a href="#autoclosure作用：将表达式自动封装成一个闭包" class="headerlink" title="@autoclosure作用：将表达式自动封装成一个闭包"></a>@autoclosure作用：将表达式自动封装成一个闭包</h4><p>()-&gt;Void</p><p>1.2 ??的底层实现是用的enum</p><p>1.3 “闭包和循环引用”</p><p><strong>weak解决循环引用的正确写法：</strong></p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token keyword">weak</span> <span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token keyword">in</span><span class="token keyword">if</span> <span class="token keyword">let</span> strongSelf <span class="token operator">=</span> <span class="token keyword">self</span> <span class="token punctuation">{</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The name is (strongSelf.name)"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="值类型和引用类型的选择"><a href="#值类型和引用类型的选择" class="headerlink" title="值类型和引用类型的选择"></a>值类型和引用类型的选择</h4><ul><li><p>数组和字典设计为值类型最大的考虑是为了线程安全.</p></li><li><p>另一个优点，那就是非常高效，因为 “一旦赋值就不太会变化” 这种使用情景在 Cocoa 框架中是占有绝大多数的，这有效减少了内存的分配和回收。</p></li></ul><p>但是在少数情况下，我们显然也可能会在数组或者字典中存储非常多的东西，并且还要对其中的内容进行添加或者删除。”</p><ul><li><p>在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好，</p></li><li><p>对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary</p></li></ul><h4 id="escaping的作用？"><a href="#escaping的作用？" class="headerlink" title="@escaping的作用？"></a>@escaping的作用？</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">func</span> <span class="token function">animate</span><span class="token punctuation">(</span>withDuration duration<span class="token punctuation">:</span> <span class="token builtin">TimeInterval</span><span class="token punctuation">,</span> animations<span class="token punctuation">:</span> @<span class="token function">escaping</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token builtin">Void</span><span class="token punctuation">,</span> completion<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Bool</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token constant">nil</span><span class="token punctuation">)</span></code></pre><img src="/Users/mac/Downloads/图像 2019-12-5，下午6.41.jpg" alt="图像 2019-12-5，下午6.41" style="zoom:50%;" /><h4 id="defer的使用注意点"><a href="#defer的使用注意点" class="headerlink" title="defer的使用注意点"></a>defer的使用注意点</h4><p><strong>defer的作用域</strong></p><p><strong>以前很单纯地认为 defer 是在函数退出的时候调用，并没有注意其实是当前 scope 退出的时候调用这个事实，造成了这个错误。在 if，guard，for，try 这些语句中使用 defer 时，应该要特别注意这一点。</strong></p><img src="/Users/mac/Downloads/图像 2019-12-5，下午6.41-1.jpg" alt="图像 2019-12-5，下午6.41-1" style="zoom:150%;" /><h4 id="discardableResult"><a href="#discardableResult" class="headerlink" title="@discardableResult"></a>@discardableResult</h4><h4 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result<T></h4><p><a href="https://onevcat.com/2018/10/swift-result-error/" target="_blank" rel="noopener">Result&lt;T, E: Error&gt; 和 Result<T></a></p><h4 id="Lazy的使用"><a href="#Lazy的使用" class="headerlink" title="Lazy的使用"></a>Lazy的使用</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token keyword">let</span> result <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token keyword">lazy</span><span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token keyword">in</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"准备处理(i)"</span><span class="token punctuation">)</span><span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"准备访问结果"</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> result <span class="token punctuation">{</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"处理后的结果:(i)"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span></code></pre><p>打印结果：</p><blockquote><p>准备访问结果</p></blockquote><p>准备处理1</p><p>处理后的结果:2</p><p>准备处理2</p><p>处理后的结果:4</p><p>准备处理3</p><p>处理后的结果:6</p><p>done</p><h4 id="Swift反射机制Mirror"><a href="#Swift反射机制Mirror" class="headerlink" title="Swift反射机制Mirror"></a>Swift反射机制Mirror</h4><blockquote><p>“通过 Mirror 初始化得到的结果中包含的元素的描述都被集合在 children 属性下，如果你有心可以到 Swift 标准库中查找它的定义，它实际上是一个 Child 的集合，而 Child 则是一对键值的多元组：</p></blockquote><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Car</span> <span class="token punctuation">{</span><span class="token keyword">let</span> logo<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token keyword">var</span> wheel<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token keyword">let</span> door<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">}</span><span class="token keyword">let</span> baoM <span class="token operator">=</span> <span class="token function">Car</span><span class="token punctuation">(</span>logo<span class="token punctuation">:</span> <span class="token string">"BMW"</span><span class="token punctuation">,</span> wheel<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> door<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">let</span> mirror <span class="token operator">=</span> <span class="token function">Mirror</span><span class="token punctuation">(</span>reflecting<span class="token punctuation">:</span> baoM<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"类型:(String(describing: mirror.displayStyle))"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">///1、通过Mirror的children获取属性信息</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"属性个数:(mirror.children.count)"</span><span class="token punctuation">)</span>mirror<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Any</span> <span class="token keyword">in</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"label: (String(describing: child.label)), value: (child.value)"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">///2、通过Refletion的dump(Any)方法获取属性信息</span><span class="token function">dump</span><span class="token punctuation">(</span>baoM<span class="token punctuation">)</span></code></pre><h3 id="示例2-获取property"><a href="#示例2-获取property" class="headerlink" title="示例2 获取property"></a>示例2 获取property</h3><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> homeProperty <span class="token operator">=</span> <span class="token function">Mirror</span><span class="token punctuation">(</span>reflecting<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">)</span>homeProperty<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span><span class="token constant">LOG</span><span class="token punctuation">.</span><span class="token function">D</span><span class="token punctuation">(</span><span class="token string">"home property:($0)"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="iOS初始化核心原则"><a href="#iOS初始化核心原则" class="headerlink" title="iOS初始化核心原则"></a>iOS初始化核心原则</h4><blockquote><p>iOS 的初始化最核心两条的规则：</p></blockquote><blockquote><p>• 必须至少有一个指定初始化器，在指定初始化器里保证所有非可选类型属性都得到正确的初始化（有值）</p></blockquote><blockquote><p>• 便利初始化器必须调用其他初始化器，使得最后肯定会调用指定初始化器</p></blockquote><p>在Swift中千万不要用String的count方法计算文本长度。否则当文本中有emoji时，会计算出错。应当转成NSString再去求length。</p><h2 id="Array-for-in使用"><a href="#Array-for-in使用" class="headerlink" title="Array for-in使用"></a>Array for-in使用</h2><img src="/Users/mac/Library/Application Support/typora-user-images/image-20191205151814435.png" alt="image-20191205151814435" style="zoom:50%;" /><h4 id="1-for-in获取索引-index"><a href="#1-for-in获取索引-index" class="headerlink" title="1.for in获取索引 index"></a>1.for in获取索引 index</h4><pre class=" language-swift"><code class="language-swift">                <span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Google"</span><span class="token punctuation">,</span> <span class="token string">"Amazon"</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> item <span class="token keyword">in</span> array <span class="token punctuation">{</span>          <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"company name is :(item)"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">///配合array.enumerated()使用</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> item<span class="token punctuation">)</span> <span class="token keyword">in</span> array<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"index:(index), item:(item)"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span></code></pre><h4 id="2-array-firstIndex-of-获取index"><a href="#2-array-firstIndex-of-获取index" class="headerlink" title="2.array.firstIndex(of:)获取index"></a>2.array.firstIndex(of:)获取index</h4><pre class=" language-swift"><code class="language-swift">                <span class="token comment" spellcheck="true">///配合array.firstIndex(of:)使用</span>        <span class="token keyword">let</span> googleIndex <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">firstIndex</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> <span class="token string">"Google"</span><span class="token punctuation">)</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"googleIndex is : (googleIndex ?? 0)"</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">///配合array.firstIndex(where:)使用</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> index <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">firstIndex</span><span class="token punctuation">(</span><span class="token keyword">where</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> $<span class="token number">0</span><span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"array.firstIndex is (index)"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> item <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token keyword">where</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> $<span class="token number">0</span><span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"array.first is :(item)"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span></code></pre><h2 id="Array-forEach"><a href="#Array-forEach" class="headerlink" title="Array.forEach()"></a>Array.forEach()</h2><h4 id="2-1forEach-和函数式编程结合使用"><a href="#2-1forEach-和函数式编程结合使用" class="headerlink" title="2.1forEach()和函数式编程结合使用"></a>2.1forEach()和函数式编程结合使用</h4><pre class=" language-swift"><code class="language-swift">                <span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"5"</span><span class="token punctuation">,</span> <span class="token string">"6"</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">///使用forEach</span>        array<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token function">Int</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">!</span> <span class="token punctuation">}</span><span class="token punctuation">.</span>forEach <span class="token punctuation">{</span> num <span class="token keyword">in</span>            <span class="token function">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//不使用forEach</span>        <span class="token keyword">let</span> <span class="token builtin">map</span> <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token function">Int</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">!</span> <span class="token punctuation">}</span>        <span class="token builtin">map</span><span class="token punctuation">.</span>forEach <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span></code></pre><h4 id="2-2forEach-遍历optional集合会自动过滤nil"><a href="#2-2forEach-遍历optional集合会自动过滤nil" class="headerlink" title="2.2forEach()遍历optional集合会自动过滤nil"></a>2.2forEach()遍历optional集合会自动过滤nil</h4><pre class=" language-swift"><code class="language-swift">                <span class="token keyword">let</span> optionalString<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token constant">nil</span>        <span class="token comment" spellcheck="true">//使用forEach强制解包option，会过滤</span>        optionalString<span class="token operator">?</span><span class="token punctuation">.</span>forEach <span class="token punctuation">{</span> str <span class="token keyword">in</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"str is (str)"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">///使用for-in强制解包optional，会crash</span>        <span class="token keyword">for</span> str <span class="token keyword">in</span> optionalString<span class="token operator">!</span> <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"str is (str)"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span></code></pre><h2 id="Array-index"><a href="#Array-index" class="headerlink" title="Array index"></a>Array index</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift函数式编程</title>
      <link href="/2019/12/06/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/12/06/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Functional-Programming-in-Swift"><a href="#Functional-Programming-in-Swift" class="headerlink" title="Functional Programming in Swift"></a>Functional Programming in Swift</h1><p>函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10</p><p>在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。</p><a id="more"></a><h2 id="不变性和副作用"><a href="#不变性和副作用" class="headerlink" title="不变性和副作用"></a>不变性和副作用</h2><p>无论您首先学习哪种编程语言，您可能要学习的最初概念之一就是变量代表数据或状态。如果您退一步考虑一下这个想法，变量似乎很奇怪。</p><p>术语“变量”表示随程序运行而变化的数量。从数学角度考虑数量问题，您已将时间作为软件行为的关键参数。通过更改变量，可以创建可变状态。</p><p>为了进行演示，请将以下代码添加到playground：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> thing <span class="token operator">=</span> <span class="token number">3</span><span class="token comment" spellcheck="true">//some stuff</span>thing <span class="token operator">=</span> <span class="token number">4</span><span class="token keyword">func</span> <span class="token function">superHero</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"I'm batman"</span><span class="token punctuation">)</span>  thing <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"original state = <span class="token interpolation"><span class="token delimiter variable">\(</span>thing<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token function">superHero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mutated state = <span class="token interpolation"><span class="token delimiter variable">\(</span>thing<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span></code></pre><p>神圣的神秘变化！为什么现在是5？这种变化称为副作用。函数superHero（）更改了一个甚至没有定义自己的变量。</p><p>单独或在简单系统中，可变状态不一定是问题。将许多对象连接在一起时（例如在大型的面向对象的系统中）会出现问题。可变状态会使人难以理解变量具有什么值以及该值随时间的变化而产生头痛。</p><p>例如，在为多线程系统编写代码时，如果两个或多个线程<strong>同时访问同一变量</strong>，则它们可能会<strong>无序地修改或访问它</strong>。这会导致意外的行为。<strong>这种意外行为包括竞态条件，死锁和许多其他问题。</strong></p><p>试想一下，如果您可以编写状态永远不变的代码。并发系统中发生的所有问题都将消失。像这样工作的系统具有<strong>不变的状态</strong>，这意味着不允许状态在程序过程中进行更改。</p><p>使用不可变数据的主要好处是，使用不可变数据的代码单元没有副作用。代码中的函数不会更改其自身之外的元素，并且在发生函数调用时不会出现怪异的效果。您的程序可以正常运行，因为没有副作用，您可以轻松重现其预期的效果。</p><p>本教程从较高的层次介绍了FP，因此在实际情况下考虑这些概念会很有帮助。在这种情况下，假设您正在为游乐园构建应用程序，并且该游乐园的后端服务器通过REST API提供了行程数据。</p><h2 id="创建Model"><a href="#创建Model" class="headerlink" title="创建Model"></a>创建Model</h2><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">RideCategory</span><span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>  <span class="token keyword">case</span> family  <span class="token keyword">case</span> kids  <span class="token keyword">case</span> thrill  <span class="token keyword">case</span> scary  <span class="token keyword">case</span> relaxing  <span class="token keyword">case</span> water<span class="token punctuation">}</span><span class="token keyword">typealias</span> <span class="token builtin">Minutes</span> <span class="token operator">=</span> <span class="token builtin">Double</span><span class="token keyword">struct</span> <span class="token builtin">Ride</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>  <span class="token keyword">let</span> categories<span class="token punctuation">:</span> <span class="token builtin">Set</span><span class="token operator">&lt;</span><span class="token builtin">RideCategory</span><span class="token operator">></span>  <span class="token keyword">let</span> waitTime<span class="token punctuation">:</span> <span class="token builtin">Minutes</span><span class="token punctuation">}</span></code></pre><h2 id="Create-some-data-using-that-model"><a href="#Create-some-data-using-that-model" class="headerlink" title="Create some data using that model"></a>Create some data using that model</h2><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> parkRides <span class="token operator">=</span> <span class="token punctuation">[</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R45"</span><span class="token punctuation">,</span>               categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>family<span class="token punctuation">,</span> <span class="token punctuation">.</span>thrill<span class="token punctuation">,</span> <span class="token punctuation">.</span>water<span class="token punctuation">]</span><span class="token punctuation">,</span>               waitTime<span class="token punctuation">:</span> <span class="token number">45.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R10"</span><span class="token punctuation">,</span> categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>family<span class="token punctuation">]</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">:</span> <span class="token number">10.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R15"</span><span class="token punctuation">,</span> categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>kids<span class="token punctuation">]</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">:</span> <span class="token number">15.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R30"</span><span class="token punctuation">,</span> categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>scary<span class="token punctuation">]</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">:</span> <span class="token number">30.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R60"</span><span class="token punctuation">,</span>               categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>family<span class="token punctuation">,</span> <span class="token punctuation">.</span>thrill<span class="token punctuation">]</span><span class="token punctuation">,</span>               waitTime<span class="token punctuation">:</span> <span class="token number">60.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R15-2"</span><span class="token punctuation">,</span> categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>family<span class="token punctuation">,</span> <span class="token punctuation">.</span>kids<span class="token punctuation">]</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">:</span> <span class="token number">15.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R25"</span><span class="token punctuation">,</span> categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>family<span class="token punctuation">,</span> <span class="token punctuation">.</span>water<span class="token punctuation">]</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">:</span> <span class="token number">25.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R0"</span><span class="token punctuation">,</span>               categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>family<span class="token punctuation">,</span> <span class="token punctuation">.</span>relaxing<span class="token punctuation">]</span><span class="token punctuation">,</span>               waitTime<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">)</span>        <span class="token punctuation">]</span></code></pre><h2 id="FP-Filter-Map-Reduce"><a href="#FP-Filter-Map-Reduce" class="headerlink" title="FP: Filter Map Reduce"></a>FP: Filter Map Reduce</h2><p><strong>Most languages that support FP will have the functions filter, map &amp; reduce.</strong></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><blockquote><p>Map是将输入Collection中的每个Element转换为新Element。</p><p>使用map遍历一个集合，并对集合中的每个元素应用相同的操作。</p><p> map函数返回一个数组，其中包含对每个元素的映射或转换函数的结果。</p></blockquote><h4 id="Map-on-array"><a href="#Map-on-array" class="headerlink" title="Map on array:"></a>Map on array:</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> arrayOfInt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span></code></pre><p>如果我们要对每个元素乘上10呢？我们以前可能要这样</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> newArr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> value <span class="token keyword">in</span> arrayOfInt <span class="token punctuation">{</span>    newArr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>value <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span></code></pre><p>现在有map()后我们可以这样：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> mapArr <span class="token operator">=</span> arrayOfInt<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>mapArr<span class="token punctuation">)</span></code></pre><blockquote><p>Working of map: The map function has a single argument which is a closure (a function) that it calls as it loops over the collection. This closure takes the element from the collection as an argument and returns a result. The map function returns these results in an array.</p></blockquote><h4 id="Map-on-Dictionary"><a href="#Map-on-Dictionary" class="headerlink" title="Map on Dictionary"></a>Map on Dictionary</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> book <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">]</span><span class="token keyword">let</span> mapedBook <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span>    key<span class="token punctuation">.</span>capitalized<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>mapedBook<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//["C", "B", "A"]</span></code></pre><h4 id="Map-on-Set"><a href="#Map-on-Set" class="headerlink" title="Map on Set"></a>Map on Set</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> lengthInmeter<span class="token punctuation">:</span> <span class="token builtin">Set</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token keyword">let</span> km  <span class="token operator">=</span> lengthInmeter<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> meter <span class="token keyword">in</span> meter <span class="token operator">*</span> <span class="token number">1000</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>km<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [1000, 5000, 3000]</span></code></pre><h4 id="Map同时获取array-Index"><a href="#Map同时获取array-Index" class="headerlink" title="Map同时获取array.Index??"></a>Map同时获取array.Index??</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token keyword">let</span> newNums <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token keyword">in</span>    <span class="token keyword">return</span> num <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"newNums:<span class="token interpolation"><span class="token delimiter variable">\(</span>newNums<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span></code></pre><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter函数的作用是过滤集合，返回符合条件的集合。</p><h4 id="Filter-on-Array"><a href="#Filter-on-Array" class="headerlink" title="Filter on Array"></a>Filter on Array</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> filterArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token keyword">let</span> newFilterArray <span class="token operator">=</span> filterArray<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span> num <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token keyword">in</span>    num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>newFilterArray<span class="token punctuation">)</span></code></pre><h4 id="Filter-on-Dictionary"><a href="#Filter-on-Dictionary" class="headerlink" title="Filter on Dictionary"></a>Filter on Dictionary</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> book <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">]</span><span class="token keyword">let</span> bookFilter <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span>    value <span class="token operator">></span> <span class="token number">80</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>bookFilter<span class="token punctuation">)</span></code></pre><p><strong>简化</strong></p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> book <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">]</span><span class="token keyword">let</span> bookFilter <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span>    $<span class="token number">1</span> <span class="token operator">></span> <span class="token number">80</span><span class="token punctuation">}</span></code></pre><blockquote><p>$0是key</p><p>$1是value</p></blockquote><h4 id="Filter-on-Set"><a href="#Filter-on-Set" class="headerlink" title="Filter on Set"></a>Filter on Set</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> setNums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4.9</span><span class="token punctuation">,</span><span class="token number">5.5</span><span class="token punctuation">,</span><span class="token number">8.6</span><span class="token punctuation">]</span><span class="token keyword">let</span> newSet <span class="token operator">=</span> setNums<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span>    $<span class="token number">0</span> <span class="token operator">></span> <span class="token number">5.0</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>newSet<span class="token punctuation">)</span></code></pre><p><strong>重要：返回类型是数组</strong></p><h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><blockquote><p>Use <code>reduce</code> to combine all items in a collection to create a single new value.</p></blockquote><blockquote><p>使用<em>reduce</em>可以合并集合中的所有元素来创建一个新的value</p></blockquote><p>Apple文档声明reduce()</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token builtin">reduce</span><span class="token operator">&lt;</span><span class="token builtin">Result</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> initialResult<span class="token punctuation">:</span> <span class="token builtin">Result</span><span class="token punctuation">,</span> <span class="token number">_</span> nextPartialResult<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">Result</span><span class="token punctuation">,</span> <span class="token builtin">Element</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Result</span><span class="token punctuation">)</span> <span class="token keyword">rethrows</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Result</span></code></pre><p><strong>reduce</strong>函数有两个参数：</p><ul><li>第一个参数 <strong>initial value</strong>用来存储初始值或者结果（每次迭代器的结果）</li><li>第二个是带有两个参数的闭包，Result是初始值或迭代器的结果，Element是集合中的下一个元素。</li></ul><h4 id="Reduce-on-Array"><a href="#Reduce-on-Array" class="headerlink" title="Reduce on Array"></a>Reduce on Array</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token keyword">let</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token keyword">in</span>    x <span class="token operator">+</span> y<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span></code></pre><p>简化版本：使用$0代表result</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> reducedSum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">+</span> $<span class="token number">1</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>reducedSum<span class="token punctuation">)</span><span class="token comment" spellcheck="true">///等价</span><span class="token keyword">let</span> reducedSum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>reducedSum<span class="token punctuation">)</span></code></pre><p>乘法</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> produceNum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token keyword">in</span>    x <span class="token operator">*</span> y<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>produceNum<span class="token punctuation">)</span><span class="token comment" spellcheck="true">///等价</span><span class="token keyword">let</span> produceNum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>produceNum<span class="token punctuation">)</span></code></pre><h4 id="Reduce-连接字符串"><a href="#Reduce-连接字符串" class="headerlink" title="Reduce + 连接字符串"></a>Reduce + 连接字符串</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> charactors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span><span class="token string">"def"</span><span class="token punctuation">,</span><span class="token string">"hijk"</span><span class="token punctuation">]</span><span class="token keyword">let</span> newCharactor <span class="token operator">=</span> charactors<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>newCharactor<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// abcdefhijk</span></code></pre><h4 id="Reduce-on-Dictionary"><a href="#Reduce-on-Dictionary" class="headerlink" title="Reduce on Dictionary"></a>Reduce on Dictionary</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> dict <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// Reduce on value</span><span class="token keyword">let</span> reducedNum <span class="token operator">=</span> dict<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> result<span class="token punctuation">,</span> dic <span class="token keyword">in</span>    <span class="token keyword">return</span> result <span class="token operator">+</span> dic<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"reduc on value is <span class="token interpolation"><span class="token delimiter variable">\(</span>reducedNum<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// reduc on value is 125</span><span class="token comment" spellcheck="true">// Reduce on key</span><span class="token keyword">let</span> reducedName <span class="token operator">=</span> dict<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token string">"Charactor are "</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>result<span class="token punctuation">,</span> dic<span class="token punctuation">)</span> <span class="token keyword">in</span>    <span class="token keyword">return</span> result <span class="token operator">+</span> dic<span class="token punctuation">.</span>key <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"reduce on key is &lt;<span class="token interpolation"><span class="token delimiter variable">\(</span>reducedName<span class="token delimiter variable">)</span></span>>"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//reduce on key is &lt;Charactor are A B ></span></code></pre><p>简化</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> reducedNameOnDic <span class="token operator">=</span> dict<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token string">"Charater are "</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">+</span> $<span class="token number">1</span><span class="token punctuation">.</span>key <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">}</span></code></pre><h4 id="Reduce-on-Set"><a href="#Reduce-on-Set" class="headerlink" title="Reduce on Set"></a>Reduce on Set</h4><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// Reduce on Set</span><span class="token keyword">let</span> lengthMeters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3.4</span><span class="token punctuation">,</span><span class="token number">1.6</span><span class="token punctuation">]</span><span class="token keyword">let</span> reducedMeters <span class="token operator">=</span> lengthMeters<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    $<span class="token number">0</span> <span class="token operator">+</span> $<span class="token number">1</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"reduced meters :<span class="token interpolation"><span class="token delimiter variable">\(</span>reducedMeters<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 5.0</span></code></pre><h2 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h2><p>Flatmap is used to flatten a collection of collections . But before flattening the collection, we can apply map to each elements.</p><blockquote><p><strong>Apple docs says</strong>: Returns an array containing the concatenated results of calling the given transformation with each element of this sequence.</p></blockquote><p>Flatmap用于展平集合的集合。 但是在展平集合之前，我们可以将map应用于每个集合元素。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> charaters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span><span class="token string">"def"</span><span class="token punctuation">,</span><span class="token string">"ghi"</span><span class="token punctuation">]</span><span class="token keyword">let</span> newCharaters <span class="token operator">=</span> charaters<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>newCharaters<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//["a", "b", "c", "d", "e", "f", "g", "h", "i"]</span><span class="token keyword">let</span> codes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span><span class="token string">"def"</span><span class="token punctuation">,</span><span class="token string">"ghi"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"jkl"</span><span class="token punctuation">,</span><span class="token string">"mno"</span><span class="token punctuation">,</span><span class="token string">"pqr"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"stu"</span><span class="token punctuation">,</span><span class="token string">"vwx"</span><span class="token punctuation">,</span><span class="token string">"yz"</span><span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token keyword">let</span> newCodes <span class="token operator">=</span> codes<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span>$<span class="token number">0</span><span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>newCodes<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// ["abc", "def", "ghi", "jkl", "mno", "pqr", "stu", "vwx", "yz"]</span></code></pre><h4 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> nilArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token constant">nil</span><span class="token punctuation">]</span><span class="token function">print</span><span class="token punctuation">(</span>nilArray<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [2,3]</span><span class="token comment" spellcheck="true">// warning: 'flatMap' is deprecated: Please use compactMap(_:) for the case where closure returns an optional value</span><span class="token function">print</span><span class="token punctuation">(</span>nilArray<span class="token punctuation">.</span>compactMap <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [2,3]</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
