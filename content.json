{"meta":{"title":"明日危机","subtitle":"iOS & Swifter","description":"","author":"KM","url":"https://mingriweiji-github.github.io","root":"/"},"pages":[],"posts":[{"title":"LookinLoader安装使用","slug":"LookinLoader安装使用","date":"2020-04-06T08:54:49.718Z","updated":"2020-04-14T08:52:38.758Z","comments":true,"path":"2020/04/06/LookinLoader安装使用/","link":"","permalink":"https://mingriweiji-github.github.io/2020/04/06/LookinLoader%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Lookin查看自己的App 1、Lookin下载 2、pod添加：pod &#39;LookinServer&#39;, :configurations =&gt; [&#39;Debug&#39;] 3、pod install 4、打开mac上安装的Lookin 配合LookinLoader查看第三方App 官方：正常情况下，你无法将 LookinServer 嵌入到别人的 iOS App 里，因此你也就无法使用 Lookin 查看别人的 App。但我们也注意到有些第三方开发者通过某些方式实现了向别人的 App 中注入 Framework 的需求，这可能已属于逆向破解范畴，你可在 Github 中搜索 LookinLoader 自行研究，或向他们寻求帮助。 1、LookinLoader安装Step 1 在越狱手机中的「Cydia」-&gt;搜索「LookinLoader」-&gt;「安裝」 Step 2进入设置-&gt;「Lookin」-&gt;「Enabled Applications」-&gt;启用想要查看的App Step 3数据线连接越狱手机到Mac-&gt; 打开要查看的APP -&gt;Mac上打开Lookin -&gt; 查看三方的App。 2、Lookin使用2.1可以看到列表0 2.2可以看到列表6 代理方法：UIScrollViewDelayedTouchesBeganGestureRecognizer 代理方法：UIScrollViewPanGestureRecognizer","categories":[],"tags":[]},{"title":"iOS越狱初体验","slug":"iOS越狱初体验","date":"2020-04-04T09:20:36.310Z","updated":"2020-04-09T00:13:42.851Z","comments":true,"path":"2020/04/04/iOS越狱初体验/","link":"","permalink":"https://mingriweiji-github.github.io/2020/04/04/iOS%E8%B6%8A%E7%8B%B1%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"","text":"iOS越狱初体验iOS越狱能做到什么？ 查看 第三方APP UI 排版方式、布局实现技术 获取三方App内部资源 .assets/.plist/icon… 修改APP 功能重新打包 (EX: 去广告) 反编译推测原始工程代码内容 dump 出 .h 头文件 / keycahin / db 越狱环境macOS 版本：10.15 CatalinaiOS 版本：iPhone 5s (iOS 9.0.1/ 完美越狱***必要)**Cydia: Open SSH 逆向工程大致流程： 解密并导出应用程序、class-dump导出头文件 从当面界面入手，获取当前界面布局和控制器VC hook相关类，记录输出调用的顺序和参数 关键函数，查看调用堆栈，hook测试结果 静态分析+动态调试分析关键函数的实现逻辑 模拟或篡改函数调用逻辑 制作插件或移植到非越狱设备上 1、越狱环境搭建 完美越狱的5c手机iOS8-iOS8.4 or 完美越狱的5s系统iOS9-iOS9.1 Mac安装 iFunBox:管理文件系统 iPhone安装 爱思助手 Cydia 通过Cydia安装下面的源到越狱设备上 Apple File Conduit 2：可以访问整个iOS文件系统 iFile: 可以自由访问iOS文件系统 2、Mac远程登录到iPhone使用SSH（Secure Shell安全外壳协议）来远程登录iPhone 使用SSH将所有传输的数据加密，防止DNS欺骗和IP欺骗 使用OpenSSH协议让Mac远程登录到iPhone iPhone上通过Cydia来安装OpenSSH工具 Cydia搜索OpenSSH 安装Openssh Mac终端： ssh root@host 输入初始密码alpine 退出登录：exit $ ssh root@192.168.0.110 root@192.168.0.110's password: password for ssh root@host$ sudo -s $ passwd Changing password for root. New password: Retype new password: 报错：ImportError: No module named usbmux 重新下载 usbmuxd工具包 保留python-client 文件夹 变更服务器身份信息 删除公钥信息：ssh-keygen -R yourIPAddress 删除known_hosts文件：vim ~/.ssh/known_hosts SSH基于秘钥的客户端认证 在客户端生成一对秘钥：公钥+私钥 $: ssh-keygen 一路敲回车键（Enter）即可 OpenSSH默认生成的是RSA密钥，可以通过-t参数指定密钥类型 生成的公钥：~/.ssh/id_rsa.pub 生成的私钥：~/.ssh/id_rsa 将客户端的公钥追加到服务器的授权文件尾部:~/.ssh/authorized_keys ssh-copy-id root@yourIPAddressshell脚本文件 通过sh、bash、source命令执行sh脚本文件 sh和bash会在当前shell环境启动一个子进程来执行文件，执行后返回到父进程的shell环境 执行cd时，子进程会进入到cd的目录，但是父进程的环境并未改变-即目录没有改变 source 在当前shell环境执行脚本文件 执行cd后自动跳转到cd的目录 source可以用”.”代替，比如”.test.sh”使用source来执行shell脚本test.sh 基于秘钥登录 1、在客户端生成一对相关联的密钥，将客户端的公钥信息追加到服务器的授权文件尾部（~/.ssh/authorized_keys）: 生成秘钥：ssh-keygen 追加到服务器授权文件：ssh-copy-id root@手机IP地址 复制客户端的公钥：scp ~/.ssh/id_rsa.pub root@服务器主机地址:~ SSH登录服务器：ssh root@服务器主机地址 2、执行脚本: python ~/tcprelay.py -t 22:10086 利用usbmuxd编写的py脚本将Mac的10086端口连接到iPhone上的22端口上Mac登录到10086端口： ssh -p 10086 root@localhost 3、Mac登录到10086端口： ssh -p 10086 root@localhost 5s:~/.ssh root# cat authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDIoCG1j95eGXgui0R8JRMSe2AHGi3RV7L1SNU/06WK21pc4tqwgiUphPwnf+yQ1SlhV4KH6utZWDa4STugDdp+nuUpMF7HYC+4iGSqP6GCpgiV+3ehqHd5cYhPIPUWinISJNJkIYU8HBUTw1Ua9HqTxrrIhV+AbZhKymDDJ+1X3+dnhu0yNZ2W4HpFDwAT9OB4go2PTGROyneHEz72bvcTAqkDdbKjbKOPD61bzlbHJqBAb0wCeTPEYWNwxb+lRcvzFs61TwCuLXQJ+GCyAtKZYzU/I9DGgfhgWQ38xB04rGMPjqOeEDRI9T8j8r3q8wP+K0BJmTlaMhYfl70U1ZUDPbqgfD93IpL4h+Mb0nqvWwkcqaFB4NPgrwvJG5WYWmR1mgu37rzC2f9BDUDz4izwSyEQDk7PwaLuuBfJet6Ro/vdHXGwUhTXP01Tkg+Qj/qcN7aMvPMXHkWNS6v83urRHwFgSSqJ1QC6O3xZlHZeRfPFt7UhcqgAGEgs8K2aCAc= Seven@MLideMacBook-Pro.local 5s:~/.ssh root# cd /etc/ssh 5s:/etc/ssh root# ls -l total 272 -rw-r--r-- 1 root wheel 242153 May 4 2018 moduli -rw-r--r-- 1 root wheel 1526 May 4 2018 ssh_config -rw------- 1 root wheel 672 May 4 2018 ssh_host_dsa_key -rw-r--r-- 1 root wheel 590 May 4 2018 ssh_host_dsa_key.pub -rw------- 1 root wheel 965 May 4 2018 ssh_host_key -rw-r--r-- 1 root wheel 630 May 4 2018 ssh_host_key.pub -rw------- 1 root wheel 1679 May 4 2018 ssh_host_rsa_key -rw-r--r-- 1 root wheel 382 May 4 2018 ssh_host_rsa_key.pub -rw-r--r-- 1 root wheel 3227 May 4 2018 sshd_config 5s:/etc/ssh root# cat ssh_host_rsa_key.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDMQHoD19uC7fQpPXMN6GWR0YcGC7BlmLis4uyuu6hk7bqDADfHlXvU5cJ6gxSkrwjzFrWPcVD5JfyrAWEw2VGMxgtMoBTOjCRciDR+yJioTbeL85r8UdT5CtVDjGkiC+07SGopHnYt1x+45lMIMzdzVbLhKTv+DIm+OIawavJSIOvhHLlf4kFrrj0vuxkDOpV8fSRdnHLKMayQ6dmgFRlYJJSCLx10VLpUhgLA6g3m3wIq5bDSoR75uEYVUYny+itCQxVXFfydKsKncBAlxE2vKKh5Ry/pQaWFBff3jEDgfFtmqGtj5y3MlLjdtqn4zLTE3FwqCAEen63+gR8z4wof 5s:/etc/ssh root# 基于USB登录 下载usbmuxd工具包（下载v1.0.8版本，主要用到里面的一个python脚本：tcprelay.py）https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz 1、Mac登录到10010端口:python tcprelay.py -t 22:10010 2、将iPhone的22端口（SSH端口）映射到Mac本地的10010端口:ssh root@localhost -p 10010 $ python ~/pathto/python-client/tcprelay.py -t 22:10010 $ ssh root@localhost -p 10010 3、Cycript动态调试 它是Objective-C++、JavaScript、Java等语法的混合产物 用来修改和调试正在运行中的Mac/iOS 应用 官网：http://www.cycript.org/ Cydia安装Cycript后，即可在iPhone上调试运行中的App 1、Cycript安装问题$ cycript dyld: Library not loaded: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib Referenced from: /Users/mli/cycript_0.9.594//Cycript.lib/cycript-apl Reason: image not found [1] 8373 abort cycript 方式1：替换libruby.2.6.dylib解决方式一：由于我的MacOS是版本10.15.4 Catalina,自带ruby版本是2.6 如果你用homebrew已经安装过高版本的Ruby，那么你可以进到/usr/local/Cellar/ruby/2.6.0/lib这个目录下，将libruby.2.6.dylib拷贝一份，然后改名为libruby.2.0.0.dylib。并将改名后的文件拷贝到Cycript.lib目录下即可。 ~: $ source .bash_profile ~: $ cycript cy# 出现cy#表示成功了 control + D可以退出 Cycript。 如果是使用iTerm2+oh my zsh组合，可以在.zshrc配置文件中导入source .bash_profile，这样每次打开就不用手动执行了！ $ open ~/.zshrc 添加配置：source ~/.bash_profile 方式2:安装ruby2.0方式二：测试该方式对于MacOS Catalina无效，中文博客都是这种方式，brew install ruby@2.0 也无法在Catalina系统上通过，所以直接修改libruby.2.6.dylib为libruby.2.0.0.dylib是简单有效的方法 1、关闭Mac的SIP 电脑重启，听到咚的时候，按住command+R，进入恢复模式 打开终端，输入csrutil disable，重启 2、查看ruby版本安装ruby2.0$ cd /System/Library/Frameworks/Ruby.framework/Versions/ $ ls 2.6 Current $ brew install ruby@2.0 3、我的ruby版本是2.6直接把本机的ruby版本的复制一份，改为2.0即可 1、关闭系统的禁用新版SIP防护 电脑重启按住command+R，进入恢复模式 打开终端，输入csrutil disable，重启 如果想打开SIP，重复上两步，命令改为csrutil enable 2、禁用SIP之后，在终端输入sudo mount -uw /，然后重启finder之后就可以对文件夹进行复制了，复制之后，对文件夹和文件名称修改为2.0，就可以正常使用Cycript了 sudo mkdir -p /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ sudo ln -s /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/libruby.2.6.0.dylib /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/libruby.2.0.0.dylib 2、Cycript使用进程名称/进程ID终端输入命令行： $ ps -A 启动越狱iPhone上的App如下： /var/mobile/Containers/Bundle/Application/AAB4F619-1565-4D60-98B7-9A5465674C0E/ElevenPlayer.app/ElevenPlayer /var/mobile/Containers/Bundle/Application/B15E42B6-EFF0-482A-A184-2E56E18BC096/Taobao4iPhone.app/Taobao4iPhone /var/mobile/Containers/Bundle/Application/6907C865-4845-4423-92BF-65D61F4B9816/DingTalk.app/DingTalk ElevenPlayer Taobao4iPhone DingTalk Cycript调试1、通过Cydia安装Cycript 2、终端输入： cycript -p Taobao4iPhone Cycript基本语法 UIApp: [UIApplication sharedApplication] var 变量名 = 变量值 通过内存地址获取内存中的对象: #内存地址 已经加载的所有OC类：ObjectiveC.classes 获取某个对象所有的成员变量：*对象名 递归打印view的所有子view: view.recursiveDescription().toString()等同于Xcode中的[view recursiveDescription] 筛选某种类型的对象: choose(UIViewController) choose(UITableViewCell) 5s:~ root# cycript -p 1856 cy# UIApp #\"&lt;UIApplication: 0x147e6db70>\" cy# var win = #0x147e6db70.keyWindow #\"&lt;UIWindow: 0x1490eba30; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x1490ed500>; layer = &lt;UIWindowLayer: 0x1490e3f50>>\" cy# UIApp.keyWindow.rootViewController #\"&lt;TBMainViewController: 0x14807b200>\" cy# choose(UICollectionViewCell) .... UIApp.keyWindow.recursiveDescription().toString()可以打印所有层级 3、使用mjcript.cy 基于Cycript实现的一些实用函数，下载地址：https://github.com/CoderMJLee/mjcript 1、下载mjcript库 2、将mjcript.cy文件拖到/usr/lib/cycript0.9 3、SSH连接iOS设备 4、使用Cycript监听APP，通过命令@import mjcript 导入 以前获取当前控制器 cy# UIApp.keyWindow.rootViewController.presentedViewController cy# #0x1483cb600.childViewControllers mjcript获取当前控制器cy# MJFrontVc() cy# MJVcSubviews(#0x12fe775e0) 获取实例方法和类方法cy# MJInstanceMethods(#0x12fe775e0) cy# MJClassMethods(#0x12fe775e0) python获取unicode$ python >>> unicode('开始使用','UTF-8') u'\\u5f00\\u59cb\\u4f7f\\u7528' 获取网易登录界面cy# MJFrontVc() #\"&lt;NTESNBLoginController: 0x12fe775e0>\" cy# MJFrontVcSubViews(#0x12fe775e0) cy# [#0x12fe775e0.view addSubview:view] 获取login相关方法cy# MJInstanceMethods(#0x12fe775e0,/login/) [{selector:@selector(loginEngine),type:&amp;\"@16@0:8\"},{selector:@selector(loginBtnDidClicked:),type:&amp;\"v24@0:8@16\"},{selector:@selector(loginDelegate),type:&amp;\"@16@0:8\"},{selector:@selector(loginBottomSafeAreaHeight),type:&amp;\"d16@0:8\"},{selector:@selector(loginStyleDesc),type:&amp;\"@16@0:8\"}] 获取login相关成员变量cy# MJIvars(#0x12fe775e0,/login/) {_loginEngine:#\"&lt;NTESNBLoginEngine: 0x12fd390e0>\",_loginDelegate:#\"&lt;NTESNBLoginService: 0x12f024f50>\",_loginStyleDesc:#\"&lt;UILabel: 0x12fe78000; frame = (25 155; 80 22.5); text = '\\xe6\\x89\\x8b\\xe6\\x9c\\xba\\xe5\\x8f\\xb7\\xe7\\x99\\xbb\\xe5\\xbd\\x95'; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x12dff5b80>>\"} 4、Reveal安装与使用安装 当前的Cydia中软件源-http://apt.so/codermjlee已连接不上，直接下载Reveal2Loader_1.0-3的deb文件 网盘链接: 提取码: gk6j 下载后直接把deb文件放在手机的Device/var/root路径下 安装之前需要先Cydia中安装Applist和RocketBootstrap Cydia中安装ExtensionList 安装reveal2load报错extensionlist is not installed.:5s:~ root# dpkg -i Reveal2Loader_1.0-3_iphoneos-arm.deb (Reading database ... 3159 files and directories currently installed.) Preparing to unpack Reveal2Loader_1.0-3_iphoneos-arm.deb ... Unpacking reveal2loader (1.0-3) over (1.0-3) ... dpkg: dependency problems prevent configuration of reveal2loader: reveal2loader depends on com.zidaneno5.extensionlist; however: Package com.zidaneno5.extensionlist is not installed. dpkg: error processing package reveal2loader (--install): dependency problems - leaving unconfigured Errors were encountered while processing: reveal2loader 解决方法： Cydia搜索并安装ExtensionList 1.0-1 再次执行 dpkg -i Reveal2Loader_1.0-3_iphoneos-arm.deb 5s:~ root# dpkg -i Reveal2Loader_1.0-3_iphoneos-arm.deb (Reading database ... 3164 files and directories currently installed.) Preparing to unpack Reveal2Loader_1.0-3_iphoneos-arm.deb ... Unpacking reveal2loader (1.0-3) over (1.0-3) ... Setting up reveal2loader (1.0-3) ... done *The operation couldn’t be completed. * The app is linked against an older version of the Reveal library. You may need to update the Reveal library in your app. Reveal破解版不可用 如有破解版Reveal可参考：https://www.jianshu.com/p/f37ea9b9d2f3 5、脱壳5.1 通过ipa获取Mach-O PP助手下载的ipa包是解密后的包 Apple Configurator 2下载的ipa包是加密包 使用Apple Configurator 2下载ipa 1、安装Apple Configurator 2 2、进入Finder：~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/ 获取ipa，记得复制出来，弹框消失后IPA文件也会消失 3、如果在解压ipa包时，出现“IPA已损坏 移除到垃圾篓”之类的提示，可以尝试把后缀名.ipa修改成.zip 4、解压zip包-&gt;进入Payload-&gt; 右键显示包内容-&gt;获取可执行文件如下 4中获取的可执行文件不能正常导出头文件的话，直接查找越狱设备的一下路径： /var/mobile/Containers/Bundle/Application/可以获取当前越狱设备中安装的应用的.app文件，直接拷贝到Mac的Desktop上 ps -A查看当前App也能看到上面这个路径 5.2 Class-dump1、下载地址：http://stevenygard.com/projects/class-dump/ 2、打开终端输入 open /usr/local/bin 3、把dmg文件中的class-dump文件复制到/usr/local/bin 4、更改权限：终端输入 sudo chmod 777 /usr/local/bin/class-dump 5、显示class-dump的用法和版本: class-dump --help 6、cd 到5.1获取的Mach-O文件所在目录 用终端输入命令 class-dump -H [MachO文件的路径] -o [输出文件夹路径],就可以得到所有的.h文件了 自己编译的项目没有加密，能够解析出来。class-dump不能直接将AppStore上的app的头文件导出来，你只会导出CDStructures.h这个头文件，而这里边基本是没有信息的。相当于Apple在app上加了一层壳（加密了），需要把这层壳砸破。 class-dump -H test.decrypted -o test，但是只能导出CDStructures.h，这个文件，但是 于是就使用class-dump -arch armv64 -H test.decrypted -o test 来导出，竟然能导出所有的头文件了。 5.2查看可执行文件是否加密？使用MachOView Load Commands -&gt; LC_ENCRYPTION_INFO -&gt; Crypt ID的值 0代表未加密 使用otoolotool -l machoFile | grep cycript 5.3、Clutch脱壳/usr/bin/Clutch Permission denied5s:~ root# Clutch -sh: /usr/bin/Clutch: Permission denied 权限不够，输入命令如下： 5s:~ root# chmod +x /usr/bin/Clutch 5s:~ root# Clutch Usage: Clutch [OPTIONS] -b --binary-dump &lt;value> Only dump binary files from specified bundleID -d --dump &lt;value> Dump specified bundleID into .ipa file -i --print-installed Print installed applications --clean Clean /var/tmp/clutch directory --version Display version and exit -? --help Display this help and exit -n --no-color Print with colors disabled Clutch -i 查看可以脱壳的App5s:~ root# Clutch -i Installed apps: 1: 知识星球 &lt;com.unnoo.quan> 2: 爱思加强版 &lt;com.pd.A4Player> 3: 饿了么 &lt;me.ele.ios.eleme> 4: 暴走漫画 &lt;goodluck.push.baozou> 5: 喜马拉雅「听书社区」电台有声小说相声评书 &lt;com.gemd.iting> 6: 微视 &lt;com.tencent.microvision> 7: 猿辅导-小学初中高中全科在线互动直播课 &lt;com.fenbi.tutor> 8: 今日头条 &lt;com.ss.iphone.article.News> 9: 手机淘宝 &lt;com.taobao.taobao4iphone> 10: 爱奇艺 &lt;com.qiyi.iphone> 11: 全民K歌 &lt;com.tencent.QQKSong> 12: 钉钉 &lt;com.laiwang.DingTalk> 13: 书旗小说 &lt;com.shuqicenter.reader> 14: QQ &lt;com.tencent.mqq> 15: 快手极速版 &lt;com.kuaishou.nebula> 16: 腾讯新闻 &lt;com.tencent.info> 17: 京东 &lt;com.360buy.jdmobile> 18: 腾讯视频 &lt;com.tencent.live4iphone> 19: 微信读书 &lt;com.tencent.weread> 20: 布卡漫画 &lt;bukaios.ibuka.com> 21: 支付宝 &lt;com.alipay.iphoneclient> 22: 快手 &lt;com.jiangjia.gif> 23: 网易新闻 &lt;com.netease.news> 24: 抖音短视频 &lt;com.ss.iphone.ugc.Aweme> Cluth -d 获取ipa文件5s:~ root# Clutch -d 4 Zipping BaoManReader.app Swapping architectures.. ASLR slide: 0xd0000 Dumping &lt;BaoManReader> (armv7) Patched cryptid (32bit segment) Writing new checksum ASLR slide: 0x100038000 Dumping &lt;BaoManReader> (arm64) Patched cryptid (64bit segment) Writing new checksum DONE: /private/var/mobile/Documents/Dumped/goodluck.push.baozou-iOS8.0-(Clutch-2.0.4).ipa Finished dumping goodluck.push.baozou in 29.4 seconds 脱壳后生成IPA文件 IPA生成后的路径: /var/mobile/Documents/Dumped/拷贝到桌面上查看当前的加密状态 $ otool -l BaoManReader_old | grep crypt cryptoff 16384 cryptsize 10403840 cryptid 1 cryptoff 16384 cryptsize 11370496 cryptid 1 存在加密id $ otool -l BaoManReader | grep crypt cryptoff 16384 cryptsize 10403840 cryptid 0 cryptoff 16384 cryptsize 11370496 cryptid 0 不存在加密的id class-dump导出头文件headers$ class-dump -H BaoManReader -o Headers","categories":[],"tags":[]},{"title":"iOS汇编基础","slug":"iOS汇编基础","date":"2020-04-02T00:52:53.292Z","updated":"2020-04-08T15:24:58.246Z","comments":true,"path":"2020/04/02/iOS汇编基础/","link":"","permalink":"https://mingriweiji-github.github.io/2020/04/02/iOS%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/","excerpt":"","text":"iOS汇编基础x86_64汇编X84中原有8个32位通用寄存器%eax，%ebx，%ecx，%edx，%esi，%edi，%ebp，%esp, X86_64中分别被扩展为64位，并且多了8个寄存器。因此X86_64的寄存器如下： rax, eax, ax, ah, al; rbx, ebx, bx, bh, bl; rcx, ecx, cx, ch, cl; rdx, edx, dx, dh, dl; rsi, esi, si; rdi, edi, di; rbp, ebp; rsp, esp; r8-r15; GCC中对这些寄存器的调用规则如下： %rax 作为函数返回值使用。 %rsp 栈指针寄存器，指向栈顶 %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。 %rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改 %r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值 ARM处理器架构ARM现在的智能手机 ARM指令集 armv7｜armv7s｜arm64都是ARM处理器的指令集 v7iPhone3GS、iPhone4、iPhone4S v7siPhone5、iPhone5C arm64iPhone5S、iPhone6、iPhone6 Plus、iPhone6S、iPhone6S PlusiPhoneSE、iPhone7、iPhone7 Plus、iPhone8、iPhone8 Plus、iPhoneXiPad5、iPad Air、iPad Air2、iPad Pro、iPad Pro2iPad mini with Retina display、iPad mini3、iPad mini4iPod Touch6 i386｜x86_64 是Mac处理器的指令集 模拟器32位处理器测试需要i386架构， 模拟器64位处理器测试需要x86_64架构， 真机32位处理器需要armv7,或者armv7s架构， 真机64位处理器需要arm64架构。 编译错误真机编译错误: No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=x86_64, VALID_ARCHS=i386) 模拟器上编译错误：No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7s, VALID_ARCHS=armv7 armv6) iOS汇编教程 来自公主号：高级页面仔 1、ARM64汇编基础 2、在Xcode工程中嵌入汇编代码 3、汇编中的 Section 与数据存取 通过dylib实现iOS运行时Native代码注入 基于 Mach-O 符号重排减少缺页中断次数来提升 iOS App 启动速度的可行性分析 4、基于 LLDB 动态调试快速分析系统函数 5、Objc Block 的内存布局和汇编表示 6、CPU 指令重排与内存屏障 7、ARM Exclusive - 互斥锁与读写一致性的底层实现原理 8、Relocation - 静态库链接时是如何保证对变量的相对寻址依然正确的？ 9、在 ARC 下对非 ObjC 类型的指针进行操作的编译器陷阱","categories":[],"tags":[]},{"title":"Dyld源码阅读","slug":"Dyld源码阅读","date":"2020-04-01T03:31:34.664Z","updated":"2020-04-02T09:02:38.977Z","comments":true,"path":"2020/04/01/Dyld源码阅读/","link":"","permalink":"https://mingriweiji-github.github.io/2020/04/01/Dyld%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"Dyld源码阅读 Version：dyld-551.4 Lauange：C++ load()调用路径：3566行 load()-&gt;loadPhase0()-&gt;loadPhase1()-&gt;loadPhase2()-&gt;loadPhase4()-&gt;loadPhase5()打开或检查已经存在的动态库：dyld3::findInSharedCacheImage-&gt;loadPhase5load()-&gt;loadPhase5open()-&gt;loadPhase6()-&gt;加载3种Mach-O文件 1、动态库路径iOS越狱手机 在Mac\\iOS中，是使用了/usr/lib/dyld程序来加载动态库 UIKit路径：/system/Library/Frameworks/UIKit.framework 动态库共享缓存：/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64 0x00 load()ImageLoader* load(const char* path, const LoadContext&amp; context, unsigned&amp; cacheIndex) { // try all path permutations and check against existing loaded images ImageLoader* image = loadPhase0(path, orgPath, context, cacheIndex, NULL); if ( image != NULL ) { CRSetCrashLogMessage2(NULL); return image; } // try all path permutations and try open() until first success image = loadPhase0(path, orgPath, context, cacheIndex, &amp;exceptions); if ( image == NULL) image = loadPhase2cache(path, orgPath, context, cacheIndex, &amp;exceptions); #endif CRSetCrashLogMessage2(NULL); } 0x01 loadPhase2()0x02 loadPhase5loadPhase5load（）loadPhase5check（）// open or check existing static ImageLoader* loadPhase5(const char* path, const char* orgPath, const LoadContext&amp; context, unsigned&amp; cacheIndex, std::vector&lt;const char*>* exceptions) { // check for specific dylib overrides for (std::vector&lt;DylibOverride>::iterator it = sDylibOverrides.begin(); it != sDylibOverrides.end(); ++it) { if ( strcmp(it->installName, path) == 0 ) { path = it->override; break; } } if ( exceptions != NULL ) return loadPhase5load(path, orgPath, context, cacheIndex, exceptions); else return loadPhase5check(path, orgPath, context); } 0x03 findInSharedCacheImagestatic bool findInSharedCacheImage(const char* path, bool searchByPath, const struct stat* stat_buf, const macho_header** mh, const char** pathInCache, long* slide) { dyld3::SharedCacheFindDylibResults results; if ( dyld3::findInSharedCacheImage(sSharedCacheLoadInfo, path, &amp;results) ) { *mh = (macho_header*)results.mhInCache; *pathInCache = results.pathInCache; *slide = results.slideInCache; return true; } return false; } bool inSharedCache(const char* path) { return dyld3::pathIsInSharedCacheImage(sSharedCacheLoadInfo, path); } static int imageSorter(const void* l, const void* r) { const ImageLoader* left = *((ImageLoader**)l); const ImageLoader* right= *((ImageLoader**)r); return left->compare(right); } findInSharedCacheImage inSharedCache 0x04 Clang++编译dsc_extractor.cpp生成可执行文件dsc_extractor :$: clang++ -o dsc_extractor dsc_extractor.cpp 抽取动态共享缓存中的Mach-O$: cd xxx/com.apple.dyld $: ./dsc_extractor dyld_shared_cache_arm64 arm64_file dsc_extractor.cpp内容如下: // test program #include &lt;stdio.h> #include &lt;stddef.h> #include &lt;dlfcn.h> typedef int (*extractor_proc)(const char* shared_cache_file_path, const char* extraction_root_path, void (^progress)(unsigned current, unsigned total)); int main(int argc, const char* argv[]) { if ( argc != 3 ) { fprintf(stderr, \"usage: dsc_extractor &lt;path-to-cache-file> &lt;path-to-device-dir>\\n\"); return 1; } //void* handle = dlopen(\"/Volumes/my/src/dyld/build/Debug/dsc_extractor.bundle\", RTLD_LAZY); void* handle = dlopen(\"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle\", RTLD_LAZY); if ( handle == NULL ) { fprintf(stderr, \"dsc_extractor.bundle could not be loaded\\n\"); return 1; } extractor_proc proc = (extractor_proc)dlsym(handle, \"dyld_shared_cache_extract_dylibs_progress\"); if ( proc == NULL ) { fprintf(stderr, \"dsc_extractor.bundle did not have dyld_shared_cache_extract_dylibs_progress symbol\\n\"); return 1; } int result = (*proc)(argv[1], argv[2], ^(unsigned c, unsigned total) { printf(\"%d/%d\\n\", c, total); } ); fprintf(stderr, \"dyld_shared_cache_extract_dylibs_progress() => %d\\n\", result); return 0; } dyld加载流程 dyldStartup.s： call __dyld_start -&gt;call dyldbootstrap::start -&gt; dyldInitialization.cpp: call start()-&gt;_main()-&gt; dyld的start()方法：uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader, uintptr_t* startGlue) { // if kernel had to slide dyld, we need to fix up load sensitive locations // we have to do this before using any global variables if ( slide != 0 ) { rebaseDyld(dyldsMachHeader, slide); } // allow dyld to use mach messaging mach_init(); // kernel sets up env pointer to be just past end of agv array const char** envp = &amp;argv[argc+1]; // kernel sets up apple pointer to be just past end of envp array const char** apple = envp; while(*apple != NULL) { ++apple; } ++apple; // set up random value for stack canary __guard_setup(apple); #if DYLD_INITIALIZER_SUPPORT // run all C++ initializers inside dyld runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple); #endif // now that we are done bootstrapping dyld, call dyld's main uintptr_t appsSlide = slideOfMainExecutable(appsMachHeader); return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue); } dyld的main()方法uintptr_t _main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue) { //1、保存可执行文件header，后面可以根据header访问其他信息 uintptr_t result = 0; sMainExecutableMachHeader = mainExecutableMH; //2、设置上下文信息 setContext(mainExecutableMH, argc, argv, envp, apple); //3、获取可执行文件的路径 sExecPath = _simple_getenv(apple, \"executable_path\"); } 0x05反汇编 Hopper Disassembler [Xclient下载Hopper Disassembler](https://xclie nt.info/s/hopper-disassembler.html#versions) 2、Mach-O文件 Mac 内核xnu 工具：MachOView 来源：C/OC/Swift -&gt; .O目标文件-&gt;Mach-O可执行文件 查看Mac内核中的Mach-O: xnu-6153.11.26-&gt;EXTERNAL_HEADERS-&gt;mach-o 2.1 常见Mach-OMH_EXECUTE-可执行文件 .app/xxx MH_OBJECT-目标文件或静态库 目标文件(.o) 静态库文件(.a)-静态库其实就是多个.o的集合 MH_DYLIB-动态库文件 .dylib .framework/xxx MH_DYLIKER-动态链接编辑器 /usr/lib/dyld MH_DSYM:存储着二进制文件符号信息 .dSYM/Contents/Resources/DWARF/XXX 11种mach-o格式 #define MH_OBJECT 0x1 /* relocatable object file */ #define MH_EXECUTE 0x2 /* demand paged executable file */ #define MH_FVMLIB 0x3 /* fixed VM shared library file */ #define MH_CORE 0x4 /* core file */ #define MH_PRELOAD 0x5 /* preloaded executable file */ #define MH_DYLIB 0x6 /* dynamically bound shared library */ #define MH_DYLINKER 0x7 /* dynamic link editor */ #define MH_BUNDLE 0x8 /* dynamically bound bundle file */ #define MH_DYLIB_STUB 0x9 /* shared library stub for static */ /* linking only, no section contents */ #define MH_DSYM 0xa /* companion file with only debug */ /* sections */ #define MH_KEXT_BUNDLE 0xb /* x86_64 kexts */ Mach-o的作用 The layout of the file depends on the filetype. For all but the MH_OBJECT file type the segments are padded out and aligned on a segment alignment boundary for efficient demand pageing. The MH_EXECUTE, MH_FVMLIB, MH_DYLIB,MH_DYLINKER and MH_BUNDLE file types also have the headers included as part of their first segment. Mach-O的布局取决于文件类型。除了MH_OBJECT以外的所有的文件类型将分段填充并在分段对齐时-对齐有效请求分页的边界。 MH_EXECUTE，MH_FVMLIB，MH_DYLIB，MH_DYLINKER和MH_BUNDLE这些文件也有headers作为它们第一个segment。 The file type MH_OBJECT is a compact format intended as output of the assembler and input (and possibly output) of the link editor (the .oformat). All sections are in one unnamed segment with no segment padding. This format is used as an executable format when the file is so small the segment padding greatly increases its size. 文件类型MH_OBJECT是一种紧凑格式，旨在作为汇编器和链接编辑器（.o的输入）（可能是输出格式）。所有sections都在一个未命名的segment中，没有segment的填充。 当文件太小时segment填充可以大大增加了它的size。此格式用作可执行格式。 The file type MH_PRELOAD is an executable format intended for things that are not executed under the kernel (proms, stand alones, kernels, etc). The format can be executed under the kernel but may demand paged it and not preload it before execution. 文件类型MH_PRELOAD是一种可执行格式，用于非kernel内核下执行。（proms, stand alones, kernels, etc） 格式可以在内核下执行，但可能需要分页而不是在执行之前预加载它。 A core file is in MH_CORE format and can be any in an arbritray legal Mach-O file. Constants for the filetype field of the mach_header 核心文件为MH_CORE格式，可以是任意格式的Mach-O文件。mach_header的文件类型是常量 生成通用二进制文件：Architectures.hpp// // Architectures // struct x86 { typedef Pointer32&lt;LittleEndian> P; }; struct x86_64 { typedef Pointer64&lt;LittleEndian> P; }; struct arm { typedef Pointer32&lt;LittleEndian> P; }; struct arm64 { typedef Pointer64&lt;LittleEndian> P; }; Universal Binary 通用二进制文件，包含多种不同架构的二进制文件，比单个架构的文件大，也叫Fat Binary 由于执行过程中，只是调用一部分代码，所以运行起来也不需要额外的内存。 Xcode生成Universal BinaryStandard architectures $(ARCHS_STANDARD) dyld_cache_format.h#define IPHONE_DYLD_SHARED_CACHE_DIR \"/System/Library/Caches/com.apple.dyld/\" #define DYLD_SHARED_CACHE_BASE_NAME \"dyld_shared_cache_\" FileAbstraction.hpptemplate &lt;typename _E> class Pointer32 { public: typedef uint32_t uint_t; typedef _E E; static uint64_t getP(const uint_t&amp; from) INLINE { return _E::get32(from); } static void setP(uint_t&amp; into, uint64_t value) INLINE { _E::set32(into, (uint32_t)value); } // Round to a P-size boundary template &lt;typename T> static T round_up(T value) { return (value+3) &amp; ~(T)3; } template &lt;typename T> static T round_down(T value) { return value &amp; ~(T)3; } }; template &lt;typename _E> class Pointer64 { public: typedef uint64_t uint_t; typedef _E E; static uint64_t getP(const uint_t&amp; from) INLINE { return _E::get64(from); } static void setP(uint_t&amp; into, uint64_t value) INLINE { _E::set64(into, value); } // Round to a P-size boundary template &lt;typename T> static T round_up(T value) { return (value+7) &amp; ~(T)7; } template &lt;typename T> static T round_down(T value) { return value &amp; ~(T)7; } }; 3、dyld与Mach-O的关系 dyld属于MH_DYLDLINKER类型的Mach-O文件 dyld负责加载三种类型Mach-O文件 可执行文件 动态库 Bundle mach-o loader：only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded // try mach-o loader if ( shortPage ) throw \"file too short\"; if ( isCompatibleMachO(firstPages, path) ) { // only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded const mach_header* mh = (mach_header*)firstPages; switch ( mh->filetype ) { case MH_EXECUTE: case MH_DYLIB: case MH_BUNDLE: break; default: throw \"mach-o, but wrong filetype\"; } uint32_t headerAndLoadCommandsSize = sizeof(macho_header) + mh->sizeofcmds; if ( headerAndLoadCommandsSize > MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE ) throwf(\"malformed mach-o: load commands size (%u) > %u\", headerAndLoadCommandsSize, MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE); if ( headerAndLoadCommandsSize > fileLength ) dyld::throwf(\"malformed mach-o: load commands size (%u) > mach-o file size (%llu)\", headerAndLoadCommandsSize, fileLength); if ( headerAndLoadCommandsSize > 4096 ) { // read more pages unsigned readAmount = headerAndLoadCommandsSize - 4096; if ( pread(fd, &amp;firstPages[4096], readAmount, fileOffset+4096) != readAmount ) throwf(\"pread of extra load commands past 4KB failed: %d\", errno); } // instantiate an image ImageLoader* image = ImageLoaderMachO::instantiateFromFile(path, fd, firstPages, headerAndLoadCommandsSize, fileOffset, fileLength, stat_buf, gLinkContext); // validate return checkandAddImage(image, context); } 4、符号地址符号地址= 基地址 - 偏移地址 获取基地址//获取基地址 uintptr_t get_load_address(void) { const struct mach_header *exe_header = NULL; for (uint32_t i = 0; i &lt; _dyld_image_count(); i++) { const struct mach_header *header = _dyld_get_image_header(i); if (header->filetype == MH_EXECUTE) { exe_header = header; break; } } //返回值即为加载地址 return (uintptr_t)exe_header; } 获取偏移地址uintptr_t get_slide_address(void) { uintptr_t vmaddr_slide = NULL; for (uint32_t i = 0; i &lt; _dyld_image_count(); i++) { const struct mach_header *header = _dyld_get_image_header(i); if (header->filetype == MH_EXECUTE) { vmaddr_slide = _dyld_get_image_vmaddr_slide(i); break; } } return (uintptr_t)vmaddr_slide; } dSYM文件 编译时添加选项：DWARF with dSYM File，在编译打包完成之后就会生成调试符号文件（Mach-O文件） 文件查找：找到.xcarchive文件→show package contents→…一直到DWARF→工程二进制文件 atos命令有了dSYM文件，就可以使用atos命令查找到具体代码行出现奔溃信息的地方 atos [-o executable] [-l loadAddress] [-arch architecture] [address ...] #-arch 选择框架arm64/arm32/x86_64 4、Crash收集KSCrashSentryCocoa SentryCrashDynamicLinker","categories":[],"tags":[]},{"title":"Alamfire源码","slug":"Alamfire源码","date":"2020-03-24T17:57:02.623Z","updated":"2020-04-11T03:04:06.161Z","comments":true,"path":"2020/03/25/Alamfire源码/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/25/Alamfire%E6%BA%90%E7%A0%81/","excerpt":"","text":"Alamfire Github地址1、Request分析Request准守的Protocol Equatable Hashable CustomStringConvertible Downloadable UploadableConvertible Equatableextension Request: Equatable { public static func ==(lhs: Request, rhs: Request) -> Bool { return lhs.id == rhs.id } } Hashableextension Request: Hashable { public func hash(into hasher: inout Hasher) { hasher.combine(id) } } CustomStringConvertible extension Request: CustomStringConvertible { /// A textual representation of this instance, including the `HTTPMethod` and `URL` if the `URLRequest` has been /// created, as well as the response status code, if a response has been received. public var description: String { guard let request = performedRequests.last ?? lastRequest, let url = request.url, let method = request.httpMethod else { return \"No request created yet.\" } let requestDescription = \"\\(method) \\(url.absoluteString)\" return response.map { \"\\(requestDescription) (\\($0.statusCode))\" } ?? requestDescription } } Downloadable /// Type describing the source used to create the underlying `URLSessionDownloadTask`. public enum Downloadable { ​ /// Download should be started from the `URLRequest` produced by the associated `URLRequestConvertible` value. ​ case request(URLRequestConvertible) ​ /// Download should be started from the associated resume `Data` value. ​ case resumeData(Data) } UploadableConvertible/// A type that can produce an `UploadRequest.Uploadable` value. public protocol UploadableConvertible { /// Produces an `UploadRequest.Uploadable` value from the instance. /// /// - Returns: The `UploadRequest.Uploadable`. /// - Throws: Any `Error` produced during creation. func createUploadable() throws -> UploadRequest.Uploadable } extension UploadRequest.Uploadable: UploadableConvertible { public func createUploadable() throws -> UploadRequest.Uploadable { return self } } /// A type that can be converted to an upload, whether from an `UploadRequest.Uploadable` or `URLRequestConvertible`. public protocol UploadConvertible: UploadableConvertible &amp; URLRequestConvertible {} 初始化字段id: UUID为request提供唯一标识，用于hash、相等underlyingQueue: DispatchQueue 内部异步操作的串行队列serializationQueue: DispatchQueue 序列化使用的队列eventMonitor: EventMonitor? 事件监控interceptor: RequestInterceptor? 拦截器(重试器、适配器)delegate: RequestDelegate? Result定义State枚举public class Request { public enum State { case initialized //初始化 case resumed //恢复 case suspended //挂起 case cancelled // 取消 case finished //完成 func canTransitionTo(_ state: State) -> Bool { switch (self, state) { case (.initialized, _): return true case (_, .initialized), (.cancelled, _), (.finished, _): return false case (.resumed, .cancelled), (.suspended, .cancelled), (.resumed, .suspended), (.suspended, .resumed): return true case (.suspended, .suspended), (.resumed, .resumed): return false case (_, .finished): return true } } } // MARK: - Initial State // MARK: - Mutable State // MARK: Progress // MARK: Redirect Handling // MARK: Cached Response Handling // MARK: URLCredential // MARK: Validators // MARK: URLRequests // MARK: HTTPURLResponse // MARK: Tasks /// All `URLSessionTask`s created on behalf of the `Request`. public var tasks: [URLSessionTask] { return protectedMutableState.directValue.tasks } /// First `URLSessionTask` created on behalf of the `Request`. public var firstTask: URLSessionTask? { return tasks.first } /// Last `URLSessionTask` crated on behalf of the `Request`. public var lastTask: URLSessionTask? { return tasks.last } /// Current `URLSessionTask` created on behalf of the `Request`. public var task: URLSessionTask? { return lastTask } ///MARK: Metrics ///MARK: Retry Count public var retryCount: Int { return protectedMutableState.directValue.retryCount } ///MARK: Error public fileprivate(set) var error: AFError? { get { return protectedMutableState.directValue.error } set { protectedMutableState.write { $0.error = newValue } } } // MARK: - Internal Event API // All API must be called from underlyingQueue.(所有的API必须从底层队列调用) ... } Task相关: cancle/resume/suspend// MARK: Task Creation /// - Returns: The `URLSessionTask` created. func task(for request: URLRequest, using session: URLSession) -> URLSessionTask { fatalError(\"Subclasses must override.\") } // MARK: State @discardableResult public func cancel() -> Self { protectedMutableState.write { mutableState in guard mutableState.state.canTransitionTo(.cancelled) else { return } mutableState.state = .cancelled underlyingQueue.async { self.didCancel() } guard let task = mutableState.tasks.last, task.state != .completed else { underlyingQueue.async { self.finish() } return } // Resume to ensure metrics are gathered. task.resume() task.cancel() underlyingQueue.async { self.didCancelTask(task) } } return self } /// Suspends the instance. /// /// - Returns: The instance. @discardableResult public func suspend() -> Self { protectedMutableState.write { mutableState in guard mutableState.state.canTransitionTo(.suspended) else { return } mutableState.state = .suspended underlyingQueue.async { self.didSuspend() } guard let task = mutableState.tasks.last, task.state != .completed else { return } task.suspend() underlyingQueue.async { self.didSuspendTask(task) } } return self } /// Resumes the instance. /// /// - Returns: The instance. @discardableResult public func resume() -> Self { protectedMutableState.write { mutableState in guard mutableState.state.canTransitionTo(.resumed) else { return } mutableState.state = .resumed underlyingQueue.async { self.didResume() } guard let task = mutableState.tasks.last, task.state != .completed else { return } task.resume() underlyingQueue.async { self.didResumeTask(task) } } return self } State /// Protected `MutableState` value that provides thread-safe access to state values. fileprivate let protectedMutableState: Protector&lt;MutableState> = Protector(MutableState()) /// `State` of the `Request`. public var state: State { return protectedMutableState.directValue.state } /// Returns whether `state` is `.initialized`. public var isInitialized: Bool { return state == .initialized } /// Returns whether `state is `.resumed`. public var isResumed: Bool { return state == .resumed } /// Returns whether `state` is `.suspended`. public var isSuspended: Bool { return state == .suspended } /// Returns whether `state` is `.cancelled`. public var isCancelled: Bool { return state == .cancelled } /// Returns whether `state` is `.finished`. public var isFinished: Bool { return state == .finished } 可变状态MutableState通过结构体MutableState封装，包括进度、重定向、缓存、cURL、响应序列化、凭证、请求、task、metrics、重试次数、错误。 /// Protected `MutableState` value that provides thread-safe access to state values. fileprivate let protectedMutableState: Protector&lt;MutableState> = Protector(MutableState()) struct MutableState { /// State of the `Request`. var state: State = .initialized /// `ProgressHandler` and `DispatchQueue` provided for upload progress callbacks. var uploadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)? /// `ProgressHandler` and `DispatchQueue` provided for download progress callbacks. var downloadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)? /// `RedirectHandler` provided for to handle request redirection. var redirectHandler: RedirectHandler? /// `CachedResponseHandler` provided to handle response caching. var cachedResponseHandler: CachedResponseHandler? /// Closure called when the `Request` is able to create a cURL description of itself. var cURLHandler: ((String) -> Void)? /// Response serialization closures that handle response parsing. var responseSerializers: [() -> Void] = [] /// Response serialization completion closures executed once all response serializers are complete. var responseSerializerCompletions: [() -> Void] = [] /// Whether response serializer processing is finished. var responseSerializerProcessingFinished = false /// `URLCredential` used for authentication challenges. var credential: URLCredential? /// All `URLRequest`s created by Alamofire on behalf of the `Request`. var requests: [URLRequest] = [] /// All `URLSessionTask`s created by Alamofire on behalf of the `Request`. var tasks: [URLSessionTask] = [] /// All `URLSessionTaskMetrics` values gathered by Alamofire on behalf of the `Request`. Should correspond /// exactly the the `tasks` created. var metrics: [URLSessionTaskMetrics] = [] /// Number of times any retriers provided retried the `Request`. var retryCount = 0 /// Final `AFError` for the `Request`, whether from various internal Alamofire calls or as a result of a `task`. var error: AFError? } Redirects 如果多次设置重定向hander是逻辑错误的而且会引起crash 如果设置了redirect handler,当redirect response 响应的话，会使用到实例Request Cached Responses Sets the cached response handler for the Request which will be used when attempting to cache a response. Note: Attempting to set the cache handler more than once is a logic error and will crash. Clearup/// Final cleanup step executed when the instance finishes response serialization. func cleanup() { delegate?.cleanup(after: self) // No-op: override in subclass } DataRequest/// DataRequest是Request子类，使用URLSessionDataTask处理内存中下载的Data public class DataRequest: Request { } DownloadRequest/// `Request` subclass which downloads `Data` to a file on disk using `URLSessionDownloadTask`. /// DownloadRequest也是Request子类，使用URLSessionDownloadTask处理下载到硬盘中的Data。 public class DownloadRequest也是Request子类，使用: Request { } UploadRequest /// `DataRequest` subclass which handles `Data` upload from memory, file, or stream using `URLSessionUploadTask`. public class UploadRequest: DataRequest { /// Type describing the origin of the upload, whether `Data`, file, or stream. public enum Uploadable { ​ /// Upload from the provided `Data` value. ​ case data(Data) ​ /// Upload from the provided file `URL`, as well as a `Bool` determining whether the source file should be ​ /// automatically removed once uploaded. ​ case file(URL, shouldRemove: Bool) ​ /// Upload from the provided `InputStream`. ​ case stream(InputStream) } // MARK: **Initial State** /// The `UploadableConvertible` value used to produce the `Uploadable` value for this instance. public let upload: UploadableConvertible /// `FileManager` used to perform cleanup tasks, including the removal of multipart form encoded payloads written /// to disk. public let fileManager: FileManager // MARK: **Mutable State** /// `Uploadable` value used by the instance. public var uploadable: Uploadable? /// Creates an `UploadRequest` using the provided parameters. ...... 2、Session3、Result枚举/// Result.swift import Foundation public enum Result&lt;Value> { case success(Value) case failure(Error) /// Returns `true` if the result is a success, `false` otherwise. public var isSuccess: Bool { switch self { case .success: return true case .failure: return false } } /// Returns `true` if the result is a failure, `false` otherwise. public var isFailure: Bool { return !isSuccess } /// Returns the associated value if the result is a success, `nil` otherwise. public var value: Value? { switch self { case .success(let value): return value case .failure: return nil } } /// Returns the associated error value if the result is a failure, `nil` otherwise. public var error: Error? { switch self { case .success: return nil case .failure(let error): return error } } } // MARK: - CustomStringConvertible extension Result: CustomStringConvertible { /// The textual representation used when written to an output stream, which includes whether the result was a /// success or failure. public var description: String { switch self { case .success: return \"SUCCESS\" case .failure: return \"FAILURE\" } } } // MARK: - CustomDebugStringConvertible extension Result: CustomDebugStringConvertible { /// The debug textual representation used when written to an output stream, which includes whether the result was a /// success or failure in addition to the value or error. public var debugDescription: String { switch self { case .success(let value): return \"SUCCESS: \\(value)\" case .failure(let error): return \"FAILURE: \\(error)\" } } } public enum AFError: Error { /// The underlying reason the parameter encoding error occurred. /// /// - missingURL: The URL request did not have a URL to encode. /// - jsonEncodingFailed: JSON serialization failed with an underlying system error during the /// encoding process. /// - propertyListEncodingFailed: Property list serialization failed with an underlying system error during /// encoding process. public enum ParameterEncodingFailureReason { case missingURL case jsonEncodingFailed(error: Error) case propertyListEncodingFailed(error: Error) } /// The underlying reason the multipart encoding error occurred. public enum MultipartEncodingFailureReason { case bodyPartURLInvalid(url: URL) case bodyPartFilenameInvalid(in: URL) case bodyPartFileNotReachable(at: URL) case bodyPartFileNotReachableWithError(atURL: URL, error: Error) case bodyPartFileIsDirectory(at: URL) case bodyPartFileSizeNotAvailable(at: URL) case bodyPartFileSizeQueryFailedWithError(forURL: URL, error: Error) case bodyPartInputStreamCreationFailed(for: URL) case outputStreamCreationFailed(for: URL) case outputStreamFileAlreadyExists(at: URL) case outputStreamURLInvalid(url: URL) case outputStreamWriteFailed(error: Error) case inputStreamReadFailed(error: Error) } public enum ResponseValidationFailureReason { case dataFileNil case dataFileReadFailed(at: URL) case missingContentType(acceptableContentTypes: [String]) case unacceptableContentType(acceptableContentTypes: [String], responseContentType: String) case unacceptableStatusCode(code: Int) } public enum ResponseSerializationFailureReason { case inputDataNil case inputDataNilOrZeroLength case inputFileNil case inputFileReadFailed(at: URL) case stringSerializationFailed(encoding: String.Encoding) case jsonSerializationFailed(error: Error) case propertyListSerializationFailed(error: Error) } case invalidURL(url: URLConvertible) case parameterEncodingFailed(reason: ParameterEncodingFailureReason) case multipartEncodingFailed(reason: MultipartEncodingFailureReason) case responseValidationFailed(reason: ResponseValidationFailureReason) case responseSerializationFailed(reason: ResponseSerializationFailureReason) } JSONSerialization编解码class JSONSerialization : NSObject Overview您可以使用JSONSerialization类将JSON转换为Foundation对象，并将Foundation对象转换为JSON。 可能转换为JSON的Foundation对象必须具有以下属性： 顶级对象是[NSArray]（https://developer.apple.com/documentation/foundation/nsarray）或[`NSDictionary`]（https://developer.apple.com/documentation/foundation/ nsdictionary）。 所有对象都是NSString，NSNumber，NSArray，NSDictionary的实例 NSNull对象 所有字典的key都是NSString的实例。 不是NaN或无穷大的数字。 其他规则可能适用。如调用isValidJSONObject（_：）或尝试进行转换是确定给定对象是否可以转换为JSON的确定方法数据。 线程安全在iOS 7和更高版本以及macOS 10.9和更高版本上，JSONSerialization是线程安全的。 Creating a JSON Objectclass func jsonObject(with: Data, options: JSONSerialization.ReadingOptions) -&gt; Any Returns a Foundation object from given JSON data. class func jsonObject(with: InputStream, options: JSONSerialization.ReadingOptions) -&gt; Any Returns a Foundation object from JSON data in a given stream. Creating JSON Dataclass func data(withJSONObject: Any, options: JSONSerialization.WritingOptions) -&gt; Data Returns JSON data from a Foundation object. class func writeJSONObject(Any, to: OutputStream, options: JSONSerialization.WritingOptions, error: NSErrorPointer) -&gt; Int Writes a given JSON object to a stream. class func isValidJSONObject(Any) -&gt; Bool Returns a Boolean value that indicates whether a given object can be converted to JSON data. 拓展阅读AFNetwork姊妹篇URLSession全家桶AlamFire结构解析戴铭JSONDecoder","categories":[],"tags":[]},{"title":"Kingfisher源码","slug":"Kingfisher源码","date":"2020-03-24T09:41:47.374Z","updated":"2020-03-25T01:42:00.076Z","comments":true,"path":"2020/03/24/Kingfisher源码/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/24/Kingfisher%E6%BA%90%E7%A0%81/","excerpt":"","text":"Kingfisher源码Kingfisher3架构kf命名空间 类 Kingfisher 是一个范型类，类型是 Base 协议 KingfisherCompatible，声明属性 kf，类型是范型 CompatibleType 。并要求遵守协议的一方，实现该属性的 get 方法。 协议扩展中，协议自身实现了属性。这样就不必在每个遵守该协议的类里实现该属性了。 协议里的 kf 是一个 Kingfisher 类的实例，调用的方法是 Kingfisher 类的方法。 根据类型的不同，调用不同类型里的方法。如：对应 Image/ImageView / Button 的 Kingfisher 里的setImage 方法。 //Kingfisher.swift public final class Kingfisher&lt;Base> { public let base: Base public init(_ base: Base) { self.base = base } } /** A type that has Kingfisher extensions. */ public protocol KingfisherCompatible { associatedtype CompatibleType var kf: CompatibleType { get } } public extension KingfisherCompatible { public var kf: Kingfisher&lt;Self> { return Kingfisher(self) } } extension Image: KingfisherCompatible { } #if !os(watchOS) extension ImageView: KingfisherCompatible { } extension Button: KingfisherCompatible { } #else extension WKInterfaceImage: KingfisherCompatible { } #endif 1、weak var解决CADisplayLink循环引用为了防止AnimatedImageView 和 CADisplayLink 之间的循环引用，Kingfisher在AnimatedImageView 内部写了一个代理类。通过TargetProxy 来调用 AnimatedImageView 中的 updateFrame 方法 open class AnimatedImageView: UIImageView { /// Proxy object for prevending a reference cycle between the CADDisplayLink and AnimatedImageView. class TargetProxy { private weak var target: AnimatedImageView? init(target: AnimatedImageView) { self.target = target } @objc func onScreenUpdate() { target?.updateFrame() } } /// A display link that keeps calling the `updateFrame` method on every screen refresh. private lazy var displayLink: CADisplayLink = { self.isDisplayLinkInitialized = true let displayLink = CADisplayLink(target: TargetProxy(target: self), selector: #selector(TargetProxy.onScreenUpdate)) displayLink.add(to: .main, forMode: self.runLoopMode) displayLink.isPaused = true return displayLink }() } 2、处理Gif图片 // MARK: - Image format private struct ImageHeaderData { static var PNG: [UInt8] = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A] static var JPEG_SOI: [UInt8] = [0xFF, 0xD8] static var JPEG_IF: [UInt8] = [0xFF] static var GIF: [UInt8] = [0x47, 0x49, 0x46] } public enum ImageFormat { case unknown, PNG, JPEG, GIF } extension DataProxy { public var imageFormat: ImageFormat { var buffer = [UInt8](repeating: 0, count: 8) (base as NSData).getBytes(&amp;buffer, length: 8) if buffer == ImageHeaderData.PNG { return .PNG } else if buffer[0] == ImageHeaderData.JPEG_SOI[0] &amp;&amp; buffer[1] == ImageHeaderData.JPEG_SOI[1] &amp;&amp; buffer[2] == ImageHeaderData.JPEG_IF[0] { return .JPEG } else if buffer[0] == ImageHeaderData.GIF[0] &amp;&amp; buffer[1] == ImageHeaderData.GIF[1] &amp;&amp; buffer[2] == ImageHeaderData.GIF[2] { return .GIF } return .unknown } } 关联对象objc_setAssociatedObject private var animatedImageDataKey: Void? private var imageSourceKey: Void? // MARK: - Image Properties extension Kingfisher where Base: Image { fileprivate(set) var animatedImageData: Data? { get { return objc_getAssociatedObject(base, &amp;animatedImageDataKey) as? Data } set { objc_setAssociatedObject(base, &amp;animatedImageDataKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } fileprivate(set) var imageSource: ImageSource? { get { return objc_getAssociatedObject(base, &amp;imageSourceKey) as? ImageSource } set { objc_setAssociatedObject(base, &amp;imageSourceKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } } KingfisherManager原理 KingfisherManager 包含了downloader和cache 通过URL检索图片 获取图片retrieveImage /// Main manager class of Kingfisher. It connects Kingfisher downloader and cache. /// You can use this class to retrieve an image via a specified URL from web or cache. public class KingfisherManager { /// Shared manager used by the extensions across Kingfisher. public static let shared = KingfisherManager() /// Cache used by this manager public var cache: ImageCache /// Downloader used by this manager public var downloader: ImageDownloader fileprivate let processQueue: DispatchQueue convenience init() { self.init(downloader: .default, cache: .default) } init(downloader: ImageDownloader, cache: ImageCache) { self.downloader = downloader self.cache = cache let processQueueName = \"com.onevcat.Kingfisher.KingfisherManager.processQueue.\\(UUID().uuidString)\" processQueue = DispatchQueue(label: processQueueName, attributes: .concurrent) } /** Get an image with resource. If KingfisherOptions.None is used as `options`, Kingfisher will seek the image in memory and disk first. If not found, it will download the image at `resource.downloadURL` and cache it with `resource.cacheKey`. These default behaviors could be adjusted by passing different options. See `KingfisherOptions` for more. - parameter resource: Resource object contains information such as `cacheKey` and `downloadURL`. - parameter options: A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more. - parameter progressBlock: Called every time downloaded data changed. This could be used as a progress UI. - parameter completionHandler: Called when the whole retrieving process finished. - returns: A `RetrieveImageTask` task object. You can use this object to cancel the task. */ @discardableResult public func retrieveImage(with resource: Resource, options: KingfisherOptionsInfo?, progressBlock: DownloadProgressBlock?, completionHandler: CompletionHandler?) -> RetrieveImageTask { let task = RetrieveImageTask() let options = currentDefaultOptions + (options ?? KingfisherEmptyOptionsInfo) if options.forceRefresh { _ = downloadAndCacheImage( with: resource.downloadURL, forKey: resource.cacheKey, retrieveImageTask: task, progressBlock: progressBlock, completionHandler: completionHandler, options: options) } else { tryToRetrieveImageFromCache( forKey: resource.cacheKey, with: resource.downloadURL, retrieveImageTask: task, progressBlock: progressBlock, completionHandler: completionHandler, options: options) } return task } }","categories":[],"tags":[]},{"title":"一颗太阳","slug":"一颗太阳","date":"2020-03-18T06:44:02.192Z","updated":"2020-03-18T06:44:02.192Z","comments":true,"path":"2020/03/18/一颗太阳/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/18/%E4%B8%80%E9%A2%97%E5%A4%AA%E9%98%B3/","excerpt":"","text":"激情岁月 一颗太阳一千颗太阳1967年6月17日","categories":[],"tags":[]},{"title":"排序问题","slug":"排序问题","date":"2020-03-15T04:37:17.863Z","updated":"2020-03-17T01:55:57.693Z","comments":true,"path":"2020/03/15/排序问题/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/15/%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"带着问题去学习，是最有效的学习方法。所以按照惯例，我还是先给你出一个思考题： 问题一：为什么插入排序比冒泡排序更受欢迎？如何分析一个“排序算法”？ 最好情况、最坏情况、平均情况时间复杂度 时间复杂度的系数、常数、低阶 比较次数和交换次数 内存消耗 原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。(冒泡排序、插入排序) 稳定性 经过某种排序算法排序之后，如果两个相同数值的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法； 如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。 1、冒泡排序 冒泡排序只会操作相邻元素的两个数据 每次都是对相邻的两个元素比较大小，前面的元素大于后面的元素，交换前后元素，一轮循环后最后元素就是最大元素 第二轮循环后，倒数第二个元素就是第二大元素 直到所有元素都是有序的停止排序 冒泡排序图示： /// 冒泡排序 func bubbleSort&lt;T>(_ array: [T]) -> [T] where T: Comparable{ var array = array guard array.count > 1 else { return array } for i in 0..&lt;array.count { //提前退出标志 var flag: Bool = false for j in 0..&lt;array.count - i - 1 { if array[j] > array[j + 1] { array.swapAt(j + 1, j) //有数据交换 flag = true } } //没有数据交换-提前退出 if flag == false { break } } return array } 现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。 第一，冒泡排序是原地排序算法吗？冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。 第二，冒泡排序是稳定的排序算法吗？在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。 第三，冒泡排序的时间复杂度是多少？最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。平均时间复杂度也是O(n2) 2、插入排序 插入排序是将数组分成两个部分，已排序和未排序 初始化已排序部分只有一个元素就是数组第一个元素 插入排序的核心思想就是取出未排序部分的元素，在已排序区间中找到合适的插入位置插入，保证已排序区间的数据一直是有序的。 插入排序如下图： ///插入排序 func insertSort&lt;T>(_ elements: [T]) -> [T] where T: Comparable { var array = elements guard array.count > 1 else { return array } for i in 1..&lt;array.count { let value = array[i] var j = i - 1 //查找要插入的位置 for p in (0...j).reversed() { if array[p] > value { array[p+1] = array[p]//移动数据 } else { break } } array[j+1] = value// 插入数据 } return array } 插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。 对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度 = 满有序度-初始有序度。 现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。 第一，插入排序是原地排序算法吗？插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。 第二，插入排序是稳定的排序算法吗？在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。 第三，插入排序的时间复杂度是多少？ 如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。 如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。 还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n2)。 3、选择排序（Selection Sort）选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。 第一，选择排序是原地排序算法吗？选择排序的时间复杂度是O(1)所以是原地排序 第二，选择排序是稳定的排序算法吗？不是稳定排序，对于选择排序来说每次都是从未排序序列中找到最小的插入到已排序序列的末尾处，和前面的元素交换，这样会破坏稳定性 比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。\\ 第三，选择排序的时间复杂度是多少？选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。 总结三种时间复杂度是 O(n2) 的排序算法 这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高，所以我们更倾向于用下一节要讲的时间复杂度为 O(nlogn) 的排序算法。 问题二：如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素?1、归并排序 归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。 归并排序的核心是合并：依次合并N个堆得数据 1、在合并时，您需要两个索引来跟踪两个数组的进度。 2、这是合并后的数组。 它现在是空的，但是你将在下面的步骤中通过添加其他数组中的元素构建它。 3、这个while循环将比较左侧和右侧的元素，并将它们添加到orderedPile，同时确保结果保持有序。 4、如果前一个while循环完成，则意味着leftPile或rightPile中的一个的内容已经完全合并到orderedPile中。此时，您不再需要进行比较。只需依次添加剩下一个数组的其余内容到orderedPile。 归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。 从我刚才的描述，你有没有感觉到，分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。 所以归并排序的核心就是递归写法： 递推公式： merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r)) 终止条件： p &gt;= r 不用再继续分解 有了递推公式，转化成代码就简单多了: func merge(_ leftArray: [Int], _ rightArray: [Int]) -> [Int] { //1 var l = 0, r = 0 //2 var mergeArr: [Int] = [] //3 while l &lt; leftArray.count &amp;&amp; r &lt; rightArray.count { if leftArray[l] > rightArray[r] { mergeArr.append(rightArray[r]) r += 1 } else if leftArray[l] &lt; rightArray[r] { mergeArr.append(leftArray[l]) l += 1 } else { mergeArr.append(leftArray[l]) l += 1 mergeArr.append(rightArray[r]) r += 1 } } //4 while l &lt; leftArray.count { mergeArr.append(leftArray[l]) l += 1 } while r &lt; rightArray.count { mergeArr.append(rightArray[r]) r += 1 } return mergeArr } /* 1、如果数组为空或包含单个元素，则无法将其拆分为更小的部分，返回数组就行。 2、找到中间索引。 3、使用上一步中的中间索引，递归地分割数组的左侧。 4、递归地分割数组的右侧。 5、最后，将所有值合并在一起，确保它始终排序。 */ func mergeSort(_ array: Array&lt;Int>) -> Array&lt;Int> { //1 guard array.count > 1 else { return array } //2 let middle = array.count / 2 //3 let leftPart = mergeSort(Array(array[0..&lt;middle])) //4 let rightPart = mergeSort(Array(array[middle..&lt;array.count])) //5 return merge(leftPart, rightPart) } 2、快速排序快速排序是原地排序，也是递归实现，但快速排序不是稳定排序 归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。 快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。 快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。 我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。 直接递归： 1、设置中间位置元素为轴点元素pivot 2、分区：less equal more 3、递归合并分区 func quickSort&lt;T: Comparable>(_ array: [T]) -> [T]{ let pivot = array[array.count / 2] let less = array.filter { $0 &lt; pivot } let equal = array.filter { $0 == pivot } let more = array.filter { $0 > pivot } return quickSort(less) + equal + quickSort(more) } /* 1、从序列中选择中轴点pivot（假设选择位置为0的元素） 2、利用pivot中轴点把序列分成两个子序列 3、分别对左右子序列递归进行快速排序，直到元素不能分割位置 快速排序的本质是把每一个元素都转换成中轴点。 */ public func quickSortDutch&lt;T: Comparable>(_ a: inout [T], low: Int, high: Int) { if low &lt; high { let pivot = Int.random(in: low...high) let (p, q) = partationDutch(&amp;a, low: low, high: high, pivotIndex: pivot) quickSortDutch(&amp;a, low: low, high: p - 1) quickSortDutch(&amp;a, low: q + 1, high: high) } } Lomuto分区 Vs Hoare分区 Vs 荷兰国旗分区 Lomuto分区法:是用数组最后一个元素作为基准元素对数组分区，区域为[low…p-1] [p+1…high]，然后递归调用quickLomutoSort分别对左右区排序，一直到数组有序 Hoare分区：选择数组的first元素作为基准，数组划分区域为[low…p] [p+1…high]，然后递归调用quickSortHoare分别对左右区排序，一直到数组有序 /* 3 荷兰国旗分区：将前部和后部各排在数组的前边和后边，中部自然就排好了,分区函数返回(p, q) 设置两个标志位begin和end分别指向这个数组的开始和末尾，然后用一个标志位current从头开始进行遍历： 1）若遍历到的current &lt; pivot，于是就和begin位置进行交换，然后current向前进，begin也向前进（表示前边的已经都排好了）。 2）若遍历到current == pivot，则说明它一定属于中部，根据总思路，中部的我们都不动，然后current向前进。 3）若遍历到current > pivot，则说明它一定属于后部，于是就和end位置进行交换， 由于交换完毕后current指向的可能是属于前部的，若此时current前进则会导致该位置不能被交换到前部，所以此时current不前进。 end向后退1。 4) 返回分区（begin, end） */ func partationDutch&lt;T: Comparable>(_ a: inout [T], low: Int, high: Int, pivotIndex: Int) -> (Int, Int) { var begin = low, end = high var current = low, pivot = a[pivotIndex] while current &lt;= end { if a[current] &lt; pivot { a.swapAt(begin, current) begin += 1 current += 1 } else if a[current] == pivot { current += 1 } else { a.swapAt(current, end) end -= 1 } } return (begin, end) } 解答问题二： 快排核心思想就是分治和分区，我们可以利用分区的思想，来解答开这个问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。 我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。 如果 p+1=K，那 A[p]就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1]区间查找。 本文参考：王争-数据结构与算法之美","categories":[],"tags":[]},{"title":"反转问题","slug":"反转问题","date":"2020-03-15T03:35:25.039Z","updated":"2020-03-15T04:25:50.290Z","comments":true,"path":"2020/03/15/反转问题/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/15/%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98/","excerpt":"","text":"字符串反转方法一：递归 原地反转字符串是否代表了空间复杂度为常数？不，原地反转字符串是一种不使用辅助数据结构的算法。 我们使用递归的方法去反转字符串，它是原地反转，但是空间复杂度却不是常数级空间，因为递归过程中使用了堆栈空间。 算法过程 我们实现递归函数 helper，它接受两个参数：left 左指针和 right 右指针。 如果 left&gt;=right，不做任何操作。 否则交换 s[left] 和 s[right] 和调用 helper(left + 1, right - 1)。 首次调用函数我们传递首尾指针反转整个字符串 return helper(0, len(s) - 1)。 public void helper(char[] s, int left, int right) { if (left >= right) return; char tmp = s[left]; s[left++] = s[right]; s[right--] = tmp; helper(s, left, right); } public void reverseString(char[] s) { helper(s, 0, s.length - 1); } 复杂度分析时间复杂度：\\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。 空间复杂度：\\mathcal{O}(N)O(N)，递归过程中使用的堆栈空间。 方法二：双指针法双指针法是使用两个指针，一个左指针 left，右指针 right，开始工作时 left 指向首元素，right 指向尾元素。交换两个指针指向的元素，并向中间移动，直到两个指针相遇。 算法过程 将 left 指向首元素，right 指向尾元素。 当 left&lt;right： 交换 s[left] 和 s[right]。 left++ right++ // 双指针 func reverseStr(_ s: inout [Character]) -> [Character]{ var left = 0, right = s.count - 1 while left &lt; right { (s[left],s[right]) = (s[right],s[left]) left += 1 right -= 1 } return s } 测试用例let str = \"123456abcdef\" var characters = Array(str) print(characters)//[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] print(reverseStr(&amp;characters))//[\"f\", \"e\", \"d\", \"c\", \"b\", \"a\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"] 复杂度分析时间复杂度：\\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。空间复杂度：\\mathcal{O}(1)O(1)，只使用了常数级空间。 反转链表双指针法 定义两个指针pre cur : pre在前 cur 在后 如果cur节点不为空，设置pre.next = cur 实现一次翻转 翻转后pre 、cur同步向前一步 当pre为空终止循环 func reverseList(_ head: ListNode?) -> ListNode? { if head == nil || head?.next == nil { return head } var pre = head, cur: ListNode? while pre != nil { let temp = pre?.next pre?.next = cur cur = pre! pre = temp } return cur } 递归法核心：reversList(head) = reverseList(head.next) func reverseList2(_ head: ListNode?) -> ListNode? { if head == nil || head?.next == nil { return nil } let newHead = reverseList2(head?.next) head?.next?.next = head head?.next = nil return newHead } 反转链表 II题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明:1 ≤ m ≤ n ≤ 链表长度 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL题解思路 第一步：找到待反转节点的前一个节点。第二步：反转m到n这部分。第三步：将反转的起点的next指向反转的后面一部分。第四步：将第一步找到的节点指向反转以后的头节点。 public ListNode reverseBetween(ListNode head, int m, int n) { ListNode res = new ListNode(0); res.next = head; ListNode node = res; //找到需要反转的那一段的上一个节点。 for (int i = 1; i &lt; m; i++) { node = node.next; } //node.next就是需要反转的这段的起点。 ListNode nextHead = node.next; ListNode next = null; ListNode pre = null; //反转m到n这一段 for (int i = m; i &lt;= n; i++) { next = nextHead.next; nextHead.next = pre; pre = nextHead; nextHead = next; } //将反转的起点的next指向next。 node.next.next = next; //需要反转的那一段的上一个节点的next节点指向反转后链表的头结点 node.next = pre; return res.next; }","categories":[],"tags":[]},{"title":"智力题","slug":"智力题","date":"2020-03-15T02:44:43.844Z","updated":"2020-03-15T03:31:45.729Z","comments":true,"path":"2020/03/15/智力题/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/15/%E6%99%BA%E5%8A%9B%E9%A2%98/","excerpt":"","text":"智力题1、有两个水桶， 一个装 3L 的水， 一个可装 5L 的水， 问:如何利用这两个桶， 量出 4L 的水来？解法一加法：操作两次3L的桶，得到1L的水，然后倒入5L的桶里面，此时5L桶里有1L的水，再次用3L的桶倒入5L桶，1L+ 3L = 4L,一共操作3次3L桶 加法解法图示： 解法二减法：5L满水的桶倒入3L的桶，剩余2L，5L桶剩余的2L再次倒入3L桶，此时3L桶还有1L集满，5L桶再次装满后倒出来1L给3L桶里面，5L - 1L = 4L,连续操作3次5L桶 减法解法图示： 2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？首先2的6次方64，2的7次方128 &gt; 100因此我们可以用7个的二进制给100个瓶子编号，7只老鼠分别对应7个二进制位，如果瓶子编号出现1，老鼠喝下瓶子中的毒药，最后统计出被毒死老鼠的二进制数，转换为10进制就是有毒瓶子的编号。 解法图示：","categories":[],"tags":[]},{"title":"Runloop","slug":"Runloop","date":"2020-03-11T13:16:28.012Z","updated":"2020-03-13T17:26:08.484Z","comments":true,"path":"2020/03/11/Runloop/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/11/Runloop/","excerpt":"","text":"Runloop1.讲讲 RunLoop，项目中有用到吗？ 事件循环，在程序运行中循环做一些事情 没有消息mach_msg()切换用户态到内核态线程休眠，有消息内核态切换到用户态 runloop相关： Timer、performSelector GCD、AutoreleasePool 事件响应、收拾识别、网络请求 runloop的应用： 线程包活 解决timer滑动停止问题 监听主线程卡顿 性能优化 2.runloop的6种状态和runloop内部实现逻辑？/* Run Loop Observer Activities */ typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出Loop kCFRunLoopAllActivities = 0x0FFFFFFFU }; source0 : 触摸事件、performSelectorOnThread: source1: 基于Port的线程间通讯，捕获到的系统事件 timers: NSTimer + performSelector:afterDelay: observers: 监听runloop的状态/autoreleasePool的创建和释放、UI的刷新 3.runloop和线程的关系？ 一一对应 保存在一个全局字典中，线程是key, runloop是value 子线程默认没有runloop，在第一次获取runloop时才会创建。 runloop在线程结束时销毁 4.timer 与 runloop 的关系？程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？5.runloop 是怎么响应用户操作的， 具体流程是什么样的？6.说说runLoop的几种状态7.runloop的mode作用是什么？ CFRunLoopModeRef代表RunLoop的运行模式 一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer RunLoop启动时只能选择其中一个Mode，作为currentMode 如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入 不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响 如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出 8.KVO实现原理?哪些情况下使用kvo会崩溃，怎么防护崩溃?9.如何手动关闭KVO?如何手动自己实现KVO说说思路10.通过KVC修改属性会触发KVO么","categories":[],"tags":[]},{"title":"iOS多线程","slug":"iOS多线程","date":"2020-03-11T12:34:15.299Z","updated":"2020-03-26T03:40:12.723Z","comments":true,"path":"2020/03/11/iOS多线程/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/11/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"深入理解GCDdispatch_async 会把任务添加到队列的一个链表中，添加完后会唤醒队列，根据 vtable 中的函数指针，调用 wakeup 方法。 在 wakeup 方法中，从线程池里取出工作线程(如果没有就新建)，然后在工作线程中取出链表头部指向的 block 并执行。 dispatch_sync 的实现略简单一些，它不涉及线程池(因此一般都在当前线程执行)，而是利用与线程绑定的信号量来实现串行。 分发到不同队列时，代码进入的分支也不一样，比如 dispatch_async 到主队列的任务由 runloop 处理，而分发到其他队列的任务由线程池处理。 在当前串行队列中执行 dispatch_sync 时，由于 dq_running 属性(表示在运行的任务数量) 为 1，所以以下判断成立: if (slowpath(!dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1))) { return _dispatch_barrier_sync_f_slow(dq, ctxt, func); } 在 _dispatch_barrier_sync_f_slow 函数中使用了线程对应的信号量并且调用 wait 方法，从而导致线程死锁。 如果向其它队列同步提交 block，最终进入 _dispatch_barrier_sync_f_invoke，它只是保证了 block 执行的原子性，但没有使用线程对应的信号量。 对于信号量来说，它主要使用 signal 和 wait 这两个接口，底层分别调用了内核提供的方法。 在调用 wait 方法后，先将 value 减一，如果大于零立刻返回，否则陷入等待。signal 方法将信号量加一，如果 value 大于零立刻返回，否则说明唤醒了某一个等待线程，此时由系统决定哪个线程的等待方法可以返回。 dispatch_group 的本质就是一个 value 非常大的信号量，等待 group 完成实际上就是等待 value 恢复初始值。而 notify 的作用是将所有注册的回调组装成一个链表，在 dispatch_async 完成时判断 value 是不是恢复初始值，如果是则调用 dispatch_async 异步执行所有注册的回调。 dispatch_once 通过一个静态变量来标记 block 是否已被执行，同时使用信号量确保只有一个线程能执行，执行完 block 后会唤醒其他所有等待的线程。 dispatch_barrier_async 改变了 block 的 vtable 标记位，当它将要被取出执行时，会等待前面的 block 都执行完，然后在下一次循环中被执行。 dispatch_source 可以用来实现定时器。 所有的 source 会被提交到用户指定的队列，然后提交到 manager 队列中，按照触发时间排好序。 随后找到最近触发的定时器，调用内核的 select 方法等待。 等待结束后，依次唤醒 manager 队列和用户指定队列，最终触发一开始设置的回调 block。 GCD 中的对象用 do_suspend_cnt 来表示是否暂停。队列默认处于启动状态，而 dispatch_source 需要手动启动。 dispatch_after 函数依赖于 dispatch_source 定时器，它只是注册了一个定时器，然后在回调函数中执行 block。 GCD死锁案例分析 NSOperation案例分析 深入理解iOS开发中的锁 自旋锁的目的是为了确保临界区只有一个线程可以访问bool lock = false; // 一开始没有锁上，任何线程都可以申请锁 do { while(test_and_set(&lock); // test_and_set 是一个原子操作 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码 } 显然在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。 如果临界区的执行时间过长，使用自旋锁不是个好主意 信号量 首先会把信号量的值减一，并判断是否大于零。 如果大于零，说明不用等待，所以立刻返回。小于0等待signal唤醒线程 pthread_mutex互斥锁 互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。 pthread_mutexattr_t attr; pthread_mutexattr_init(&attr); pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL); // 定义锁的属性 pthread_mutex_t mutex; pthread_mutex_init(&mutex, &attr) // 创建锁 pthread_mutex_lock(&mutex); // 申请锁 // 临界区 pthread_mutex_unlock(&mutex); // 释放锁 一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。 假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。 然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。 NSLock NSLock 只是在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。 NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。 NSCondition NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。 条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程**，并等待某个数据就绪，随后唤醒线程**，比如常见的生产者-消费者模式。 NSCondition 其实是封装了一个互斥锁和条件变量， 它把前者的 lock 方法和后者的 wait/signal 统一在 NSCondition 对象中，暴露给使用者 它的加解锁过程与 NSLock 几乎一致，理论上来说耗时也应该一样(实际测试也是如此)。在图中显示它耗时略长，我猜测有可能是测试者在每次加解锁的前后还附带了变量的初始化和销毁操作。 NSRecursiveLock 递归锁也是通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器加一，锁的释放过程也是同理。 使用递归锁NSRecursiveLock NSLock *lock = [[NSLock alloc] init]; dispatch_async(dispatch_get_global_queue(0, 0), ^{ static void (^RecursiveMethod)(int); RecursiveMethod = ^(int value) { [lock lock];//递归调用时失败，NSLock不能被同一线程多次获取，多次获取使用NSRecursiveLock if (value > 0) { NSLog(@\"value = %d\", value); sleep(2); RecursiveMethod(value - 1); } [lock unlock]; }; RecursiveMethod(5); }); @synchronized这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。 你调用 sychronized 的每个对象，runtime 都会为其分配一个递归锁并存储在哈希表中。 如果在 sychronized 内部对象被释放或被设为 nil 看起来都 OK。不过这没在文档中说明，所以我不会再生产代码中依赖这条。 注意不要向你的 sychronized block 传入 nil！这将会从代码中移走线程安全。你可以通过在 objc_sync_nil 上加断点来查看是否发生了这样的事情。 1、你理解的多线程？并发和串行，同步和异步 同步和异步的区别: 是否开辟新的线程，同步只能在当前线程执行任务，异步可以再新的线程执行任务 串行和并发的区别:是任务执行的顺序，串行任务只能顺序执行，并发可以多个任务同时执行。 2、iOS多线程有哪些？常用哪个？ NSThread、GCD/NSOperationQueue 常用GCD/NSOperation 3、GCD 的队列类型有哪些？GCD的队列可以分为2大类型 并发队列（Concurrent Dispatch Queue） 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务） 并发功能只有在异步（dispatch_async）函数下才有效 串行队列（Serial Dispatch Queue） 让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务） 4、OperationQueue 和 GCD 的区别？ GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择； 在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)； NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行； 我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样子能比GCD更加有效地掌控我们执行的后台任务； 在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码； 我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。 总的来说，Operation queue 提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。 从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。 5、线程安全是什么？如何处理线程安全的问题？ 我们一般通过线程同步方案如加锁的方式来实现线程的安全 iOS锁的原理 | 深入浅出iOS系统内核-同步机制 os_unfair_lock：iOS10开始os_unfair_lock来替代OSSpinLock, 等待锁的线程会进入休眠不占用CPU资源， 这个os_unfair_lock解决了优先级翻转问题。 OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等一直占用着CPU资源 dispatch_semaphore：信号量为1的semaphore也可以看做是锁 pthread_mutex：跨平台的互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。 使用GCD的串行队列也可以实现锁的功能 NSLock是对metex互斥锁的封装，NSRecurisiveLock也是对metex的递归封装，API和NSLock一直。 NSCondition NSConditionLock @synchorized也是mutex的递归封装，@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作。 6、自旋锁和互斥锁如何选择？自旋锁OSSpinLock：当线程获取锁，其他等待锁的线程会忙等一直占用CPU,自旋锁有优先级翻转的可能性，所以苹果已经弃用自旋锁OSSpinLock改用os_unfair_lock. 互斥锁mutext：阻塞线程并休眠，其他线程才能正常访问，用互斥的方式来保证线程的安全。 递归锁：顾名思义，可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。 什么情况使用自旋锁比较划算？ 预计线程等待锁的时间很短 竞争情况很少发生，加锁的代码（临界区）经常被调用 CPU资源不紧张 多核处理器 什么情况使用互斥锁比较划算？ 预计线程等待锁的时间较长 临界区代码复杂或者循环量大 临界区竞争非常激烈 单核处理器 临界区有IO操作 追问二：使用以上锁需要注意哪些？ 追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！ 7、iOS线程同步方案性能比较性能从高到低排序: os_unfair_lock &gt; OSSpinLock &gt; dispatch_semaphore &gt; pthread_mutex &gt; dispatch_queue(DISPATCH_QUEUE_SERIAL) &gt; NSLock &gt; NSCondition &gt; pthread_mutex(recursive) &gt; NSRecursiveLock &gt; NSConditionLock &gt; @synchronized**8、如何用gcd实现并发执行1和2再执行任务3的方案？ 异步并发执行任务1、任务2 等任务1、任务2都执行完毕后，再回到主线程执行任务3 dispatch_group_notifydispatch_barrier_asyncdispatch_sempher(2) let group = DispatchGroup() let queue = DispatchQueue.init(label: \"handleAPIQueue\") group.enter() queue.async { print(\"任务1完成\") group.leave() } group.enter() queue.async { DispatchQueue.main.asyncAfter(deadline: .now() + 3) { print(\"任务2完成\") group.leave() //注意leave的位置必须在任务完成后 } } //group.leave() //如果leave放在这里的话，notify不会等待任务2完成就会触发 group.enter() queue.async { print(\"任务3完成\") group.leave() } group.notify(queue: queue) { print(\"所有任务都完成了\") } 网络请求应用实例 9、如何实现多度单写？dispatch_barrier_async 这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的 如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果 dispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.queue.concurrent\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(concurrentQueue, ^{ NSLog(@\"async_1\"); }); dispatch_async(concurrentQueue, ^{ NSLog(@\"async_2\"); }); dispatch_async(concurrentQueue, ^{ NSLog(@\"async_3\"); }); dispatch_barrier_async(concurrentQueue, ^{//dispatch_barrier_sync效果相同 NSLog(@\"dispatch_barrier_async\"); }); dispatch_async(concurrentQueue, ^{ NSLog(@\"async_4\"); }); /* 01-OC底层[25009:1007376] async_1 01-OC底层[25009:1007372] async_3 01-OC底层[25009:1007374] async_2 01-OC底层[25009:1007372] dispatch_barrier_async 01-OC底层[25009:1007372] async_4 */ 10、GCD实现暂停和继续注意什么？ dispatch_queue_t conQueue = dispatch_queue_create(\"com.seria.queue\", DISPATCH_QUEUE_CONCURRENT); size_t count = 5; dispatch_apply(5, conQueue, ^(size_t index) { NSLog(@\"numer is %zu\",index); if (index == 2) { // dispatch_suspend(concurrentQueue);// suspend并不能停止当前队列的任务，只能停止后面队列中的任务 } }); dispatch_suspend(conQueue); // dispatch_suspend 不能单独使用，和dispatch_resume配对使用 NSLog(@\"task1---\"); dispatch_async(conQueue, ^{ NSLog(@\"async1\"); }); NSLog(@\"task2---\"); dispatch_resume(conQueue); dispatch_async(conQueue, ^{ NSLog(@\"async2\"); }); NSLog(@\"task3---\"); 11、案例分析使用 Dispatch Source定时器Dispatch Source Timer利用 Dispatch Source 的 DISPATCH_SOURCE_TYPE_TIMER 类型，我们可以创建一个 跨线程的 定时器（我们平时使用的 NSTimer 是基于 Run Loop 的 timer 事件，只能在对应的线程里触发） dispatch_queue_t queue = dispatch_get_main_queue(); //1、创建一个 timer； self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); //2、配置 timer，从现在起，每两秒在主线程触发一次，精度为0s dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC, 0 * NSEC_PER_SEC); //3、timer 触发之后的回调 block dispatch_source_set_event_handler(self.timer, ^{ NSLog(@\"%ld\", self.count++); }); //4、启动 timer dispatch_resume(self.time);","categories":[],"tags":[]},{"title":"红黑树前世今生","slug":"红黑树前世今生","date":"2019-12-30T07:28:54.939Z","updated":"2019-12-30T07:28:54.939Z","comments":true,"path":"2019/12/30/红黑树前世今生/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/30/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/","excerpt":"","text":"红黑树前世今生关键词：二叉搜索树、前驱节点、后继节点、B树、红黑树 什么是B树前世B树是一种相对于来说特殊二叉搜索树，多用于数据库和文件搜索系统中。 n阶B树的性质 B树是一种平衡的多路搜索树，拥有平衡二叉树的一些特性，与平衡二叉树的最大区别在于每个节点不再是只能存储一个元素，而且每个节点可以拥有多个子节点而像二叉平衡树只能拥有两个。 B树每个节点最多可以存储超过2个元素，可以拥有超过2个子节点 B树每个子节点的子树高度一致 B树和二叉搜索树一样，左子树&lt;根节点&lt;右子树 根节点元素个数: 1≤ X ≤ n - 1 非根节点元素个数: n/2 - 1 ≤ x ≤ n - 1 (n/2 向上取整) 如果有子节点，子节点个数 y = x + 1, 根节点 2 ≤ y ≤ n非根节点 n / 2 ≤ y ≤ n (n/2 向上取整) 数据库中一般使用的是200-300阶B树 4阶B树元素个数为(2-3-4)，所以4阶B树也叫2-4树或者2-3-4树 5阶B树元素个数为 3-4-5 所以5阶B树叫（3，5）树 6阶B树元素个数3-4-5-6，所以6阶B树叫（3，6）树 7阶B树元素个数为4-5-6-7，所以7阶B树叫（4，7）树 B树 VS 二叉搜索树 B树与二叉搜索树逻辑上等价 n阶B树最多需要log2 N代合并 多代节点合并可以获得超节点 2代合并最多拥有4个子节点 3代合并最多拥有8个子节点 n代合并最多拥有2^n个子节点（至少是2^n阶B树） B树的添加与上溢上溢出（overflow）:添加元素到子节点后，该节点元素个数大于N时，我们称之为上溢出 B树的元素添加的位置一定是叶子节点 B树添加导致上溢 B树上溢最极端的情况是一直分裂到根节点 B树的删除与下溢删除 删除叶子节点的话直接删除 删除的非叶子节点的话：1、先找到前驱或后继节点元素，覆盖需要删除的值，2、把前驱或后继元素删除（说明：一个树的前驱在左子树的最后边，后驱在右子树的最左边。） 非叶子节点前驱或后继元素，必然是在叶子节点中，所以真正删除的元素都是叶子节点 下溢出（underflow）：叶子节点被删除一个元素后，元素个数可能会低于最低限制 （n/2 - 1 向上取整） 下溢出的解决方案是旋转，总体元素是哪个方向失衡往哪个方向转，子树大小顺序不能乱 4阶B树 4阶B树所有节点都能储存的元素个数x: 1 ≤ x ≤ 3 4阶B树非叶子节点的子节点个数：2 ≤ y ≤ 4 为什么需要红黑树?红黑树是在二叉搜索树的基础上对AVL树的改进，二叉搜索树顾名思义是对搜索算法的一种优化，能够大大减少我们元素对比的次数。红黑树在Java中的应用如HashSet(底层是数组单链表和红黑树)、数据库搜索也有应用。 什么是红黑树？红黑树是一种自平衡的二叉搜索树也叫平衡二叉B树 红黑树5个性质 节点分为红色与黑色 根节点是黑色 叶子节点是黑色 不能有两个连续的红色节点 从任意节点到叶子节点上所有路径的黑色节点数目必须相等 红黑树等价变换红黑树等价于4阶B树 红黑树添加失衡如何解决？添加失衡 Parrent节点为黑色时不需要处理 Parrent节点为红色（Double Red） Uncle节点不是red: LL/RR LR/RL Uncle节点是red: 红黑树删除节点失衡如何解决？红黑树 VS AVL树搜索性能添加删除实际应用Java8中的hashMap是使用数组+链表实现的，在解决哈希碰撞时使用了红黑树。","categories":[],"tags":[]},{"title":"二叉树前世今生","slug":"二叉树前世今生","date":"2019-12-30T07:28:54.936Z","updated":"2019-12-30T07:28:54.937Z","comments":true,"path":"2019/12/30/二叉树前世今生/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/","excerpt":"","text":"二叉树今生为什么会有二叉树这种数据结构？ 思考一个问题：如果一个集合中有42亿个元素，让你从这42亿个元素中搜索某一个元素，你需要多少次操作？ 如果使用数组链表的话最多可能需要42亿次比较，而如果使用二叉树我们只需要32次比较即可，这就是二叉树存在的价值。Java中的HashSet使用的就是二叉树 前驱与后继前驱节点 若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode） 若一个节点没有左子树，那么判断该节点和其父节点的关系 2.1 若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。 2.2 若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点 后继节点 若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode） 若一个节点没有右子树，那么判断该节点和其父节点的关系2.1 若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点2.2 若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点 如何判断两个二叉树是否相同？ 递归法 static public bool IsSameTree(TreeNode root1, TreeNode root2) { if (root1 == null && root2 == null) { return true; } if ((root1 == null && root2 != null) || (root1 != null && root2 == null)) { return false; } if (root1.val != root2.val) {//判断每个节点的值是否相等，如果去除此判断，则判断两个二叉树是否结构相等 return false; } return IsSameTree(root1.left, root2.left) && IsSameTree(root1.right, root2.right); } 非递归法 bool BTreeCompare（BTreeNode_t *pRoot1, BTreeNode_t *pRoot2) { if( pRoot1 == NULL && pRoot2 == NULL ) return false; queue que1; queue que2; que1.push(pRoot1); que2.push(pRoot2); int curLevelNodeTotal1 = 0; int curLevelNodeTotal2 = 0; bool flag = true; //作为比较不一致时跳出标识 while( ( !que1.empty()) && ( !que2.empty())) //当两个队列均不为空时，才进行比较 { curLevelNodeTotal1 = que1.size(); //获取树1的当前层节点总数 curLevelNodeTotal2 = que2.size(); //获取树2的当前层节点总数 if( curLevelNodeTotal1 != curLevelNodeTotal2){ flag = false;//当前层节点总数都不一致，不需要比较了，直接跳出 break; } int cnt1 = 0;//遍历本层节点时的计数器 int cnt2 = 0; while( cnt1 < curLevelNodeTotal1 && cnt2 < curLevelNodeTotal2){ ++cnt1; ++cnt2; pRoot1 = que1.front(); que1.pop(); pRoot2 = que2.front(); que2.pop(); //比较当前节点中数据是否一致 if( pRoot1->m_pElemt != pRoot2->m_pElemt ){ flag = false; break; } //判断pRoot1和pRoot2左右节点结构是否相同 if( ( pRoot1->m_pLeft != NULL && pRoot2->m_pLeft == NULL ) || ( pRoot1->m_pLeft == NULL && pRoot2->m_pLeft != NULL ) || ( pRoot1->m_pRight != NULL && pRoot2->m_pRight == NULL ) || ( pRoot1->m_pRight == NULL && pRoot2->m_pRight != NULL ) ){ flag = false; break; } //将左右节点入队 if( pRoot1->m_pLeft != NULL ) que1.push( pRoot1->m_pLeft); if( pRoot1->m_pRight != NULL ) que1.push( pRoot1->m_pRight); if( pRoot2->m_pLeft != NULL ) que2.push( pRoot2->m_pLeft); if( pRoot2->m_pRight != NULL ) que2.push( pRoot2->m_pRight); } if( flag == false ) break; } //如果比较标志为false，则不相同 if( flag == false ){ while( !que1.empty() ) que1.pop(); while( !que2.empty()) que2.pop(); return false; } return true; }","categories":[],"tags":[]},{"title":"iOS图像处理","slug":"iOS图像处理","date":"2019-12-30T07:28:54.924Z","updated":"2020-03-26T08:59:08.699Z","comments":true,"path":"2019/12/30/iOS图像处理/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/30/iOS%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"iOS图像优化技巧 1、如何处理大尺寸图片？ 2、如何处理瀑布流图片占用大量内存的问题？ 3、如何处理多张图片上传和下载问题？ 1、处理大尺寸图片那么，什么时候对图像进行渲染优化才有意义呢？ 当它明显大于 UIImageView 显示尺寸的时候 想要完整渲染这张宽高为 12,000 px 的图片，需要高达 20 MB 的空间。对于当今的硬件来说，你可能不会在意这么少兆字节的占用。但那只是它压缩后的尺寸。要展示它，UIImageView 首先需要把 JPEG 数据解码成位图（bitmap），如果要在一个 UIImageView 上按原样设置这张全尺寸图片，你的应用内存占用将会激增到几百兆，对用户明显没有什么好处（毕竟，屏幕能显示的像素有限）。但只要在设置 UIImageView 的 image 属性之前，将图像渲染的尺寸调整成 UIImageView 的大小，你用到的内存就会少一个数量级： 内存消耗 (MB) 无下采样 220.2 下采样 23.7 这个技巧就是众所周知的下采样（downsampling），在这些情况下，它可以有效地优化你应用的性能表现。如果你想了解更多关于下采样的知识或者其它图形图像的最佳实践，请参照 来自 WWDC 2018 的精彩课程。 而现在，很少有应用程序会尝试一次性加载这么大的图像了，但是也跟我从设计师那里拿到的图片资源不会差太多。（认真的吗？一张颜色渐变的 PNG 图片要 3 MB?） 考虑到这一点，让我们来看看有什么不同的方法，可以让你用来对图像进行优化或者下采样。 不用说，这里所有从 URL 加载的示例图像都是针对本地文件。记住，在应用的主线程同步使用网络请求图像绝不是什么好主意。 图像渲染优化技巧优化图像渲染的方法有很多种，每种都有不同的功能和性能特性。我们在本文看到的这些例子，架构层次跨度上从底层的 Core Graphics、vImage、Image I/O 到上层的 Core Image 和 UIKit 都有。 绘制到 UIGraphicsImageRenderer 上 绘制到 Core Graphics Context 上 使用 Image I/O 创建缩略图像 使用 Core Image 进行 Lanczos 重采样 使用 vImage 优化图片渲染 下面的这些数字是多次迭代加载、优化、渲染之前那张 超大地球图片 的平均时间： 耗时 (seconds) 技巧 #1: UIKit 0.1420 技巧 #2: Core Graphics 1 0.1722 技巧 #3: Image I/O 0.1616 技巧 #4: Core Image 2 2.4983 技巧 #5: vImage 2.3126 1设置不同的 CGInterpolationQuality 值出来的结果是一致的，在性能上的差异可以忽略不计。 2若在 CIContext 创建时设置 kCIContextUseSoftwareRenderer 的值为 true，会导致耗时相比基础结果慢一个数量级。 使用CGContextDrawImage()异步解码图片 dispatch_async(dispatch_get_global_queue(0, 0), ^{ // 1、获取CGImage CGImageRef cgImage = [UIImage imageNamed:@\"img\"].CGImage; // alphaInfo CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage) & kCGBitmapAlphaInfoMask; BOOL hasAlpha = NO; if (alphaInfo == kCGImageAlphaPremultipliedLast || alphaInfo == kCGImageAlphaPremultipliedFirst || alphaInfo == kCGImageAlphaLast || alphaInfo == kCGImageAlphaFirst) { hasAlpha = YES; } // bitmapInfo CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; // size size_t width = CGImageGetWidth(cgImage); size_t height = CGImageGetHeight(cgImage); // 2、获取context CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo); //3、 draw CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage); // get CGImage cgImage = CGBitmapContextCreateImage(context); // into UIImage UIImage *newImage = [UIImage imageWithCGImage:cgImage]; // release CGContextRelease(context); CGImageRelease(cgImage); // back to the main thread dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = newImage; }); }); 技巧 #1: 绘制到 UIGraphicsImageRenderer 上图像渲染优化的最上层 API 位于 UIKit 框架中。给定一个 UIImage，你可以绘制到 UIGraphicsImageRenderer 的上下文（context）中以渲染缩小版本的图像： import UIKit // 技巧 #1 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { guard let image = UIImage(contentsOfFile: url.path) else { return nil } let renderer = UIGraphicsImageRenderer(size: size) return renderer.image { (context) in image.draw(in: CGRect(origin: .zero, size: size)) } }UIGraphicsImageRenderer 是一项相对较新的技术，在 iOS 10 中被引入，用以取代旧版本的 UIGraphicsBeginImageContextWithOptions / UIGraphicsEndImageContext API。你通过指定以 point 计量的 size 创建了一个 UIGraphicsImageRenderer。image 方法带有一个闭包参数，返回的是一个经过闭包处理后的位图。最终，原始图像便会在缩小到指定的范围内绘制。 技巧 #2：绘制到 Core Graphics Context 中Core Graphics / Quartz 2D 提供了一系列底层 API 让我们可以进行更多高级的配置。 给定一个 CGImage 作为暂时的位图上下文，使用 draw(_:in:) 方法来绘制缩放后的图像： import UIKit import CoreGraphics // 技巧 #2 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil), let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil) else { return nil } let context = CGContext(data: nil, width: Int(size.width), height: Int(size.height), bitsPerComponent: image.bitsPerComponent, bytesPerRow: image.bytesPerRow, space: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!, bitmapInfo: image.bitmapInfo.rawValue) context?.interpolationQuality = .high context?.draw(image, in: CGRect(origin: .zero, size: size)) guard let scaledImage = context?.makeImage() else { return nil } return UIImage(cgImage: scaledImage) }这个 CGContext 初始化方法接收了几个参数来构造一个上下文，包括了必要的宽高参数，还有在给出的色域范围内每个颜色通道所需要的内存大小。在这个例子中，这些参数都是通过 CGImage 这个对象获取的。下一步，设置 interpolationQuality 属性为 .high 指示上下文在保证一定的精度上填充像素。draw(_:in:) 方法则是在给定的宽高和位置绘制图像，可以让图片在特定的边距下裁剪，也可以适用于一些像是人脸识别之类的图像特性。最后 makeImage() 从上下文获取信息并且渲染到一个 CGImage 值上（之后会用来构造 UIImage 对象）。 技巧 #3：使用 Image I/O 创建缩略图像处理大分辨率图片时，往往容易出现OOM，原因是-[UIImage drawInRect:]在绘制时，先解码图片，再生成原始分辨率大小的bitmap，这是很耗内存的。 解决方法是使用更低层的ImageIO接口，避免中间bitmap产生： Image I/O 是一个强大（却鲜有人知）的图像处理框架。 它可以读写许多不同图像格式，访问图像的元数据，还有执行常规的图像处理操作。这个框架通过先进的缓存机制，提供了平台上最快的图片编码器和解码器，甚至可以增量加载图片。 这个重要的 CGImageSourceCreateThumbnailAtIndex 提供了一个带有许多不同配置选项的 API，比起在 Core Graphics 中等价的处理操作要简洁得多： import ImageIO // 技巧 #3 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { let options: [CFString: Any] = [ kCGImageSourceCreateThumbnailFromImageIfAbsent: true, kCGImageSourceCreateThumbnailWithTransform: true, kCGImageSourceShouldCacheImmediately: true, kCGImageSourceThumbnailMaxPixelSize: max(size.width, size.height) ] guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil), let image = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, options as CFDictionary) else { return nil } return UIImage(cgImage: image) }给定一个 CGImageSource 和一系列配置选项，CGImageSourceCreateThumbnailAtIndex(_:_:_:) 函数创建了一个图像的缩略图。优化尺寸大小的操作是通过 kCGImageSourceThumbnailMaxPixelSize 完成的，它根据图像原始宽高比指定的最大尺寸来缩放图像。通过设定 kCGImageSourceCreateThumbnailFromImageIfAbsent 或 kCGImageSourceCreateThumbnailFromImageAlways 选项，Image I/O 可以自动缓存优化后的结果以便后续调用。 总结 UIKit, Core Graphics, 和 Image I/O 都能很好地用于大部分图片的优化操作。 如果（在 iOS 平台，至少）要选择一个的话，UIGraphicsImageRenderer 是你最佳的选择。 Core Image 在图像优化渲染操作方面性能表现优越。实际上，根据 Apple 官方 Core Image 编程规范中的性能最佳实践单元，你应该使用 Core Graphics 或 Image I/O 对图像进行裁剪和下采样，而不是用 Core Image。 除非你已经在使用 vImage，否则在大多数情况下用到底层的 Accelerate API 所需的额外工作可能是不合理的。 本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 http://swift.gg。 2、同时处理大量图片UIScrollView滚动停止监测通过调查发现 UIScrollView 停止滚动的类型分为三种： 快速滚动，自然停止 快速滚动，手指按压突然停止 慢速上下滑动停止 第1种类型，比较简单，在 UIScrollView 的代理中就可以监听到。 - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; 而第2种类型和第3种类型，就没有方法让我们可以直接监听到了。但是只要是滑动了，就一定会触发 UIScrollView 的下面代理，然后通过 UIScrollView 部分属性的改变，我们就可以监听到滚动停止了，后面会详细介绍方法。 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; 监听UIScrollView停止滚动通过翻阅文档，我们可以看到 UIScrollView 有三个属性: tracking、dragging、decelerating。 // returns YES if user has touched. may not yet have started dragging @property(nonatomic,readonly,getter=isTracking) BOOL tracking; // returns YES if user has started scrolling. this may require some time and or distance to move to initiate dragging @property(nonatomic,readonly,getter=isDragging) BOOL dragging; // returns YES if user isn't dragging (touch up) but scroll view is still moving @property(nonatomic,readonly,getter=isDecelerating) BOOL decelerating; 在滚动和滚动结束时，这三个属性的值都不相同。我们利用这三个属性，完成对 UIScrollView 停止滚动的监听。 停止类型1：scrollViewDidEndDecelerating - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; tracking:0,dragging:0,decelerating:0 停止类型2：scrollViewDidEndDragging &amp; scrollViewDidEndDecelerating - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; tracking:1,dragging:0,decelerating:1 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; tracking:0,dragging:0,decelerating:0停止类型3：scrollViewDidEndDragging - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; tracking:1,dragging:0,decelerating:0通过上面的代码，可以发现，我们只需要对 UIScrollView 的这三个属性进行相应的组合，就可以监听到 UIScrollView 停止滚动的事件了。 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView { [self stoppedScrolling]; } - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { if (!decelerate) { [self stoppedScrolling]; } } - (void)stoppedScrolling { // ... NSLog(@\"停止滚动了！！！\"); } -(void)scrollViewDidScroll:(UIScrollView *)sender { [NSObject cancelPreviousPerformRequestsWithTarget:self]; [self performSelector:@selector(scrollViewDidEndScrollingAnimation:) withObject:nil afterDelay:0.1]; } -(void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView { [NSObject cancelPreviousPerformRequestsWithTarget:self]; } 3、处理多图上传下载问题？UI刷新问题layout的相关方法: layoutSubviews layoutIfNeeded setNeedsLayout setNeedsDisplay drawRect sizeThatFits sizeToFit layoutSubviews这个方法，默认没有做任何事情，需要子类进行重写 。 系统在很多时候会去调用这个方法： 1.初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发。2.addSubview会触发layoutSubviews3.设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化4.滚动一个UIScrollView会触发layoutSubviews5.旋转Screen会触发父UIView上的layoutSubviews事件6.改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件 You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。 反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。 setNeedsLayout 标记为需要重新布局，不立即刷新，但layoutSubviews一定会被调用 配合layoutIfNeeded立即更新 layoutIfNeeded 如果有需要刷新的标记，立即调用layoutSubviews进行布局","categories":[],"tags":[]},{"title":"Swift备忘录","slug":"Swift备忘录","date":"2019-12-07T04:48:29.505Z","updated":"2020-04-15T09:52:06.164Z","comments":true,"path":"2019/12/07/Swift备忘录/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/07/Swift%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"SwiftTip","text":"SwiftTip Flip the image: 翻转图片 Retrive the paths: 检索，重新获得 Swift访问控制权限Swift的访问权限管理依赖于两个概念：module和文件。module是一个完整的代码单元， 它可以是一个或多个框架（Framework），或者是一个App Bundle，可以被import导入到工程中。 文件指的就是Swift File，它通常属于一个module。 Swift 为代码中的实体提供了5种不同的访问级别:open、public、internal、fileprivate、private。 访问级别 定义 open 这个属性允许在 app 内或 app 外重写和访问。在开发框架的时候，会应用到这个访问修饰符。 public 可以访问自己模块中源文件里的任何实体，别人也可以通过引入该模块来访问源文件里的所有实体。 internal 默认权限可以访问自己module中源文件里的任何实体 fileprivate 只能在当前源文件中使用。 private 只允许实体在定义的类以及相同源文件内的 extension 中访问 Open 为最高级访问级别，private 为最低级访问级别。 class Person { private var name: String? } *如果希望name仅在当前文件中可访问，可以使用private修饰 * class Person { private(set) var name: String? } 如果希望外部可以读取，但不可以修改。这也是为了保证类型的封装和安全，在内部提供可读可写，而外部仅仅可读 这种写法相当于把setter设置为private，而getter仍然是默认的internal class Person { public private(set) var name: String? } 如果既想要外部可读，又想仅内部可写，可以为getter加上public： 声明关键字associatedtype：在协议中，定义一个类型的占位符名称。直到协议被实现，该占位符才会被指定具体的类型。protocol Entertainment { associatedtype MediaType } class Foo : Entertainment { typealias MediaType = String //可以指定任意类型 } class：通用、灵活的结构体，是程序的基础组成部分。与 struct 类似，不同之处在于： 允许一个类继承另一个类的特性。 类型转换，允许在运行时检查和指定一个类的实际类型。 析构方法允许类的实例释放所有资源。 引用计数允许多个引用指向一个实例。 struct：通用、灵活的结构体，是程序的基础组成部分，并提供了默认初始化方法。与 class 不同，当 struct 在代码中被传递时，是被拷贝的，并不使用引用计数。除此之外，struct 没有下面的这些功能： 使用继承。 运行时的类型转换。 使用析构方法。 struct Person { var name:String var age:Int var gender:String } extension：允许给已有的类、结构体、枚举、协议类型，添加新功能。NSError：code、domin、userInfoSwift Error分类 domain error Recoverable error Universal error Logic error enum Result&lt;T> { case Success(T) case Failure(NSError) } try!表示强制执行，如果发生异常程序crashtry?返回可选项，如果发生异常返回nil 不会crashenum E: Error { case Negative } func methodThrowsWhenPassingNegative(number: Int) throws -> Int { if number &lt; 0 { throw E.Negative } return number } if let num = try? methodThrowsWhenPassingNegative(100) { print(num.dynamicType) } else { print(\"failed\") } Precondition预处理定义public func precondition(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line) public func preconditionFailure(_ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line) -> Never 使用precondition(condition: Bool, message: String) precondition 在一般的代码中并不多见，因为它是动态的，只会在程序运行时进行检查，适用于哪些无法在编译期确定的风险情况。 如果出现了诸如数据错误的情况，precondition 会提前终止程序，避免因数据错误造成更多的损失。 如果条件判断为 true，代码运行会继续进行。 如果条件判断为 false，程序将终止。 assert 是单纯地触发断言即停止程序，不会让你有机会将可能出错的设计走过它这一关。？？？ 例如：Swift 数组的下标操作可能造成越界，使用扩展的方式向其中增加一个方法来判断下标是否越界。 extension Array { func isOutOfBounds(index: Int) { precondition((0..&lt;endIndex).contains(index), &quot;数组越界&quot;) print(&quot;继续执行&quot;) } }// 不越界的情况 [1, 2, 3].isOutOfBounds(index: 2) // 继续执行 // 越界的情况 [1, 2, 3].isOutOfBounds(index: 3) // Thread 1: Precondition failed: 数组越界 在满足 precondition 条件的时候，程序会继续执行。 在不满足 precondition 条件的时候，程序被终止，并且将 precondition 中预设的错误信息打印到了控制台上，precondition 避免了一些无意义的操作。 precondition和assert的区别 https://stackoverflow.com/questions/29673027/difference-between-precondition-and-assert-in-swift 闭包@autoclosure作用：将表达式自动封装成一个闭包()-&gt;Void 1.2 ??的底层实现是用的enum 1.3 “闭包和循环引用” weak解决循环引用的正确写法： var name: ()->() = { [weak self] in if let strongSelf = self { print(\"The name is (strongSelf.name)\") } } 值类型和引用类型的选择 数组和字典设计为值类型最大的考虑是为了线程安全. 另一个优点，那就是非常高效，因为 “一旦赋值就不太会变化” 这种使用情景在 Cocoa 框架中是占有绝大多数的，这有效减少了内存的分配和回收。 但是在少数情况下，我们显然也可能会在数组或者字典中存储非常多的东西，并且还要对其中的内容进行添加或者删除。” 在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好， 对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary @escaping的作用？ class func animate(withDuration duration: TimeInterval, animations: @escaping () -&amp;gt; Void, completion: ((Bool) -> Void)? = nil) defer的使用注意点defer的作用域 以前很单纯地认为 defer 是在函数退出的时候调用，并没有注意其实是当前 scope 退出的时候调用这个事实，造成了这个错误。在 if，guard，for，try 这些语句中使用 defer 时，应该要特别注意这一点。 @discardableResultResultResult&lt;T, E: Error&gt; 和 Result Lazy的使用 let data = 1...3 let result = data.lazy.map { (i: Int) -> Int in print(\"准备处理(i)\") return i * 2 } print(\"准备访问结果\") for i in result { print(\"处理后的结果:(i)\") } print(\"done\") 打印结果： 准备访问结果 准备处理1 处理后的结果:2 准备处理2 处理后的结果:4 准备处理3 处理后的结果:6 done Swift反射机制Mirror “通过 Mirror 初始化得到的结果中包含的元素的描述都被集合在 children 属性下，如果你有心可以到 Swift 标准库中查找它的定义，它实际上是一个 Child 的集合，而 Child 则是一对键值的多元组： 示例1 struct Car { let logo: String var wheel: Int let door: Int } let baoM = Car(logo: \"BMW\", wheel: 4, door: 2) let mirror = Mirror(reflecting: baoM) print(\"类型:(String(describing: mirror.displayStyle))\") ///1、通过Mirror的children获取属性信息 print(\"属性个数:(mirror.children.count)\") mirror.children.map { (child) -> Any in print(\"label: (String(describing: child.label)), value: (child.value)\") } ///2、通过Refletion的dump(Any)方法获取属性信息 dump(baoM) 示例2 获取property let homeProperty = Mirror(reflecting: self) homeProperty.children.map { LOG.D(\"home property:($0)\") } iOS初始化核心原则 iOS 的初始化最核心两条的规则： • 必须至少有一个指定初始化器，在指定初始化器里保证所有非可选类型属性都得到正确的初始化（有值） • 便利初始化器必须调用其他初始化器，使得最后肯定会调用指定初始化器 在Swift中千万不要用String的count方法计算文本长度。否则当文本中有emoji时，会计算出错。应当转成NSString再去求length。 Array for-in使用 1.for in获取索引 index let array = [\"Apple\", \"Google\", \"Amazon\"] for item in array { print(\"company name is :(item)\") } ///配合array.enumerated()使用 for (index, item) in array.enumerated() { print(\"index:(index), item:(item)\") } 2.array.firstIndex(of:)获取index ///配合array.firstIndex(of:)使用 let googleIndex = array.firstIndex(of: \"Google\") print(\"googleIndex is : (googleIndex ?? 0)\") ///配合array.firstIndex(where:)使用 if let index = array.firstIndex(where: { $0.hasPrefix(\"A\") }) { print(\"array.firstIndex is (index)\") } if let item = array.first(where: { $0.hasPrefix(\"A\")}{ print(\"array.first is :(item)\") } Array.forEach()2.1forEach()和函数式编程结合使用 let array = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"] ///使用forEach array.map { Int($0)! }.forEach { num in print(num) } //不使用forEach let map = array.map { Int($0)! } map.forEach { print($0) } 2.2forEach()遍历optional集合会自动过滤nil let optionalString: [String]? = nil //使用forEach强制解包option，会过滤 optionalString?.forEach { str in print(\"str is (str)\") } ///使用for-in强制解包optional，会crash for str in optionalString! { print(\"str is (str)\") } @propertyWrapper定义与使用@propertyWrapper定义@propertyWrapper struct Clamping&lt;Value: Comparable> { var value: Value let range: ClosedRange&lt;Value> init(initialValue value: Value, _ range: ClosedRange&lt;Value>) { precondition(range.contains(value)) self.value = value self.range = range } var wrappedValue: Value { get { value } set { value = min(max(range.lowerBound, newValue), range.upperBound) } } } 使用struct Solution { @Clamping(0...14) var pH: Double = 7.0 } let carbonicAcid = Solution(pH: 4.68) // at 1 mM under standard conditions Related Ideas A @Positive / @NonNegative property wrapper that provides the unsigned guarantees to signed integer types. A @NonZero property wrapper that ensures that a number value is either greater than or less than 0. @Validated or @Whitelisted / @Blacklisted property wrappers that restrict which values can be assigned. FirstVCextension UIView { /// Get current view controller based current view. public func firstViewController() -> UIViewController? { for view in sequence(first: self.superview, next: { $0?.superview }) { if let responder = view?.next { if responder.isKind(of: UIViewController.self) { return responder as? UIViewController } } } return nil } public func firstResponder() -> UIView? { var views = [UIView](arrayLiteral: self) var index = 0 repeat { let view = views[index] if view.isFirstResponder { return view } views.append(contentsOf: view.subviews) index += 1 } while index &lt; views.count return nil } } TopVCif let controller = UIWindow.topViewController() { controller.present(alert, animated: true, completion: nil) } extension UIWindow { /// Returns the top most controller open class func topViewController() -> UIViewController? { let window = UIApplication.shared.delegate?.window let rootViewController = window??.rootViewController return topMost(of: rootViewController) } /// Returns the top most view controller from given view controller's stack. open class func topMost(of viewController: UIViewController?) -> UIViewController? { // presented view controller if let presentedViewController = viewController?.presentedViewController { return self.topMost(of: presentedViewController) } // UITabBarController if let tabBarController = viewController as? UITabBarController, let selectedViewController = tabBarController.selectedViewController { return self.topMost(of: selectedViewController) } // UINavigationController if let navigationController = viewController as? UINavigationController, let visibleViewController = navigationController.visibleViewController { return self.topMost(of: visibleViewController) } // UIPageController if let pageViewController = viewController as? UIPageViewController, pageViewController.viewControllers?.count == 1 { return self.topMost(of: pageViewController.viewControllers?.first) } // child view controller for subview in viewController?.view?.subviews ?? [] { if let childViewController = subview.next as? UIViewController { return self.topMost(of: childViewController) } } return viewController } } DispatchGroup分组管理异步任务 enter和leave必须配对出现，如下： let group = DispatchGroup() group.enter()//把该任务添加到组队列中执行 myQueue?.async(group: group, qos: .default, flags: [], execute: { for _ in 0...10 { print(\"耗时任务一\") group.leave()//执行完之后从组队列中移除 } }) group.enter()//把该任务添加到组队列中执行 myQueue?.async(group: group, qos: .default, flags: [], execute: { for _ in 0...10 { print(\"耗时任务二\") group.leave()//执行完之后从组队列中移除 } }) //当上面所有的任务执行完之后通知 group.notify(queue: .main) { print(\"所有的任务执行完了\") } Swift4.2中的self 在 4.2 之前，self 是全局保留关键字，所以如果在逃逸闭包中如果在闭包中把 self 标记为 weak 后，如果要使用需要使用 ` 包起来： guard let `self` = self else { return } Swift4.2之后 doSomething(then: { [weak self] in guard let self = self { else return } self.doSomethingElse() ) 当然取消了这个限制后也意味着 self 可能不一定是 self 了： var number: Int? = nil if let self = number { print(self) // 这里的 self 是 number：Int } prepareForReuse重置 Apple: If a UITableViewCell object is reusable—that is, it has a reuse identifier—this method is invoked just before the object is returned from the UITableView method dequeueReusableCell(withIdentifier:). For performance reasons, you should only reset attributes of the cell that are not related to content, for example, alpha, editing, and selection state. The table view’s delegate in tableView(_:cellForRowAt:) should always reset all content when reusing a cell. If the cell object does not have an associated reuse identifier, this method is not called. If you override this method, you must be sure to invoke the superclass implementation. override func prepareForReuse() { // Clean up if [self.subviews containsObject: self.someNotoriousView] { [self.contentView removeFromSuperview]; } } callbackvar select1Callback: ((String) -> Void)? var select2Callback: ((IndexPath, Model) -> Void)?","categories":[],"tags":[]},{"title":"Swift函数式编程","slug":"Swift函数式编程","date":"2019-12-06T01:36:47.815Z","updated":"2020-04-11T06:01:17.063Z","comments":true,"path":"2019/12/06/Swift函数式编程/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/06/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"Functional Programming in Swift函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。","text":"Functional Programming in Swift函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。 不变性和副作用无论您首先学习哪种编程语言，您可能要学习的最初概念之一就是变量代表数据或状态。如果您退一步考虑一下这个想法，变量似乎很奇怪。 术语“变量”表示随程序运行而变化的数量。从数学角度考虑数量问题，您已将时间作为软件行为的关键参数。通过更改变量，可以创建可变状态。 为了进行演示，请将以下代码添加到playground： var thing = 3 //some stuff thing = 4 func superHero() { print(\"I'm batman\") thing = 5 } print(\"original state = \\(thing)\") superHero() print(\"mutated state = \\(thing)\") 神圣的神秘变化！为什么现在是5？这种变化称为副作用。函数superHero（）更改了一个甚至没有定义自己的变量。 单独或在简单系统中，可变状态不一定是问题。将许多对象连接在一起时（例如在大型的面向对象的系统中）会出现问题。可变状态会使人难以理解变量具有什么值以及该值随时间的变化而产生头痛。 例如，在为多线程系统编写代码时，如果两个或多个线程同时访问同一变量，则它们可能会无序地修改或访问它。这会导致意外的行为。这种意外行为包括竞态条件，死锁和许多其他问题。 试想一下，如果您可以编写状态永远不变的代码。并发系统中发生的所有问题都将消失。像这样工作的系统具有不变的状态，这意味着不允许状态在程序过程中进行更改。 使用不可变数据的主要好处是，使用不可变数据的代码单元没有副作用。代码中的函数不会更改其自身之外的元素，并且在发生函数调用时不会出现怪异的效果。您的程序可以正常运行，因为没有副作用，您可以轻松重现其预期的效果。 本教程从较高的层次介绍了FP，因此在实际情况下考虑这些概念会很有帮助。在这种情况下，假设您正在为游乐园构建应用程序，并且该游乐园的后端服务器通过REST API提供了行程数据。 创建Modelenum RideCategory: String { case family case kids case thrill case scary case relaxing case water } typealias Minutes = Double struct Ride { let name: String let categories: Set&lt;RideCategory> let waitTime: Minutes } Create some data using that modellet parkRides = [ Ride(name: \"R45\", categories: [.family, .thrill, .water], waitTime: 45.0), Ride(name: \"R10\", categories: [.family], waitTime: 10.0), Ride(name: \"R15\", categories: [.kids], waitTime: 15.0), Ride(name: \"R30\", categories: [.scary], waitTime: 30.0), Ride(name: \"R60\", categories: [.family, .thrill], waitTime: 60.0), Ride(name: \"R15-2\", categories: [.family, .kids], waitTime: 15.0), Ride(name: \"R25\", categories: [.family, .water], waitTime: 25.0), Ride(name: \"R0\", categories: [.family, .relaxing], waitTime: 0.0) ] Map 、Filter、 ReduceMost languages that support FP will have the functions filter, map &amp; reduce. Map Map是将输入Collection中的每个Element转换为新Element。 使用map遍历一个集合，并对集合中的每个元素应用相同的操作。 map函数返回一个数组，其中包含对每个元素的映射或转换函数的结果。 Map on array:let arrayOfInt = [1,2,3,4,5] 如果我们要对每个元素乘上10呢？我们以前可能要这样 var newArr: [Int] = [] for value in arrayOfInt { newArr.append(value * 10) } print(newArr) 现在有map()后我们可以这样： let mapArr = arrayOfInt.map { $0 * 10 } print(mapArr) Working of map: The map function has a single argument which is a closure (a function) that it calls as it loops over the collection. This closure takes the element from the collection as an argument and returns a result. The map function returns these results in an array. Map on Dictionarylet book = [\"A\": 100, \"B\": 80, \"C\": 90] let mapedBook = book.map { (key, value) in key.capitalized } print(mapedBook) //[\"C\", \"B\", \"A\"] Map on Setlet lengthInmeter: Set = [1,3,5] let km = lengthInmeter.map { meter in meter * 1000 } print(km) // [1000, 5000, 3000] Map同时获取array.Index??let nums = [1,2,3,4,5] let newNums = nums.enumerated().map { (index, num) in return num * 10 } print(\"newNums:\\(newNums)\") FilterFilter函数的作用是过滤集合，返回符合条件的集合。 Filter on Arraylet filterArray = [2,4,6,1,5,7] let newFilterArray = filterArray.filter { num -> Bool in num % 2 == 0 } print(newFilterArray) Filter on Dictionarylet book = [\"A\": 100, \"B\": 80, \"C\": 90] let bookFilter = book.filter { (key, value) in value > 80 } print(bookFilter) 简化 let book = [\"A\": 100, \"B\": 80, \"C\": 90] let bookFilter = book.filter { $1 > 80 } $0是key $1是value Filter on Setlet setNums = [4.9,5.5,8.6] let newSet = setNums.filter { $0 > 5.0 } print(newSet) 重要：返回类型是数组 Reduce Use reduce to combine all items in a collection to create a single new value. 使用reduce可以合并集合中的所有元素来创建一个新的value Apple文档声明reduce() func reduce&lt;Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -> Result) rethrows -> Result reduce函数有两个参数： 第一个参数 initial value用来存储初始值或者结果（每次迭代器的结果） 第二个是带有两个参数的闭包，Result是初始值或迭代器的结果，Element是集合中的下一个元素。 Reduce on Arraylet numbers = [1,2,3,4,5,6] let sum = numbers.reduce(0) { x, y in x + y } print(sum) 简化版本：使用$0代表result let reducedSum = numbers.reduce(0) { $0 + $1 } print(reducedSum) ///等价 let reducedSum = numbers.reduce(0, +) print(reducedSum) 乘法 let produceNum = numbers.reduce(1) { x, y in x * y } print(produceNum) ///等价 let produceNum = numbers.reduce(1, *) print(produceNum) Reduce + 连接字符串let charactors = [\"abc\",\"def\",\"hijk\"] let newCharactor = charactors.reduce(\"\", +) print(newCharactor) // abcdefhijk Reduce on Dictionary let dict = [\"A\": 20, \"B\": 100] // Reduce on value let reducedNum = dict.reduce(5) { result, dic in return result + dic.value } print(\"reduc on value is \\(reducedNum)\") // reduc on value is 125 // Reduce on key let reducedName = dict.reduce(\"Charactor are \") { (result, dic) in return result + dic.key + \" \" } print(\"reduce on key is &lt;\\(reducedName)>\") //reduce on key is &lt;Charactor are A B > 简化 let reducedNameOnDic = dict.reduce(\"Charater are \") { $0 + $1.key + \" \"} Reduce on Set// Reduce on Set let lengthMeters = [3.4,1.6] let reducedMeters = lengthMeters.reduce(0.0) { $0 + $1 } print(\"reduced meters :\\(reducedMeters)\") // 5.0 FlatMapFlatmap is used to flatten a collection of collections . But before flattening the collection, we can apply map to each elements. Apple docs says: Returns an array containing the concatenated results of calling the given transformation with each element of this sequence. Flatmap用于展平集合的集合。 但是在展平集合之前，我们可以将map应用于每个集合元素。 let charaters = [\"abc\",\"def\",\"ghi\"] let newCharaters = charaters.flatMap { $0 } print(newCharaters) //[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"] let codes = [[\"abc\",\"def\",\"ghi\"], [\"jkl\",\"mno\",\"pqr\"],[\"stu\",\"vwx\",\"yz\"] ] let newCodes = codes.flatMap {$0.map { $0 } } print(newCodes) // [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\"] nillet nilArray = [2,3,nil] print(nilArray.flatMap { $0 }) // [2,3] // warning: 'flatMap' is deprecated: Please use compactMap(_:) for the case where closure returns an optional value print(nilArray.compactMap { $0 }) // [2,3]","categories":[],"tags":[]}]}