{"meta":{"title":"明日危机","subtitle":"iOS & Swifter","description":"","author":"KM","url":"https://mingriweiji-github.github.io","root":"/"},"pages":[],"posts":[{"title":"2020数据结构","slug":"2020数据结构","date":"2020-03-16T10:34:26.943Z","updated":"2020-03-16T10:36:46.164Z","comments":true,"path":"2020/03/16/2020数据结构/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/16/2020%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"思考题： 1.如何分别用链表和数组实现LRU缓冲淘汰策略？1）什么是缓存？ 缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。 什么是C CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。 2）为什么使用缓存？即缓存的特点 缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。 3）什么是缓存淘汰策略？ 指的是当缓存被用满时清理数据的优先顺序。 4）有哪些缓存淘汰策略？ 先进先出策略FIFO（First In，First Out） 最少使用策略LFU（Least Frenquently Used） 最近最少使用策略LRU（Least Recently Used）。 5）链表实现LRU缓存淘汰策略 我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。 如果此数据没有在缓存链表中，又可以分为两种情况： 如果此时缓存未满，则将此结点直接插入到链表的头部； 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。 6）数组实现LRU缓存淘汰策略 方式一 首位置保存最新访问数据，末尾位置优先清理 当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)； 当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。 缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。 方式二 首位置优先清理，末尾位置保存最新访问数据 当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)； 当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。 缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。） 2.如何通过单链表实现“判断某个字符串是否为回文字符串”？方法一：半栈法 １．用快慢两个指针遍历，同时用栈copy慢指针指向的data。 ２．完成后，慢指针指向中间节点，耗时为N/2. ３．最后用pop栈中的data和慢指针指向的data比较，耗时也是N/2. 所以时间复杂度为：Ｏ(N)，空间复杂度因栈额外存储了一半的data，故为O(N/2) 方法二：全栈法 1）前提：字符串以单个字符的形式存储在单链表中。 2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。 3）将链表中的字符倒序存储一份在另一个链表中。 4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是回文字串，否则，不是。 方法三：硬干法 一个指针从头取data，另一个指针遍历到底取data，比较二者 ２．删除尾部节点，重复１． 时间复杂度高达 O(N^2)，空间复杂度却最低Ｏ(1) 栈和队列1、栈和队列20. 有效的括号 func isValid(_ s: String) -> Bool { var stack: [String] = [] let dic: [String: String] = [\")\": \"(\", \"}\": \"{\", \"]\": \"[\"] for c in s { let key = String(c) if !dic.keys.contains(key) { stack.append(key) } else if stack.count == 0 || dic[key] != stack.removeLast() { return false } } return stack.count == 0 } 232. 用栈实现队列225. 用队列实现栈2、链表public class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } 1： 删除链表中的节点 class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } 2：反转链表 题目描述：反转一个单链表。 Solution1: 递归法 public ListNode reverseList(ListNode head) { if(head == null) return head; if(head.next == null) return head; ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead; } Solotion2: 非递归-双指针（https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/） 正确示例 public ListNode reverseList(ListNode head) { if(head == null) return head; if(head.next == null) return head; ListNode newHead = null; while (head != null) { ListNode temp = head.next; head.next = newHead; newHead = head; head = temp; } return newHead; } 3：反转链表 II 题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 4：环形链表 第一步：找到快慢指针相遇的节点，如果找不到，证明没有环，返回null 第二步：head节出发与slow节点出发，相遇的节点为环的入口节点 public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode fast = head.next; ListNode slow = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; if (fast == slow) { return true; } } return fast == slow; } 5：环形链表II-寻找环的入口节点 问题描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 官方解读Gif 6：703. 数据流中的第K大元素 public class KthLargest { private PriorityQueue queue; private int limit; public KthLargest(int k, int[] nums) { limit = k; queue = new PriorityQueue(k); for (int num : nums) { add(num); } } public int add(int val) { if (queue.size() < limit) { queue.add(val); } else if (val > queue.peek()) { queue.poll(); queue.add(val); } return queue.peek(); } } 3、优先队列 Heap (Binary, Binomial, Fibonacci) Binary Search Tree Heap Wiki • https://en.wikipedia.org/wiki/Heap_(data_structure) 239、滑动窗口最大值4、哈希表 与双指针法1. 两数之和1.1暴力循环 1.2一次哈希思路标签：哈希映射 这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n2) 由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度 遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值 如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止 如果最终都没有结果则抛出异常 时间复杂度：O(n) 15. 三数之和 (硅谷面试)给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 解题思路： 1、可以三重loops循环时间复杂度是O(n3) 2、可以两层循环得到a+b,然后在Set集合中查找符合-(a+b)的值是否存在，时间复杂度是O(n2) 3、先排序 后查找：时间复杂度为O(n2)，先排序后得到元素a, 元素b从数组下标1开始，元素c从数组下标array.length开始，检查（a + b + c）的值： 如果（a + b + c）&gt; 0, c– 如果 （a + b + c）&lt; 0, b++ 如果（a + b + c） == 0， 得到结果 整个过程时间复杂度是O(N * N) 解题思路3 public static List threeSum(int[] nums) { List ans = new ArrayList(); int len = nums.length; if(nums == null || len < 3) return ans; Arrays.sort(nums); // 排序 for (int i = 0; i < len ; i++) { if(nums[i] > 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环 if(i > 0 && nums[i] == nums[i-1]) continue; // 去重 int L = i+1; int R = len-1; while(L < R){ int sum = nums[i] + nums[L] + nums[R]; if(sum == 0){ ans.add(Arrays.asList(nums[i],nums[L],nums[R])); while (L [Int] { guard let root = root else { return[]} var res: [Int] = [] res.append(root.val) res += preorderTraversal(root.left) res += preorderTraversal(root.right) return res } 2、中序遍历中序遍历递归法：左子树-根节点-右子树 func inorderTraversal(_ root: TreeNode?) -> [Int] { guard let root = root else { return [] } var res: [Int] = [] res += inorderTraversal(root.left) res.append(root.val) res += inorderTraversal(root.right) return res } 3、后序遍历后序遍历递归法：左子树-右子树-根节点 func postorderTraversal(_ root: TreeNode?) -> [Int] { guard let root = root else { return [] } var result: [Int] = [] if let left = root.left { result += postorderTraversal(left) } if let right = root.right { result += postorderTraversal(right) } result.append(root.val) return result } 4.1、二叉树的层次遍历 图片来自网络，侵权删 实现思路：使用队列1.将根节点入队2.循环执行以下操作，直到队列为空 将队头节点A出队，进行访问 将A的左子节点入队 将A的右子节点入队 func levelOrder(_ root: TreeNode?) -> [[Int]] { guard let root = root else { return []} var result: [[Int]] = [] var queue: [TreeNode] = [] queue.append(root) while !queue.isEmpty { //创建存储当前level的数组 var level: [Int] = [] for _ in 0.. [[Int]] { guard let root = root else { return [] } var results: [[Int]] = [] var queue: [TreeNode] = [root] while !queue.isEmpty { var levelItems: [Int] = [] for _ in 0.. Int { if let root = root { var leftHeight = 0, rightHeight = 0 if let left = root.left { leftHeight = maxDepth(left) } if let right = root.right { rightHeight = maxDepth(right) } return max(leftHeight, rightHeight) + 1 } return 0 } 解放二：使用队列，分层遍历DFS，记录层数即可 //2、利用队列-和分层遍历类似 //只不过分层遍历是头结点出队列时，将头队列的值保存起来，这里求最大深度是depth += 1 func maxDepth(_ root: TreeNode?) -> Int { guard let root = root else { return 0 } var depth = 0 var queue: [TreeNode] = [root] while !queue.isEmpty { depth += 1 let size = queue.count for _ in 0.. Int { guard let root = root else { return 0} var queue: [TreeNode] = [root] var list: [Int] = [1] var maxLen = 1 while !queue.isEmpty { let size = queue.count for _ in 0..= 2 { //注意临界条件是大于等于2，因为count为1宽度也是1 maxLen = max(maxLen, list.last! &- list.first! &+ 1) } } return maxLen } 作者：mingriweiji-github 链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/fen-ceng-bian-li-shi-yong-dui-lie-qlai-ji-lu-mei-y/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码实现： guard let root = root else { return 0 } var queue: [(TreeNode, Int)] = [] queue.append((root, 1)) var maxLen = 1 while !queue.isEmpty { let count = queue.count for _ in 0 ..< count { let curr = queue.removeFirst() let index = curr.1 if let left = curr.0.left { queue.append((left, index &* 2)) } if let right = curr.0.right { queue.append((right, index &* 2 + 1)) } } if !queue.isEmpty { maxLen = max(maxLen, queue.last!.1 &- queue.first!.1 &+ 1) } } return maxLen } 7、 验证二叉搜索树1、递归法 递归法解题的关键在于：maxLeft &lt; root.val &lt; minRight 1、临界条件:root==null 2、递归左子树，找到最大值max和根节点root.val进行比较，如果左子树的max大于等于根节点的值，返回false 3、递归右子树，找到右子树的最小值min和根节点root.val比较，如果右子树的min小于等于根节点，返回false public boolean helper(TreeNode root, Integer min, Integer max) { if (root == null) return true; if (min != null && min > root.val) return false; if (max != null && max < root.val) return true; return helper(root.left,min,root.val) && helper(root.right,root.val,max); } public boolean isValidBST(TreeNode root) { return helper(root,null,null); } 上面的help()方法不能通过测试用例[1,1]这种重复元素的数组，判断条件错误，修改如下： Java版本 public boolean helper(TreeNode root, Integer min, Integer max) { if (root == null) return true; if (min != null && min >= root.val) return false; if (max != null && max Bool { guard let root = root else { return true } return helper(root,nil,nil) } func helper(_ root: TreeNode?, _ min: Int?, _ max: Int?) -> Bool { guard let root = root else { return true } //左节点需要小于根节点值 if let min = min, min = root.val { return false } return helper(root.left, root.val,max) && helper(root.right, min, root.val) } 8、对称二叉树解题思路：给定一个二叉树，看它是否镜像对称关键是1、左右子树的值相等 2、左子树的left和右子树的right是镜像对称，利用递归思想容易解决。 24ms代码实现如下: func isSymmetric(_ root: TreeNode?) -> Bool { return isMirror(root,root) } func isMirror(_ p: TreeNode?, _ q: TreeNode?) -> Bool{ //注意临界条件判断，先判断p、q均为空的情况 if p == nil && q == nil { return true } if p == nil || q == nil { return false } return (p!.val == q!.val) && isMirror(p!.left, q!.right) && isMirror(p!.right, q!.left) } 20ms代码实现如下： func isSymmetric(_ root: TreeNode?) -> Bool { guard let root = root else { return true } return isMirror(root.left, root.right) } func isMirror(_ p: TreeNode?, _ q: TreeNode?) -> Bool { if p == nil, q == nil { return true } if let p = p, let q = q, p.val == q.val { return isMirror(p.left, q.right) && isMirror(p.right, q.left) } return false } 第二遍： 执行用时 :16 ms, 在所有 swift 提交中击败了94.96%的用户 内存消耗 :19.9 MB, 在所有 swift 提交中击败了5.00%的用户 func isSymmetric(_ root: TreeNode?) -> Bool { guard let root = root else { return true } return isMirror(root.left, root.right) } func isMirror(_ p: TreeNode?, _ q: TreeNode?) -> Bool { if p == nil && q == nil { return true } if let p = p,let q = q, p.val == q.val { return isMirror(p.left, q.right) && isMirror(p.right, q.left) } return false } 9、翻转一颗二叉树迭代就要遍历二叉树，利用分层遍历用队列交换每个结点的左右子树。 8ms迭代法： func invertTree(_ root: TreeNode?) -> TreeNode? { //迭代法翻转二叉树,交换每一个结点的左右子树，我们用队列储存没有交换过的左右子树的结点，拿到current结点后，交换左右结点，然后再将该节点的左右结点加入到队列中。直到队列为空截止。 guard let root = root else { return nil } var queue: [TreeNode] = [root] while !queue.isEmpty { var node = queue.removeFirst() let temp = node.left node.left = node.right node.right = temp if let left = node.left { queue.append(left) } if let right = node.right { queue.append(right) } } return root } 16ms递归法： func invertTree(_ root: TreeNode?) -> TreeNode? { guard let root = root else { return nil } let temp = root.left root.left = root.right root.right = temp invertTree(root.left) invertTree(root.right) return root } 8ms递归法：同上面的区别是没有解包，解包耗时8ms? func invertTree(_ root: TreeNode?) -> TreeNode? { if root == nil { return nil } let temp = root?.left root?.left = root?.right root?.right = temp invertTree(root?.left) invertTree(root?.right) return root } 第二遍：分层遍历后不要把当前节点放入队列中，我们要的是翻转二叉树，不需要记录当前节点node 6、二叉树搜索树10道常见题目 验证二叉搜索树 二叉搜索树中的插入操作 二叉搜索树中的搜索 删除二叉搜索树中的节点 二叉搜索树的最小绝对差 二叉搜索树结点最小距离 将有序数组转换为二叉搜索树 * 二叉搜索树的范围和 * 二叉搜索树的最近公共祖先 * 二叉搜索树中第K小的元素 ** 二叉搜索树迭代器 ** 恢复二叉搜索树 平衡二叉树 7、合并21. 合并两个有序链表递归法 func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1!.val < l2!.val { l1?.next = mergeTwoLists(l1?.next, l2) return l1 } else { l2?.next = mergeTwoLists(l1, l2?.next) return l2 } } 迭代法 func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? { var l1 = l1 var l2 = l2 let head = ListNode(-1) var cur = head while (l1 != nil && l2 != nil) { //cur.next 记录当前的head if l1!.val = 0) { if (p1 >= 0 && nums1[p1] >= nums2[p2]) { nums1[cur] = nums1[p1] cur -= 1; p1 -= 1 } else { nums1[cur] = nums2[p2] cur -= 1; p2 -= 2 } } } 面试题 16.16. 部分排序func subSort(_ array: [Int]) -> [Int] { //1 从左往右扫描，应该越来越大，出现比max小的，记录下来 //2 从右往左扫描，应该越来越小，出现比min小的，记录下来 //临界条件（array.count < 2） if array.count < 2 { return [-1, -1] } var max = array[0], R = -1 for i in 0..= max { max = v } else { R = i } } //如果有序 if R == -1 { return [-1, -1] } var min = array[array.count - 1], L = -1 for i in (0...(array.count - 2)).reversed() { let v = array[i] if v","categories":[],"tags":[]},{"title":"排序问题","slug":"排序问题","date":"2020-03-15T04:37:17.863Z","updated":"2020-03-16T10:14:05.536Z","comments":true,"path":"2020/03/15/排序问题/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/15/%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"带着问题去学习，是最有效的学习方法。所以按照惯例，我还是先给你出一个思考题： 为什么插入排序比冒泡排序更受欢迎？如何分析一个“排序算法”？ 最好情况、最坏情况、平均情况时间复杂度 时间复杂度的系数、常数、低阶 比较次数和交换次数 2、内存消耗 原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。(冒泡排序、插入排序) 3、稳定性 经过某种排序算法排序之后，如果两个相同数值的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法； 如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。 冒泡排序 冒泡排序只会操作相邻元素的两个数据 每次都是对相邻的两个元素比较大小，前面的元素大于后面的元素，交换前后元素，一轮循环后最后元素就是最大元素 第二轮循环后，倒数第二个元素就是第二大元素 直到所有元素都是有序的停止排序 冒泡排序图示： /// 冒泡排序 func bubbleSort&lt;T>(_ array: [T]) -> [T] where T: Comparable{ var array = array guard array.count > 1 else { return array } for i in 0..&lt;array.count { //提前退出标志 var flag: Bool = false for j in 0..&lt;array.count - i - 1 { if array[j] > array[j + 1] { array.swapAt(j + 1, j) //有数据交换 flag = true } } //没有数据交换-提前退出 if flag == false { break } } return array } 现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。 第一，冒泡排序是原地排序算法吗？冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。 第二，冒泡排序是稳定的排序算法吗？在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。 第三，冒泡排序的时间复杂度是多少？最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。平均时间复杂度也是O(n2) 插入排序 插入排序是将数组分成两个部分，已排序和未排序 初始化已排序部分只有一个元素就是数组第一个元素 插入排序的核心思想就是取出未排序部分的元素，在已排序区间中找到合适的插入位置插入，保证已排序区间的数据一直是有序的。 插入排序如下图： ///插入排序 func insertSort&lt;T>(_ elements: [T]) -> [T] where T: Comparable { var array = elements guard array.count > 1 else { return array } for i in 1..&lt;array.count { let value = array[i] var j = i - 1 //查找要插入的位置 for p in (0...j).reversed() { if array[p] > value { array[p+1] = array[p]//移动数据 } else { break } } array[j+1] = value// 插入数据 } return array } 插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。 对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度 = 满有序度-初始有序度。 现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。 第一，插入排序是原地排序算法吗？插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。 第二，插入排序是稳定的排序算法吗？在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。 第三，插入排序的时间复杂度是多少？ 如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。 如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。 还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n2)。 选择排序（Selection Sort）选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。 第一，选择排序是原地排序算法吗？选择排序的时间复杂度是O(1)所以是原地排序 第二，选择排序是稳定的排序算法吗？不是稳定排序，对于选择排序来说每次都是从未排序序列中找到最小的插入到已排序序列的末尾处，和前面的元素交换，这样会破坏稳定性 比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。\\ 第三，选择排序的时间复杂度是多少？选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。 总结三种时间复杂度是 O(n2) 的排序算法 这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高，所以我们更倾向于用下一节要讲的时间复杂度为 O(nlogn) 的排序算法。 思考一个问题：如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？归并排序快速排序","categories":[],"tags":[]},{"title":"反转问题","slug":"反转问题","date":"2020-03-15T03:35:25.039Z","updated":"2020-03-15T04:25:50.290Z","comments":true,"path":"2020/03/15/反转问题/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/15/%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98/","excerpt":"","text":"字符串反转方法一：递归 原地反转字符串是否代表了空间复杂度为常数？不，原地反转字符串是一种不使用辅助数据结构的算法。 我们使用递归的方法去反转字符串，它是原地反转，但是空间复杂度却不是常数级空间，因为递归过程中使用了堆栈空间。 算法过程 我们实现递归函数 helper，它接受两个参数：left 左指针和 right 右指针。 如果 left&gt;=right，不做任何操作。 否则交换 s[left] 和 s[right] 和调用 helper(left + 1, right - 1)。 首次调用函数我们传递首尾指针反转整个字符串 return helper(0, len(s) - 1)。 public void helper(char[] s, int left, int right) { if (left >= right) return; char tmp = s[left]; s[left++] = s[right]; s[right--] = tmp; helper(s, left, right); } public void reverseString(char[] s) { helper(s, 0, s.length - 1); } 复杂度分析时间复杂度：\\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。 空间复杂度：\\mathcal{O}(N)O(N)，递归过程中使用的堆栈空间。 方法二：双指针法双指针法是使用两个指针，一个左指针 left，右指针 right，开始工作时 left 指向首元素，right 指向尾元素。交换两个指针指向的元素，并向中间移动，直到两个指针相遇。 算法过程 将 left 指向首元素，right 指向尾元素。 当 left&lt;right： 交换 s[left] 和 s[right]。 left++ right++ // 双指针 func reverseStr(_ s: inout [Character]) -> [Character]{ var left = 0, right = s.count - 1 while left &lt; right { (s[left],s[right]) = (s[right],s[left]) left += 1 right -= 1 } return s } 测试用例let str = \"123456abcdef\" var characters = Array(str) print(characters)//[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] print(reverseStr(&amp;characters))//[\"f\", \"e\", \"d\", \"c\", \"b\", \"a\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"] 复杂度分析时间复杂度：\\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。空间复杂度：\\mathcal{O}(1)O(1)，只使用了常数级空间。 反转链表双指针法 定义两个指针pre cur : pre在前 cur 在后 如果cur节点不为空，设置pre.next = cur 实现一次翻转 翻转后pre 、cur同步向前一步 当pre为空终止循环 func reverseList(_ head: ListNode?) -> ListNode? { if head == nil || head?.next == nil { return head } var pre = head, cur: ListNode? while pre != nil { let temp = pre?.next pre?.next = cur cur = pre! pre = temp } return cur } 递归法核心：reversList(head) = reverseList(head.next) func reverseList2(_ head: ListNode?) -> ListNode? { if head == nil || head?.next == nil { return nil } let newHead = reverseList2(head?.next) head?.next?.next = head head?.next = nil return newHead } 反转链表 II题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明:1 ≤ m ≤ n ≤ 链表长度 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL题解思路 第一步：找到待反转节点的前一个节点。第二步：反转m到n这部分。第三步：将反转的起点的next指向反转的后面一部分。第四步：将第一步找到的节点指向反转以后的头节点。 public ListNode reverseBetween(ListNode head, int m, int n) { ListNode res = new ListNode(0); res.next = head; ListNode node = res; //找到需要反转的那一段的上一个节点。 for (int i = 1; i &lt; m; i++) { node = node.next; } //node.next就是需要反转的这段的起点。 ListNode nextHead = node.next; ListNode next = null; ListNode pre = null; //反转m到n这一段 for (int i = m; i &lt;= n; i++) { next = nextHead.next; nextHead.next = pre; pre = nextHead; nextHead = next; } //将反转的起点的next指向next。 node.next.next = next; //需要反转的那一段的上一个节点的next节点指向反转后链表的头结点 node.next = pre; return res.next; }","categories":[],"tags":[]},{"title":"智力题","slug":"智力题","date":"2020-03-15T02:44:43.844Z","updated":"2020-03-15T03:31:45.729Z","comments":true,"path":"2020/03/15/智力题/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/15/%E6%99%BA%E5%8A%9B%E9%A2%98/","excerpt":"","text":"智力题1、有两个水桶， 一个装 3L 的水， 一个可装 5L 的水， 问:如何利用这两个桶， 量出 4L 的水来？解法一加法：操作两次3L的桶，得到1L的水，然后倒入5L的桶里面，此时5L桶里有1L的水，再次用3L的桶倒入5L桶，1L+ 3L = 4L,一共操作3次3L桶 加法解法图示： 解法二减法：5L满水的桶倒入3L的桶，剩余2L，5L桶剩余的2L再次倒入3L桶，此时3L桶还有1L集满，5L桶再次装满后倒出来1L给3L桶里面，5L - 1L = 4L,连续操作3次5L桶 减法解法图示： 2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？首先2的6次方64，2的7次方128 &gt; 100因此我们可以用7个的二进制给100个瓶子编号，7只老鼠分别对应7个二进制位，如果瓶子编号出现1，老鼠喝下瓶子中的毒药，最后统计出被毒死老鼠的二进制数，转换为10进制就是有毒瓶子的编号。 解法图示：","categories":[],"tags":[]},{"title":"Runloop","slug":"Runloop","date":"2020-03-11T13:16:28.012Z","updated":"2020-03-13T17:26:08.484Z","comments":true,"path":"2020/03/11/Runloop/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/11/Runloop/","excerpt":"","text":"Runloop1.讲讲 RunLoop，项目中有用到吗？ 事件循环，在程序运行中循环做一些事情 没有消息mach_msg()切换用户态到内核态线程休眠，有消息内核态切换到用户态 runloop相关： Timer、performSelector GCD、AutoreleasePool 事件响应、收拾识别、网络请求 runloop的应用： 线程包活 解决timer滑动停止问题 监听主线程卡顿 性能优化 2.runloop的6种状态和runloop内部实现逻辑？/* Run Loop Observer Activities */ typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出Loop kCFRunLoopAllActivities = 0x0FFFFFFFU }; source0 : 触摸事件、performSelectorOnThread: source1: 基于Port的线程间通讯，捕获到的系统事件 timers: NSTimer + performSelector:afterDelay: observers: 监听runloop的状态/autoreleasePool的创建和释放、UI的刷新 3.runloop和线程的关系？ 一一对应 保存在一个全局字典中，线程是key, runloop是value 子线程默认没有runloop，在第一次获取runloop时才会创建。 runloop在线程结束时销毁 4.timer 与 runloop 的关系？程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？5.runloop 是怎么响应用户操作的， 具体流程是什么样的？6.说说runLoop的几种状态7.runloop的mode作用是什么？ CFRunLoopModeRef代表RunLoop的运行模式 一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer RunLoop启动时只能选择其中一个Mode，作为currentMode 如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入 不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响 如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出 8.KVO实现原理?哪些情况下使用kvo会崩溃，怎么防护崩溃?9.如何手动关闭KVO?如何手动自己实现KVO说说思路10.通过KVC修改属性会触发KVO么","categories":[],"tags":[]},{"title":"多线程","slug":"多线程","date":"2020-03-11T12:34:15.299Z","updated":"2020-03-13T20:37:44.285Z","comments":true,"path":"2020/03/11/多线程/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"1、你理解的多线程？并发和串行，同步和异步 同步和异步的区别: 是否开辟新的线程，同步只能在当前线程执行任务，异步可以再新的线程执行任务 串行和并发的区别是任务执行的顺序，串行任务只能顺序执行，并发可以多个任务同时执行。 2、iOS多线程有哪些？常用哪个？ NSThread、GCD/NSOperationQueue 常用GCD/NSOperation GCD 的队列类型有哪些？OperationQueue 和 GCD 的区别？ GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择； 在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)； NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行； 我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样子能比GCD更加有效地掌控我们执行的后台任务； 在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码； 我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。 总的来说，Operation queue 提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。 从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。 如何用gcd实现以下功能？ 异步并发执行任务1、任务2 等任务1、任务2都执行完毕后，再回到主线程执行任务3 线程安全是什么？如何处理线程安全的问题？ 我们一般通过线程同步方案如加锁的方式来实现线程的安全 iOS锁的原理 | 深入浅出iOS系统内核-同步机制 os_unfair_lock：iOS10开始os_unfair_lock来替代OSSpinLock, 等待锁的线程会进入休眠不占用CPU资源， 这个os_unfair_lock解决了优先级翻转问题。 OSSpinLock: 自旋锁，线程忙等一直占用CUP资源，不安全因为可能出现优先级翻转的可能 dispatch_semaphore：信号量为1的semaphore也可以看做是锁 pthread_mutex：mutex是互斥锁，等待锁的线程处于休眠状态，pthread_mutex是递归锁，可以递归调用。 使用GCD的串行队列也可以实现锁的功能 NSLock是对metex互斥锁的封装，NSRecurisiveLock也是对metex的递归封装，API和NSLock一直。 NSCondition NSConditionLock @synchorized也是mutex的递归封装，@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作。 自旋锁和互斥锁如何选择？自旋锁OSSpinLock：当线程获取锁，其他等待锁的线程会忙等一直占用CPU,自旋锁有优先级翻转的可能性，所以苹果已经弃用自旋锁OSSpinLock改用os_unfair_lock. 互斥锁mutext：阻塞线程并休眠，其他线程才能正常访问，用互斥的方式来保证线程的安全。 递归锁：顾名思义，可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。 什么情况使用自旋锁比较划算？ 预计线程等待锁的时间很短 加锁的代码（临界区）经常被调用，但竞争情况很少发生 CPU资源不紧张 多核处理器 什么情况使用互斥锁比较划算？ 预计线程等待锁的时间较长 单核处理器 临界区有IO操作 临界区代码复杂或者循环量大 临界区竞争非常激烈 追问二：使用以上锁需要注意哪些？ 追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！ iOS线程同步方案性能比较性能从高到低排序: os_unfair_lock &gt; OSSpinLock &gt; dispatch_semaphore &gt; pthread_mutex &gt; dispatch_queue(DISPATCH_QUEUE_SERIAL) &gt; NSLock &gt; NSCondition &gt; pthread_mutex(recursive) &gt; NSRecursiveLock &gt; NSConditionLock &gt; @synchronized如何实现多度单写？dispatch_barrier_async 这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的 如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果 pthread_rwlock读写锁-等待锁的线程进入休眠 ‌","categories":[],"tags":[]},{"title":"红黑树前世今生","slug":"红黑树前世今生","date":"2019-12-30T07:28:54.939Z","updated":"2019-12-30T07:28:54.939Z","comments":true,"path":"2019/12/30/红黑树前世今生/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/30/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/","excerpt":"","text":"红黑树前世今生关键词：二叉搜索树、前驱节点、后继节点、B树、红黑树 什么是B树前世B树是一种相对于来说特殊二叉搜索树，多用于数据库和文件搜索系统中。 n阶B树的性质 B树是一种平衡的多路搜索树，拥有平衡二叉树的一些特性，与平衡二叉树的最大区别在于每个节点不再是只能存储一个元素，而且每个节点可以拥有多个子节点而像二叉平衡树只能拥有两个。 B树每个节点最多可以存储超过2个元素，可以拥有超过2个子节点 B树每个子节点的子树高度一致 B树和二叉搜索树一样，左子树&lt;根节点&lt;右子树 根节点元素个数: 1≤ X ≤ n - 1 非根节点元素个数: n/2 - 1 ≤ x ≤ n - 1 (n/2 向上取整) 如果有子节点，子节点个数 y = x + 1, 根节点 2 ≤ y ≤ n非根节点 n / 2 ≤ y ≤ n (n/2 向上取整) 数据库中一般使用的是200-300阶B树 4阶B树元素个数为(2-3-4)，所以4阶B树也叫2-4树或者2-3-4树 5阶B树元素个数为 3-4-5 所以5阶B树叫（3，5）树 6阶B树元素个数3-4-5-6，所以6阶B树叫（3，6）树 7阶B树元素个数为4-5-6-7，所以7阶B树叫（4，7）树 B树 VS 二叉搜索树 B树与二叉搜索树逻辑上等价 n阶B树最多需要log2 N代合并 多代节点合并可以获得超节点 2代合并最多拥有4个子节点 3代合并最多拥有8个子节点 n代合并最多拥有2^n个子节点（至少是2^n阶B树） B树的添加与上溢上溢出（overflow）:添加元素到子节点后，该节点元素个数大于N时，我们称之为上溢出 B树的元素添加的位置一定是叶子节点 B树添加导致上溢 B树上溢最极端的情况是一直分裂到根节点 B树的删除与下溢删除 删除叶子节点的话直接删除 删除的非叶子节点的话：1、先找到前驱或后继节点元素，覆盖需要删除的值，2、把前驱或后继元素删除（说明：一个树的前驱在左子树的最后边，后驱在右子树的最左边。） 非叶子节点前驱或后继元素，必然是在叶子节点中，所以真正删除的元素都是叶子节点 下溢出（underflow）：叶子节点被删除一个元素后，元素个数可能会低于最低限制 （n/2 - 1 向上取整） 下溢出的解决方案是旋转，总体元素是哪个方向失衡往哪个方向转，子树大小顺序不能乱 4阶B树 4阶B树所有节点都能储存的元素个数x: 1 ≤ x ≤ 3 4阶B树非叶子节点的子节点个数：2 ≤ y ≤ 4 为什么需要红黑树?红黑树是在二叉搜索树的基础上对AVL树的改进，二叉搜索树顾名思义是对搜索算法的一种优化，能够大大减少我们元素对比的次数。红黑树在Java中的应用如HashSet(底层是数组单链表和红黑树)、数据库搜索也有应用。 什么是红黑树？红黑树是一种自平衡的二叉搜索树也叫平衡二叉B树 红黑树5个性质 节点分为红色与黑色 根节点是黑色 叶子节点是黑色 不能有两个连续的红色节点 从任意节点到叶子节点上所有路径的黑色节点数目必须相等 红黑树等价变换红黑树等价于4阶B树 红黑树添加失衡如何解决？添加失衡 Parrent节点为黑色时不需要处理 Parrent节点为红色（Double Red） Uncle节点不是red: LL/RR LR/RL Uncle节点是red: 红黑树删除节点失衡如何解决？红黑树 VS AVL树搜索性能添加删除实际应用Java8中的hashMap是使用数组+链表实现的，在解决哈希碰撞时使用了红黑树。","categories":[],"tags":[]},{"title":"二叉树前世今生","slug":"二叉树前世今生","date":"2019-12-30T07:28:54.936Z","updated":"2019-12-30T07:28:54.937Z","comments":true,"path":"2019/12/30/二叉树前世今生/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/","excerpt":"","text":"二叉树今生为什么会有二叉树这种数据结构？ 思考一个问题：如果一个集合中有42亿个元素，让你从这42亿个元素中搜索某一个元素，你需要多少次操作？ 如果使用数组链表的话最多可能需要42亿次比较，而如果使用二叉树我们只需要32次比较即可，这就是二叉树存在的价值。Java中的HashSet使用的就是二叉树 前驱与后继前驱节点 若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode） 若一个节点没有左子树，那么判断该节点和其父节点的关系 2.1 若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。 2.2 若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点 后继节点 若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode） 若一个节点没有右子树，那么判断该节点和其父节点的关系2.1 若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点2.2 若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点 如何判断两个二叉树是否相同？ 递归法 static public bool IsSameTree(TreeNode root1, TreeNode root2) { if (root1 == null && root2 == null) { return true; } if ((root1 == null && root2 != null) || (root1 != null && root2 == null)) { return false; } if (root1.val != root2.val) {//判断每个节点的值是否相等，如果去除此判断，则判断两个二叉树是否结构相等 return false; } return IsSameTree(root1.left, root2.left) && IsSameTree(root1.right, root2.right); } 非递归法 bool BTreeCompare（BTreeNode_t *pRoot1, BTreeNode_t *pRoot2) { if( pRoot1 == NULL && pRoot2 == NULL ) return false; queue que1; queue que2; que1.push(pRoot1); que2.push(pRoot2); int curLevelNodeTotal1 = 0; int curLevelNodeTotal2 = 0; bool flag = true; //作为比较不一致时跳出标识 while( ( !que1.empty()) && ( !que2.empty())) //当两个队列均不为空时，才进行比较 { curLevelNodeTotal1 = que1.size(); //获取树1的当前层节点总数 curLevelNodeTotal2 = que2.size(); //获取树2的当前层节点总数 if( curLevelNodeTotal1 != curLevelNodeTotal2){ flag = false;//当前层节点总数都不一致，不需要比较了，直接跳出 break; } int cnt1 = 0;//遍历本层节点时的计数器 int cnt2 = 0; while( cnt1 < curLevelNodeTotal1 && cnt2 < curLevelNodeTotal2){ ++cnt1; ++cnt2; pRoot1 = que1.front(); que1.pop(); pRoot2 = que2.front(); que2.pop(); //比较当前节点中数据是否一致 if( pRoot1->m_pElemt != pRoot2->m_pElemt ){ flag = false; break; } //判断pRoot1和pRoot2左右节点结构是否相同 if( ( pRoot1->m_pLeft != NULL && pRoot2->m_pLeft == NULL ) || ( pRoot1->m_pLeft == NULL && pRoot2->m_pLeft != NULL ) || ( pRoot1->m_pRight != NULL && pRoot2->m_pRight == NULL ) || ( pRoot1->m_pRight == NULL && pRoot2->m_pRight != NULL ) ){ flag = false; break; } //将左右节点入队 if( pRoot1->m_pLeft != NULL ) que1.push( pRoot1->m_pLeft); if( pRoot1->m_pRight != NULL ) que1.push( pRoot1->m_pRight); if( pRoot2->m_pLeft != NULL ) que2.push( pRoot2->m_pLeft); if( pRoot2->m_pRight != NULL ) que2.push( pRoot2->m_pRight); } if( flag == false ) break; } //如果比较标志为false，则不相同 if( flag == false ){ while( !que1.empty() ) que1.pop(); while( !que2.empty()) que2.pop(); return false; } return true; }","categories":[],"tags":[]},{"title":"iOS图像处理","slug":"iOS图像处理","date":"2019-12-30T07:28:54.924Z","updated":"2020-03-16T06:51:41.123Z","comments":true,"path":"2019/12/30/iOS图像处理/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/30/iOS%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"iOS图像优化技巧iOS内存分配图像渲染优化的时机和理由在开始之前，让我们先讨论一下为什么需要对图像进行渲染优化。毕竟，UIImageView 会自动根据 contentmode 属性 规定的行为缩放和裁剪图像。在绝大多数情况下，.scaleAspectFit、.scaleAspectFill 或 .scaleToFill 已经完全满足你的所需。 imageView.contentMode = .scaleAspectFit imageView.image = image 那么，什么时候对图像进行渲染优化才有意义呢？ 当它明显大于 UIImageView 显示尺寸的时候 想要完整渲染这张宽高为 12,000 px 的图片，需要高达 20 MB 的空间。对于当今的硬件来说，你可能不会在意这么少兆字节的占用。但那只是它压缩后的尺寸。要展示它，UIImageView 首先需要把 JPEG 数据解码成位图（bitmap），如果要在一个 UIImageView 上按原样设置这张全尺寸图片，你的应用内存占用将会激增到几百兆，对用户明显没有什么好处（毕竟，屏幕能显示的像素有限）。但只要在设置 UIImageView 的 image 属性之前，将图像渲染的尺寸调整成 UIImageView 的大小，你用到的内存就会少一个数量级： 内存消耗 (MB) 无下采样 220.2 下采样 23.7 这个技巧就是众所周知的下采样（downsampling），在这些情况下，它可以有效地优化你应用的性能表现。如果你想了解更多关于下采样的知识或者其它图形图像的最佳实践，请参照 来自 WWDC 2018 的精彩课程。 而现在，很少有应用程序会尝试一次性加载这么大的图像了，但是也跟我从设计师那里拿到的图片资源不会差太多。（认真的吗？一张颜色渐变的 PNG 图片要 3 MB?） 考虑到这一点，让我们来看看有什么不同的方法，可以让你用来对图像进行优化或者下采样。 不用说，这里所有从 URL 加载的示例图像都是针对本地文件。记住，在应用的主线程同步使用网络请求图像绝不是什么好主意。 图像渲染优化技巧优化图像渲染的方法有很多种，每种都有不同的功能和性能特性。我们在本文看到的这些例子，架构层次跨度上从底层的 Core Graphics、vImage、Image I/O 到上层的 Core Image 和 UIKit 都有。 绘制到 UIGraphicsImageRenderer 上 绘制到 Core Graphics Context 上 使用 Image I/O 创建缩略图像 使用 Core Image 进行 Lanczos 重采样 使用 vImage 优化图片渲染 下面的这些数字是多次迭代加载、优化、渲染之前那张 超大地球图片 的平均时间： 耗时 (seconds) 技巧 #1: UIKit 0.1420 技巧 #2: Core Graphics 1 0.1722 技巧 #3: Image I/O 0.1616 技巧 #4: Core Image 2 2.4983 技巧 #5: vImage 2.3126 1设置不同的 CGInterpolationQuality 值出来的结果是一致的，在性能上的差异可以忽略不计。 2若在 CIContext 创建时设置 kCIContextUseSoftwareRenderer 的值为 true，会导致耗时相比基础结果慢一个数量级。 技巧 #1: 绘制到 UIGraphicsImageRenderer 上图像渲染优化的最上层 API 位于 UIKit 框架中。给定一个 UIImage，你可以绘制到 UIGraphicsImageRenderer 的上下文（context）中以渲染缩小版本的图像： import UIKit // 技巧 #1 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { guard let image = UIImage(contentsOfFile: url.path) else { return nil } let renderer = UIGraphicsImageRenderer(size: size) return renderer.image { (context) in image.draw(in: CGRect(origin: .zero, size: size)) } }UIGraphicsImageRenderer 是一项相对较新的技术，在 iOS 10 中被引入，用以取代旧版本的 UIGraphicsBeginImageContextWithOptions / UIGraphicsEndImageContext API。你通过指定以 point 计量的 size 创建了一个 UIGraphicsImageRenderer。image 方法带有一个闭包参数，返回的是一个经过闭包处理后的位图。最终，原始图像便会在缩小到指定的范围内绘制。 技巧 #2：绘制到 Core Graphics Context 中Core Graphics / Quartz 2D 提供了一系列底层 API 让我们可以进行更多高级的配置。 给定一个 CGImage 作为暂时的位图上下文，使用 draw(_:in:) 方法来绘制缩放后的图像： import UIKit import CoreGraphics // 技巧 #2 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil), let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil) else { return nil } let context = CGContext(data: nil, width: Int(size.width), height: Int(size.height), bitsPerComponent: image.bitsPerComponent, bytesPerRow: image.bytesPerRow, space: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!, bitmapInfo: image.bitmapInfo.rawValue) context?.interpolationQuality = .high context?.draw(image, in: CGRect(origin: .zero, size: size)) guard let scaledImage = context?.makeImage() else { return nil } return UIImage(cgImage: scaledImage) }这个 CGContext 初始化方法接收了几个参数来构造一个上下文，包括了必要的宽高参数，还有在给出的色域范围内每个颜色通道所需要的内存大小。在这个例子中，这些参数都是通过 CGImage 这个对象获取的。下一步，设置 interpolationQuality 属性为 .high 指示上下文在保证一定的精度上填充像素。draw(_:in:) 方法则是在给定的宽高和位置绘制图像，可以让图片在特定的边距下裁剪，也可以适用于一些像是人脸识别之类的图像特性。最后 makeImage() 从上下文获取信息并且渲染到一个 CGImage 值上（之后会用来构造 UIImage 对象）。 技巧 #3：使用 Image I/O 创建缩略图像Image I/O 是一个强大（却鲜有人知）的图像处理框架。抛开 Core Graphics 不说，它可以读写许多不同图像格式，访问图像的元数据，还有执行常规的图像处理操作。这个框架通过先进的缓存机制，提供了平台上最快的图片编码器和解码器，甚至可以增量加载图片。 这个重要的 CGImageSourceCreateThumbnailAtIndex 提供了一个带有许多不同配置选项的 API，比起在 Core Graphics 中等价的处理操作要简洁得多： import ImageIO // 技巧 #3 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { let options: [CFString: Any] = [ kCGImageSourceCreateThumbnailFromImageIfAbsent: true, kCGImageSourceCreateThumbnailWithTransform: true, kCGImageSourceShouldCacheImmediately: true, kCGImageSourceThumbnailMaxPixelSize: max(size.width, size.height) ] guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil), let image = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, options as CFDictionary) else { return nil } return UIImage(cgImage: image) }给定一个 CGImageSource 和一系列配置选项，CGImageSourceCreateThumbnailAtIndex(_:_:_:) 函数创建了一个图像的缩略图。优化尺寸大小的操作是通过 kCGImageSourceThumbnailMaxPixelSize 完成的，它根据图像原始宽高比指定的最大尺寸来缩放图像。通过设定 kCGImageSourceCreateThumbnailFromImageIfAbsent 或 kCGImageSourceCreateThumbnailFromImageAlways 选项，Image I/O 可以自动缓存优化后的结果以便后续调用。 总结 UIKit, Core Graphics, 和 Image I/O 都能很好地用于大部分图片的优化操作。 如果（在 iOS 平台，至少）要选择一个的话，UIGraphicsImageRenderer 是你最佳的选择。 Core Image 在图像优化渲染操作方面性能表现优越。实际上，根据 Apple 官方 Core Image 编程规范中的性能最佳实践单元，你应该使用 Core Graphics 或 Image I/O 对图像进行裁剪和下采样，而不是用 Core Image。 除非你已经在使用 vImage，否则在大多数情况下用到底层的 Accelerate API 所需的额外工作可能是不合理的。 本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 http://swift.gg。","categories":[],"tags":[]},{"title":"Swift备忘录","slug":"Swift备忘录","date":"2019-12-07T04:48:29.505Z","updated":"2020-03-13T20:18:13.194Z","comments":true,"path":"2019/12/07/Swift备忘录/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/07/Swift%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"SwiftTip","text":"SwiftTip ##1、@autoclosure作用：将表达式自动封装成一个闭包 ()-&gt;Void 1.2 ??的底层实现是用的enum 1.3 “闭包和循环引用” weak解决循环引用的正确写法： var name: ()->() = { [weak self] in if let strongSelf = self { print(\"The name is (strongSelf.name)\") } } 2、值类型和引用类型的选择 数组和字典设计为值类型最大的考虑是为了线程安全. 另一个优点，那就是非常高效，因为 “一旦赋值就不太会变化” 这种使用情景在 Cocoa 框架中是占有绝大多数的，这有效减少了内存的分配和回收。 但是在少数情况下，我们显然也可能会在数组或者字典中存储非常多的东西，并且还要对其中的内容进行添加或者删除。” 在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好， 对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary 3、@escaping的作用？ class func animate(withDuration duration: TimeInterval, animations: @escaping () -&amp;gt; Void, completion: ((Bool) -> Void)? = nil) 4、defer的使用注意点defer的作用域以前很单纯地认为 defer 是在函数退出的时候调用，并没有注意其实是当前 scope 退出的时候调用这个事实，造成了这个错误。在 if，guard，for，try 这些语句中使用 defer 时，应该要特别注意这一点。 5、@discardableResult6、ResultResult&lt;T, E: Error&gt; 和 Result 7、Lazy的使用 let data = 1...3 let result = data.lazy.map { (i: Int) -> Int in print(\"准备处理(i)\") return i * 2 } print(\"准备访问结果\") for i in result { print(\"处理后的结果:(i)\") } print(\"done\") 打印结果： 准备访问结果 准备处理1 处理后的结果:2 准备处理2 处理后的结果:4 准备处理3 处理后的结果:6 done 8、Swift反射机制Mirror “通过 Mirror 初始化得到的结果中包含的元素的描述都被集合在 children 属性下，如果你有心可以到 Swift 标准库中查找它的定义，它实际上是一个 Child 的集合，而 Child 则是一对键值的多元组： 示例1 struct Car { let logo: String var wheel: Int let door: Int } let baoM = Car(logo: \"BMW\", wheel: 4, door: 2) let mirror = Mirror(reflecting: baoM) print(\"类型:(String(describing: mirror.displayStyle))\") ///1、通过Mirror的children获取属性信息 print(\"属性个数:(mirror.children.count)\") mirror.children.map { (child) -> Any in print(\"label: (String(describing: child.label)), value: (child.value)\") } ///2、通过Refletion的dump(Any)方法获取属性信息 dump(baoM) 示例2 获取property let homeProperty = Mirror(reflecting: self) homeProperty.children.map { LOG.D(\"home property:($0)\") } 9、iOS初始化核心原则 iOS 的初始化最核心两条的规则： • 必须至少有一个指定初始化器，在指定初始化器里保证所有非可选类型属性都得到正确的初始化（有值） • 便利初始化器必须调用其他初始化器，使得最后肯定会调用指定初始化器 在Swift中千万不要用String的count方法计算文本长度。否则当文本中有emoji时，会计算出错。应当转成NSString再去求length。 10、Swift备忘录001 Array for-in使用 1.for in获取索引 index let array = [\"Apple\", \"Google\", \"Amazon\"] for item in array { print(\"company name is :(item)\") } ///配合array.enumerated()使用 for (index, item) in array.enumerated() { print(\"index:(index), item:(item)\") } 2.array.firstIndex(of:)获取index ///配合array.firstIndex(of:)使用 let googleIndex = array.firstIndex(of: \"Google\") print(\"googleIndex is : (googleIndex ?? 0)\") ///配合array.firstIndex(where:)使用 if let index = array.firstIndex(where: { $0.hasPrefix(\"A\") }) { print(\"array.firstIndex is (index)\") } if let item = array.first(where: { $0.hasPrefix(\"A\")}{ print(\"array.first is :(item)\") } Swift备忘录002 Array.forEach()2.1forEach()和函数式编程结合使用 let array = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"] ///使用forEach array.map { Int($0)! }.forEach { num in print(num) } //不使用forEach let map = array.map { Int($0)! } map.forEach { print($0) } 2.2forEach()遍历optional集合会自动过滤nil let optionalString: [String]? = nil //使用forEach强制解包option，会过滤 optionalString?.forEach { str in print(\"str is (str)\") } ///使用for-in强制解包optional，会crash for str in optionalString! { print(\"str is (str)\") } Swift备忘录003 Array index3.1","categories":[],"tags":[]},{"title":"Swift函数式编程","slug":"Swift函数式编程","date":"2019-12-06T01:36:47.815Z","updated":"2020-03-13T20:17:46.842Z","comments":true,"path":"2019/12/06/Swift函数式编程/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/06/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"Functional Programming in Swift函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。","text":"Functional Programming in Swift函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。 不变性和副作用无论您首先学习哪种编程语言，您可能要学习的最初概念之一就是变量代表数据或状态。如果您退一步考虑一下这个想法，变量似乎很奇怪。 术语“变量”表示随程序运行而变化的数量。从数学角度考虑数量问题，您已将时间作为软件行为的关键参数。通过更改变量，可以创建可变状态。 为了进行演示，请将以下代码添加到playground： var thing = 3 //some stuff thing = 4 func superHero() { print(\"I'm batman\") thing = 5 } print(\"original state = \\(thing)\") superHero() print(\"mutated state = \\(thing)\") 神圣的神秘变化！为什么现在是5？这种变化称为副作用。函数superHero（）更改了一个甚至没有定义自己的变量。 单独或在简单系统中，可变状态不一定是问题。将许多对象连接在一起时（例如在大型的面向对象的系统中）会出现问题。可变状态会使人难以理解变量具有什么值以及该值随时间的变化而产生头痛。 例如，在为多线程系统编写代码时，如果两个或多个线程同时访问同一变量，则它们可能会无序地修改或访问它。这会导致意外的行为。这种意外行为包括竞态条件，死锁和许多其他问题。 试想一下，如果您可以编写状态永远不变的代码。并发系统中发生的所有问题都将消失。像这样工作的系统具有不变的状态，这意味着不允许状态在程序过程中进行更改。 使用不可变数据的主要好处是，使用不可变数据的代码单元没有副作用。代码中的函数不会更改其自身之外的元素，并且在发生函数调用时不会出现怪异的效果。您的程序可以正常运行，因为没有副作用，您可以轻松重现其预期的效果。 本教程从较高的层次介绍了FP，因此在实际情况下考虑这些概念会很有帮助。在这种情况下，假设您正在为游乐园构建应用程序，并且该游乐园的后端服务器通过REST API提供了行程数据。 创建Modelenum RideCategory: String { case family case kids case thrill case scary case relaxing case water } typealias Minutes = Double struct Ride { let name: String let categories: Set&lt;RideCategory> let waitTime: Minutes } Create some data using that modellet parkRides = [ Ride(name: \"R45\", categories: [.family, .thrill, .water], waitTime: 45.0), Ride(name: \"R10\", categories: [.family], waitTime: 10.0), Ride(name: \"R15\", categories: [.kids], waitTime: 15.0), Ride(name: \"R30\", categories: [.scary], waitTime: 30.0), Ride(name: \"R60\", categories: [.family, .thrill], waitTime: 60.0), Ride(name: \"R15-2\", categories: [.family, .kids], waitTime: 15.0), Ride(name: \"R25\", categories: [.family, .water], waitTime: 25.0), Ride(name: \"R0\", categories: [.family, .relaxing], waitTime: 0.0) ] FP: Filter Map ReduceMost languages that support FP will have the functions filter, map &amp; reduce. Map Map是将输入Collection中的每个Element转换为新Element。 使用map遍历一个集合，并对集合中的每个元素应用相同的操作。 map函数返回一个数组，其中包含对每个元素的映射或转换函数的结果。 Map on array:let arrayOfInt = [1,2,3,4,5] 如果我们要对每个元素乘上10呢？我们以前可能要这样 var newArr: [Int] = [] for value in arrayOfInt { newArr.append(value * 10) } print(newArr) 现在有map()后我们可以这样： let mapArr = arrayOfInt.map { $0 * 10 } print(mapArr) Working of map: The map function has a single argument which is a closure (a function) that it calls as it loops over the collection. This closure takes the element from the collection as an argument and returns a result. The map function returns these results in an array. Map on Dictionarylet book = [\"A\": 100, \"B\": 80, \"C\": 90] let mapedBook = book.map { (key, value) in key.capitalized } print(mapedBook) //[\"C\", \"B\", \"A\"] Map on Setlet lengthInmeter: Set = [1,3,5] let km = lengthInmeter.map { meter in meter * 1000 } print(km) // [1000, 5000, 3000] Map同时获取array.Index??let nums = [1,2,3,4,5] let newNums = nums.enumerated().map { (index, num) in return num * 10 } print(\"newNums:\\(newNums)\") FilterFilter函数的作用是过滤集合，返回符合条件的集合。 Filter on Arraylet filterArray = [2,4,6,1,5,7] let newFilterArray = filterArray.filter { num -> Bool in num % 2 == 0 } print(newFilterArray) Filter on Dictionarylet book = [\"A\": 100, \"B\": 80, \"C\": 90] let bookFilter = book.filter { (key, value) in value > 80 } print(bookFilter) 简化 let book = [\"A\": 100, \"B\": 80, \"C\": 90] let bookFilter = book.filter { $1 > 80 } $0是key $1是value Filter on Setlet setNums = [4.9,5.5,8.6] let newSet = setNums.filter { $0 > 5.0 } print(newSet) 重要：返回类型是数组 Reduce Use reduce to combine all items in a collection to create a single new value. 使用reduce可以合并集合中的所有元素来创建一个新的value Apple文档声明reduce() func reduce&lt;Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -> Result) rethrows -> Result reduce函数有两个参数： 第一个参数 initial value用来存储初始值或者结果（每次迭代器的结果） 第二个是带有两个参数的闭包，Result是初始值或迭代器的结果，Element是集合中的下一个元素。 Reduce on Arraylet numbers = [1,2,3,4,5,6] let sum = numbers.reduce(0) { x, y in x + y } print(sum) 简化版本：使用$0代表result let reducedSum = numbers.reduce(0) { $0 + $1 } print(reducedSum) ///等价 let reducedSum = numbers.reduce(0, +) print(reducedSum) 乘法 let produceNum = numbers.reduce(1) { x, y in x * y } print(produceNum) ///等价 let produceNum = numbers.reduce(1, *) print(produceNum) Reduce + 连接字符串let charactors = [\"abc\",\"def\",\"hijk\"] let newCharactor = charactors.reduce(\"\", +) print(newCharactor) // abcdefhijk Reduce on Dictionary let dict = [\"A\": 20, \"B\": 100] // Reduce on value let reducedNum = dict.reduce(5) { result, dic in return result + dic.value } print(\"reduc on value is \\(reducedNum)\") // reduc on value is 125 // Reduce on key let reducedName = dict.reduce(\"Charactor are \") { (result, dic) in return result + dic.key + \" \" } print(\"reduce on key is &lt;\\(reducedName)>\") //reduce on key is &lt;Charactor are A B > 简化 let reducedNameOnDic = dict.reduce(\"Charater are \") { $0 + $1.key + \" \"} Reduce on Set// Reduce on Set let lengthMeters = [3.4,1.6] let reducedMeters = lengthMeters.reduce(0.0) { $0 + $1 } print(\"reduced meters :\\(reducedMeters)\") // 5.0 FlatMapFlatmap is used to flatten a collection of collections . But before flattening the collection, we can apply map to each elements. Apple docs says: Returns an array containing the concatenated results of calling the given transformation with each element of this sequence. Flatmap用于展平集合的集合。 但是在展平集合之前，我们可以将map应用于每个集合元素。 let charaters = [\"abc\",\"def\",\"ghi\"] let newCharaters = charaters.flatMap { $0 } print(newCharaters) //[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"] let codes = [[\"abc\",\"def\",\"ghi\"], [\"jkl\",\"mno\",\"pqr\"],[\"stu\",\"vwx\",\"yz\"] ] let newCodes = codes.flatMap {$0.map { $0 } } print(newCodes) // [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\"] nillet nilArray = [2,3,nil] print(nilArray.flatMap { $0 }) // [2,3] // warning: 'flatMap' is deprecated: Please use compactMap(_:) for the case where closure returns an optional value print(nilArray.compactMap { $0 }) // [2,3]","categories":[],"tags":[]}]}