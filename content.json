{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Swift备忘录","slug":"Swift备忘录","date":"2019-12-07T04:48:29.505Z","updated":"2019-12-07T06:45:51.535Z","comments":true,"path":"2019/12/07/Swift备忘录/","link":"","permalink":"http://yoursite.com/2019/12/07/Swift%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"toc = true SwiftTip","text":"toc = true SwiftTip ##1、@autoclosure作用：将表达式自动封装成一个闭包 ()-&gt;Void ####1.2 ??的底层实现是用的enum ####1.3 “闭包和循环引用” weak解决循环引用的正确写法： 12var name: ()-&gt;() = &#123;34[weak self] in56if let strongSelf = self &#123;78print(\"The name is (strongSelf.name)\")910&#125;1112&#125; 2、值类型和引用类型的选择 数组和字典设计为值类型最大的考虑是为了线程安全. 另一个优点，那就是非常高效，因为 “一旦赋值就不太会变化” 这种使用情景在 Cocoa 框架中是占有绝大多数的，这有效减少了内存的分配和回收。 但是在少数情况下，我们显然也可能会在数组或者字典中存储非常多的东西，并且还要对其中的内容进行添加或者删除。” 在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好， 对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary 3、@escaping的作用？12class func animate(withDuration duration: TimeInterval, animations: @escaping () -&amp;gt; Void, completion: ((Bool) -&gt; Void)? = nil) 4、defer的使用注意点defer的作用域以前很单纯地认为 defer 是在函数退出的时候调用，并没有注意其实是当前 scope 退出的时候调用这个事实，造成了这个错误。在 if，guard，for，try 这些语句中使用 defer 时，应该要特别注意这一点。 5、@discardableResult6、ResultResult&lt;T, E: Error&gt; 和 Result 7、Lazy的使用12let data = 1...334let result = data.lazy.map &#123; (i: Int) -&gt; Int in56print(\"准备处理(i)\")78return i * 2910&#125;1112print(\"准备访问结果\")1314for i in result &#123;1516print(\"处理后的结果:(i)\")1718&#125;1920print(\"done\") 打印结果： 准备访问结果 准备处理1 处理后的结果:2 准备处理2 处理后的结果:4 准备处理3 处理后的结果:6 done 8、Swift反射机制Mirror “通过 Mirror 初始化得到的结果中包含的元素的描述都被集合在 children 属性下，如果你有心可以到 Swift 标准库中查找它的定义，它实际上是一个 Child 的集合，而 Child 则是一对键值的多元组： 示例112struct Car &#123;34let logo: String56var wheel: Int78let door: Int910&#125;1112let baoM = Car(logo: \"BMW\", wheel: 4, door: 2)1314let mirror = Mirror(reflecting: baoM)1516print(\"类型:(String(describing: mirror.displayStyle))\")1718///1、通过Mirror的children获取属性信息1920print(\"属性个数:(mirror.children.count)\")2122mirror.children.map &#123; (child) -&gt; Any in2324print(\"label: (String(describing: child.label)), value: (child.value)\")2526&#125;2728///2、通过Refletion的dump(Any)方法获取属性信息2930dump(baoM) 示例2 获取property12let homeProperty = Mirror(reflecting: self)34homeProperty.children.map &#123;56LOG.D(\"home property:($0)\")78&#125; 9、iOS初始化核心原则 iOS 的初始化最核心两条的规则： • 必须至少有一个指定初始化器，在指定初始化器里保证所有非可选类型属性都得到正确的初始化（有值） • 便利初始化器必须调用其他初始化器，使得最后肯定会调用指定初始化器 在Swift中千万不要用String的count方法计算文本长度。否则当文本中有emoji时，会计算出错。应当转成NSString再去求length。 10、Swift备忘录001 Array for-in使用 1.for in获取索引 index1let array = [\"Apple\", \"Google\", \"Amazon\"]2 for item in array &#123;3 print(\"company name is :(item)\")4 &#125;5 ///配合array.enumerated()使用6 for (index, item) in array.enumerated() &#123;7 print(\"index:(index), item:(item)\")8 &#125; 2.array.firstIndex(of:)获取index1///配合array.firstIndex(of:)使用2 let googleIndex = array.firstIndex(of: \"Google\")3 print(\"googleIndex is : (googleIndex ?? 0)\")4///配合array.firstIndex(where:)使用5 if let index = array.firstIndex(where: &#123; $0.hasPrefix(\"A\") &#125;) &#123;6 print(\"array.firstIndex is (index)\")7 &#125;8 if let item = array.first(where: &#123; $0.hasPrefix(\"A\")&#125;&#123;9 print(\"array.first is :(item)\")10 &#125; Swift备忘录002 Array.forEach()2.1forEach()和函数式编程结合使用1let array = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"]2 ///使用forEach3 array.map &#123; Int($0)! &#125;.forEach &#123; num in4 print(num)5 &#125;6 //不使用forEach7 let map = array.map &#123; Int($0)! &#125;8 map.forEach &#123;9 print($0)10 &#125; 2.2forEach()遍历optional集合会自动过滤nil1let optionalString: [String]? = nil2 //使用forEach强制解包option，会过滤3 optionalString?.forEach &#123; str in4 print(\"str is (str)\")5 &#125;6 ///使用for-in强制解包optional，会crash7 for str in optionalString! &#123;8 print(\"str is (str)\")9 &#125; Swift备忘录003 Array index3.1","categories":[],"tags":[]},{"title":"Swift函数式编程","slug":"Swift函数式编程","date":"2019-12-06T01:36:47.815Z","updated":"2019-12-07T06:45:58.692Z","comments":true,"path":"2019/12/06/Swift函数式编程/","link":"","permalink":"http://yoursite.com/2019/12/06/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"Functional Programming in Swift函数式编程介绍。版本：Swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。","text":"Functional Programming in Swift函数式编程介绍。版本：Swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。 不变性和副作用无论您首先学习哪种编程语言，您可能要学习的最初概念之一就是变量代表数据或状态。如果您退一步考虑一下这个想法，变量似乎很奇怪。 术语“变量”表示随程序运行而变化的数量。从数学角度考虑数量问题，您已将时间作为软件行为的关键参数。通过更改变量，可以创建可变状态。 为了进行演示，请将以下代码添加到playground： 1var thing = 32//some stuff3thing = 445func superHero() &#123;6 print(\"I'm batman\")7 thing = 58&#125;910print(\"original state = \\(thing)\")11superHero()12print(\"mutated state = \\(thing)\") 神圣的神秘变化！为什么现在是5？这种变化称为副作用。函数superHero（）更改了一个甚至没有定义自己的变量。 单独或在简单系统中，可变状态不一定是问题。将许多对象连接在一起时（例如在大型的面向对象的系统中）会出现问题。可变状态会使人难以理解变量具有什么值以及该值随时间的变化而产生头痛。 例如，在为多线程系统编写代码时，如果两个或多个线程同时访问同一变量，则它们可能会无序地修改或访问它。这会导致意外的行为。这种意外行为包括竞态条件，死锁和许多其他问题。 试想一下，如果您可以编写状态永远不变的代码。并发系统中发生的所有问题都将消失。像这样工作的系统具有不变的状态，这意味着不允许状态在程序过程中进行更改。 使用不可变数据的主要好处是，使用不可变数据的代码单元没有副作用。代码中的函数不会更改其自身之外的元素，并且在发生函数调用时不会出现怪异的效果。您的程序可以正常运行，因为没有副作用，您可以轻松重现其预期的效果。 本教程从较高的层次介绍了FP，因此在实际情况下考虑这些概念会很有帮助。在这种情况下，假设您正在为游乐园构建应用程序，并且该游乐园的后端服务器通过REST API提供了行程数据。 创建Model1enum RideCategory: String &#123;2 case family3 case kids4 case thrill5 case scary6 case relaxing7 case water8&#125;910typealias Minutes = Double11struct Ride &#123;12 let name: String13 let categories: Set&lt;RideCategory&gt;14 let waitTime: Minutes15&#125; Create some data using that model1let parkRides = [2 Ride(name: \"R45\",3 categories: [.family, .thrill, .water],4 waitTime: 45.0),5 Ride(name: \"R10\", categories: [.family], waitTime: 10.0),6 Ride(name: \"R15\", categories: [.kids], waitTime: 15.0),7 Ride(name: \"R30\", categories: [.scary], waitTime: 30.0),8 Ride(name: \"R60\",9 categories: [.family, .thrill],10 waitTime: 60.0),11 Ride(name: \"R15-2\", categories: [.family, .kids], waitTime: 15.0),12 Ride(name: \"R25\", categories: [.family, .water], waitTime: 25.0),13 Ride(name: \"R0\",14 categories: [.family, .relaxing],15 waitTime: 0.0)16 ] FP: Filter Map ReduceMost languages that support FP will have the functions filter, map &amp; reduce. Map Map是将输入Collection中的每个Element转换为新Element。 使用map遍历一个集合，并对集合中的每个元素应用相同的操作。 map函数返回一个数组，其中包含对每个元素的映射或转换函数的结果。 Map on array:1let arrayOfInt = [1,2,3,4,5] 如果我们要对每个元素乘上10呢？我们以前可能要这样 1var newArr: [Int] = []2for value in arrayOfInt &#123;3 newArr.append(value * 10)4&#125;5print(newArr) 现在有map()后我们可以这样： 1let mapArr = arrayOfInt.map &#123; $0 * 10 &#125;2print(mapArr) Working of map: The map function has a single argument which is a closure (a function) that it calls as it loops over the collection. This closure takes the element from the collection as an argument and returns a result. The map function returns these results in an array. Map on Dictionary1let book = [\"A\": 100, \"B\": 80, \"C\": 90]2let mapedBook = book.map &#123; (key, value) in3 key.capitalized4&#125;5print(mapedBook) //[\"C\", \"B\", \"A\"] Map on Set1let lengthInmeter: Set = [1,3,5]2let km = lengthInmeter.map &#123; meter in meter * 1000 &#125;3print(km) // [1000, 5000, 3000] Map同时获取array.Index??1let nums = [1,2,3,4,5]2let newNums = nums.enumerated().map &#123; (index, num) in3 return num * 104&#125;5print(\"newNums:\\(newNums)\") FilterFilter函数的作用是过滤集合，返回符合条件的集合。 Filter on Array1let filterArray = [2,4,6,1,5,7]2let newFilterArray = filterArray.filter &#123; num -&gt; Bool in3 num % 2 == 04&#125;5print(newFilterArray) Filter on Dictionary1let book = [\"A\": 100, \"B\": 80, \"C\": 90]2let bookFilter = book.filter &#123; (key, value) in3 value &gt; 804&#125;5print(bookFilter) 简化 1let book = [\"A\": 100, \"B\": 80, \"C\": 90]2let bookFilter = book.filter &#123;3 $1 &gt; 804&#125; $0是key $1是value Filter on Set1let setNums = [4.9,5.5,8.6]2let newSet = setNums.filter &#123;3 $0 &gt; 5.04&#125;5print(newSet) 重要：返回类型是数组 Reduce Use reduce to combine all items in a collection to create a single new value. 使用reduce可以合并集合中的所有元素来创建一个新的value Apple文档声明reduce() 1func reduce&lt;Result&gt;(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -&gt; Result) rethrows -&gt; Result reduce函数有两个参数： 第一个参数 initial value用来存储初始值或者结果（每次迭代器的结果） 第二个是带有两个参数的闭包，Result是初始值或迭代器的结果，Element是集合中的下一个元素。 Reduce on Array1let numbers = [1,2,3,4,5,6]2let sum = numbers.reduce(0) &#123; x, y in3 x + y4&#125;5print(sum) 简化版本：使用$0代表result 1let reducedSum = numbers.reduce(0) &#123; $0 + $1 &#125;2print(reducedSum)3///等价4let reducedSum = numbers.reduce(0, +)5print(reducedSum) 乘法 1let produceNum = numbers.reduce(1) &#123; x, y in2 x * y3&#125;4print(produceNum)5///等价6let produceNum = numbers.reduce(1, *)7print(produceNum) Reduce + 连接字符串1let charactors = [\"abc\",\"def\",\"hijk\"]2let newCharactor = charactors.reduce(\"\", +)3print(newCharactor) // abcdefhijk Reduce on Dictionary12let dict = [\"A\": 20, \"B\": 100]34// Reduce on value5let reducedNum = dict.reduce(5) &#123; result, dic in6 return result + dic.value7&#125;8print(\"reduc on value is \\(reducedNum)\") 9// reduc on value is 1251011// Reduce on key12let reducedName = dict.reduce(\"Charactor are \") &#123; (result, dic) in13 return result + dic.key + \" \"14&#125;15print(\"reduce on key is &lt;\\(reducedName)&gt;\") 16//reduce on key is &lt;Charactor are A B &gt; 简化 12let reducedNameOnDic = dict.reduce(\"Charater are \") &#123; $0 + $1.key + \" \"&#125; Reduce on Set1// Reduce on Set2let lengthMeters = [3.4,1.6]3let reducedMeters = lengthMeters.reduce(0.0) &#123;4 $0 + $15&#125;6print(\"reduced meters :\\(reducedMeters)\") // 5.0 FlatMapFlatmap is used to flatten a collection of collections . But before flattening the collection, we can apply map to each elements. Apple docs says: Returns an array containing the concatenated results of calling the given transformation with each element of this sequence. Flatmap用于展平集合的集合。 但是在展平集合之前，我们可以将map应用于每个集合元素。 1let charaters = [\"abc\",\"def\",\"ghi\"]2let newCharaters = charaters.flatMap &#123; $0 &#125;3print(newCharaters)4//[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"]56let codes = [[\"abc\",\"def\",\"ghi\"], [\"jkl\",\"mno\",\"pqr\"],[\"stu\",\"vwx\",\"yz\"] ]7let newCodes = codes.flatMap &#123;$0.map &#123; $0 &#125; &#125;8print(newCodes)9// [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\"] nil1let nilArray = [2,3,nil]2print(nilArray.flatMap &#123; $0 &#125;) // [2,3]3// warning: 'flatMap' is deprecated: Please use compactMap(_:) for the case where closure returns an optional value4print(nilArray.compactMap &#123; $0 &#125;) // [2,3]","categories":[],"tags":[]}]}