{"meta":{"title":"明日危机","subtitle":"iOS & Swifter","description":"","author":"KM","url":"https://mingriweiji-github.github.io","root":"/"},"pages":[],"posts":[{"title":"反转问题","slug":"反转问题","date":"2020-03-15T03:35:25.039Z","updated":"2020-03-15T04:25:50.290Z","comments":true,"path":"2020/03/15/反转问题/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/15/%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98/","excerpt":"","text":"字符串反转方法一：递归 原地反转字符串是否代表了空间复杂度为常数？不，原地反转字符串是一种不使用辅助数据结构的算法。 我们使用递归的方法去反转字符串，它是原地反转，但是空间复杂度却不是常数级空间，因为递归过程中使用了堆栈空间。 算法过程 我们实现递归函数 helper，它接受两个参数：left 左指针和 right 右指针。 如果 left&gt;=right，不做任何操作。 否则交换 s[left] 和 s[right] 和调用 helper(left + 1, right - 1)。 首次调用函数我们传递首尾指针反转整个字符串 return helper(0, len(s) - 1)。 public void helper(char[] s, int left, int right) { if (left >= right) return; char tmp = s[left]; s[left++] = s[right]; s[right--] = tmp; helper(s, left, right); } public void reverseString(char[] s) { helper(s, 0, s.length - 1); } 复杂度分析时间复杂度：\\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。 空间复杂度：\\mathcal{O}(N)O(N)，递归过程中使用的堆栈空间。 方法二：双指针法双指针法是使用两个指针，一个左指针 left，右指针 right，开始工作时 left 指向首元素，right 指向尾元素。交换两个指针指向的元素，并向中间移动，直到两个指针相遇。 算法过程 将 left 指向首元素，right 指向尾元素。 当 left&lt;right： 交换 s[left] 和 s[right]。 left++ right++ // 双指针 func reverseStr(_ s: inout [Character]) -> [Character]{ var left = 0, right = s.count - 1 while left &lt; right { (s[left],s[right]) = (s[right],s[left]) left += 1 right -= 1 } return s } 测试用例let str = \"123456abcdef\" var characters = Array(str) print(characters)//[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] print(reverseStr(&amp;characters))//[\"f\", \"e\", \"d\", \"c\", \"b\", \"a\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"] 复杂度分析时间复杂度：\\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。空间复杂度：\\mathcal{O}(1)O(1)，只使用了常数级空间。 反转链表双指针法 定义两个指针pre cur : pre在前 cur 在后 如果cur节点不为空，设置pre.next = cur 实现一次翻转 翻转后pre 、cur同步向前一步 当pre为空终止循环 func reverseList(_ head: ListNode?) -> ListNode? { if head == nil || head?.next == nil { return head } var pre = head, cur: ListNode? while pre != nil { let temp = pre?.next pre?.next = cur cur = pre! pre = temp } return cur } 递归法核心：reversList(head) = reverseList(head.next) func reverseList2(_ head: ListNode?) -> ListNode? { if head == nil || head?.next == nil { return nil } let newHead = reverseList2(head?.next) head?.next?.next = head head?.next = nil return newHead } 反转链表 II题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明:1 ≤ m ≤ n ≤ 链表长度 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL题解思路 第一步：找到待反转节点的前一个节点。第二步：反转m到n这部分。第三步：将反转的起点的next指向反转的后面一部分。第四步：将第一步找到的节点指向反转以后的头节点。 public ListNode reverseBetween(ListNode head, int m, int n) { ListNode res = new ListNode(0); res.next = head; ListNode node = res; //找到需要反转的那一段的上一个节点。 for (int i = 1; i &lt; m; i++) { node = node.next; } //node.next就是需要反转的这段的起点。 ListNode nextHead = node.next; ListNode next = null; ListNode pre = null; //反转m到n这一段 for (int i = m; i &lt;= n; i++) { next = nextHead.next; nextHead.next = pre; pre = nextHead; nextHead = next; } //将反转的起点的next指向next。 node.next.next = next; //需要反转的那一段的上一个节点的next节点指向反转后链表的头结点 node.next = pre; return res.next; }","categories":[],"tags":[]},{"title":"智力题","slug":"智力题","date":"2020-03-15T02:44:43.844Z","updated":"2020-03-15T03:31:45.729Z","comments":true,"path":"2020/03/15/智力题/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/15/%E6%99%BA%E5%8A%9B%E9%A2%98/","excerpt":"","text":"智力题1、有两个水桶， 一个装 3L 的水， 一个可装 5L 的水， 问:如何利用这两个桶， 量出 4L 的水来？解法一加法：操作两次3L的桶，得到1L的水，然后倒入5L的桶里面，此时5L桶里有1L的水，再次用3L的桶倒入5L桶，1L+ 3L = 4L,一共操作3次3L桶 加法解法图示： 解法二减法：5L满水的桶倒入3L的桶，剩余2L，5L桶剩余的2L再次倒入3L桶，此时3L桶还有1L集满，5L桶再次装满后倒出来1L给3L桶里面，5L - 1L = 4L,连续操作3次5L桶 减法解法图示： 2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？首先2的6次方64，2的7次方128 &gt; 100因此我们可以用7个的二进制给100个瓶子编号，7只老鼠分别对应7个二进制位，如果瓶子编号出现1，老鼠喝下瓶子中的毒药，最后统计出被毒死老鼠的二进制数，转换为10进制就是有毒瓶子的编号。 解法图示：","categories":[],"tags":[]},{"title":"Runloop","slug":"Runloop","date":"2020-03-11T13:16:28.012Z","updated":"2020-03-13T17:26:08.484Z","comments":true,"path":"2020/03/11/Runloop/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/11/Runloop/","excerpt":"","text":"Runloop1.讲讲 RunLoop，项目中有用到吗？ 事件循环，在程序运行中循环做一些事情 没有消息mach_msg()切换用户态到内核态线程休眠，有消息内核态切换到用户态 runloop相关： Timer、performSelector GCD、AutoreleasePool 事件响应、收拾识别、网络请求 runloop的应用： 线程包活 解决timer滑动停止问题 监听主线程卡顿 性能优化 2.runloop的6种状态和runloop内部实现逻辑？/* Run Loop Observer Activities */ typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出Loop kCFRunLoopAllActivities = 0x0FFFFFFFU }; source0 : 触摸事件、performSelectorOnThread: source1: 基于Port的线程间通讯，捕获到的系统事件 timers: NSTimer + performSelector:afterDelay: observers: 监听runloop的状态/autoreleasePool的创建和释放、UI的刷新 3.runloop和线程的关系？ 一一对应 保存在一个全局字典中，线程是key, runloop是value 子线程默认没有runloop，在第一次获取runloop时才会创建。 runloop在线程结束时销毁 4.timer 与 runloop 的关系？程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？5.runloop 是怎么响应用户操作的， 具体流程是什么样的？6.说说runLoop的几种状态7.runloop的mode作用是什么？ CFRunLoopModeRef代表RunLoop的运行模式 一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer RunLoop启动时只能选择其中一个Mode，作为currentMode 如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入 不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响 如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出 8.KVO实现原理?哪些情况下使用kvo会崩溃，怎么防护崩溃?9.如何手动关闭KVO?如何手动自己实现KVO说说思路10.通过KVC修改属性会触发KVO么","categories":[],"tags":[]},{"title":"多线程","slug":"多线程","date":"2020-03-11T12:34:15.299Z","updated":"2020-03-13T20:37:44.285Z","comments":true,"path":"2020/03/11/多线程/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"1、你理解的多线程？并发和串行，同步和异步 同步和异步的区别: 是否开辟新的线程，同步只能在当前线程执行任务，异步可以再新的线程执行任务 串行和并发的区别是任务执行的顺序，串行任务只能顺序执行，并发可以多个任务同时执行。 2、iOS多线程有哪些？常用哪个？ NSThread、GCD/NSOperationQueue 常用GCD/NSOperation GCD 的队列类型有哪些？OperationQueue 和 GCD 的区别？ GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择； 在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)； NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行； 我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样子能比GCD更加有效地掌控我们执行的后台任务； 在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码； 我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。 总的来说，Operation queue 提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。 从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。 如何用gcd实现以下功能？ 异步并发执行任务1、任务2 等任务1、任务2都执行完毕后，再回到主线程执行任务3 线程安全是什么？如何处理线程安全的问题？ 我们一般通过线程同步方案如加锁的方式来实现线程的安全 iOS锁的原理 | 深入浅出iOS系统内核-同步机制 os_unfair_lock：iOS10开始os_unfair_lock来替代OSSpinLock, 等待锁的线程会进入休眠不占用CPU资源， 这个os_unfair_lock解决了优先级翻转问题。 OSSpinLock: 自旋锁，线程忙等一直占用CUP资源，不安全因为可能出现优先级翻转的可能 dispatch_semaphore：信号量为1的semaphore也可以看做是锁 pthread_mutex：mutex是互斥锁，等待锁的线程处于休眠状态，pthread_mutex是递归锁，可以递归调用。 使用GCD的串行队列也可以实现锁的功能 NSLock是对metex互斥锁的封装，NSRecurisiveLock也是对metex的递归封装，API和NSLock一直。 NSCondition NSConditionLock @synchorized也是mutex的递归封装，@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作。 自旋锁和互斥锁如何选择？自旋锁OSSpinLock：当线程获取锁，其他等待锁的线程会忙等一直占用CPU,自旋锁有优先级翻转的可能性，所以苹果已经弃用自旋锁OSSpinLock改用os_unfair_lock. 互斥锁mutext：阻塞线程并休眠，其他线程才能正常访问，用互斥的方式来保证线程的安全。 递归锁：顾名思义，可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。 什么情况使用自旋锁比较划算？ 预计线程等待锁的时间很短 加锁的代码（临界区）经常被调用，但竞争情况很少发生 CPU资源不紧张 多核处理器 什么情况使用互斥锁比较划算？ 预计线程等待锁的时间较长 单核处理器 临界区有IO操作 临界区代码复杂或者循环量大 临界区竞争非常激烈 追问二：使用以上锁需要注意哪些？ 追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！ iOS线程同步方案性能比较性能从高到低排序: os_unfair_lock &gt; OSSpinLock &gt; dispatch_semaphore &gt; pthread_mutex &gt; dispatch_queue(DISPATCH_QUEUE_SERIAL) &gt; NSLock &gt; NSCondition &gt; pthread_mutex(recursive) &gt; NSRecursiveLock &gt; NSConditionLock &gt; @synchronized如何实现多度单写？dispatch_barrier_async 这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的 如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果 pthread_rwlock读写锁-等待锁的线程进入休眠 ‌","categories":[],"tags":[]},{"title":"红黑树前世今生","slug":"红黑树前世今生","date":"2019-12-30T07:28:54.939Z","updated":"2019-12-30T07:28:54.939Z","comments":true,"path":"2019/12/30/红黑树前世今生/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/30/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/","excerpt":"","text":"红黑树前世今生关键词：二叉搜索树、前驱节点、后继节点、B树、红黑树 什么是B树前世B树是一种相对于来说特殊二叉搜索树，多用于数据库和文件搜索系统中。 n阶B树的性质 B树是一种平衡的多路搜索树，拥有平衡二叉树的一些特性，与平衡二叉树的最大区别在于每个节点不再是只能存储一个元素，而且每个节点可以拥有多个子节点而像二叉平衡树只能拥有两个。 B树每个节点最多可以存储超过2个元素，可以拥有超过2个子节点 B树每个子节点的子树高度一致 B树和二叉搜索树一样，左子树&lt;根节点&lt;右子树 根节点元素个数: 1≤ X ≤ n - 1 非根节点元素个数: n/2 - 1 ≤ x ≤ n - 1 (n/2 向上取整) 如果有子节点，子节点个数 y = x + 1, 根节点 2 ≤ y ≤ n非根节点 n / 2 ≤ y ≤ n (n/2 向上取整) 数据库中一般使用的是200-300阶B树 4阶B树元素个数为(2-3-4)，所以4阶B树也叫2-4树或者2-3-4树 5阶B树元素个数为 3-4-5 所以5阶B树叫（3，5）树 6阶B树元素个数3-4-5-6，所以6阶B树叫（3，6）树 7阶B树元素个数为4-5-6-7，所以7阶B树叫（4，7）树 B树 VS 二叉搜索树 B树与二叉搜索树逻辑上等价 n阶B树最多需要log2 N代合并 多代节点合并可以获得超节点 2代合并最多拥有4个子节点 3代合并最多拥有8个子节点 n代合并最多拥有2^n个子节点（至少是2^n阶B树） B树的添加与上溢上溢出（overflow）:添加元素到子节点后，该节点元素个数大于N时，我们称之为上溢出 B树的元素添加的位置一定是叶子节点 B树添加导致上溢 B树上溢最极端的情况是一直分裂到根节点 B树的删除与下溢删除 删除叶子节点的话直接删除 删除的非叶子节点的话：1、先找到前驱或后继节点元素，覆盖需要删除的值，2、把前驱或后继元素删除（说明：一个树的前驱在左子树的最后边，后驱在右子树的最左边。） 非叶子节点前驱或后继元素，必然是在叶子节点中，所以真正删除的元素都是叶子节点 下溢出（underflow）：叶子节点被删除一个元素后，元素个数可能会低于最低限制 （n/2 - 1 向上取整） 下溢出的解决方案是旋转，总体元素是哪个方向失衡往哪个方向转，子树大小顺序不能乱 4阶B树 4阶B树所有节点都能储存的元素个数x: 1 ≤ x ≤ 3 4阶B树非叶子节点的子节点个数：2 ≤ y ≤ 4 为什么需要红黑树?红黑树是在二叉搜索树的基础上对AVL树的改进，二叉搜索树顾名思义是对搜索算法的一种优化，能够大大减少我们元素对比的次数。红黑树在Java中的应用如HashSet(底层是数组单链表和红黑树)、数据库搜索也有应用。 什么是红黑树？红黑树是一种自平衡的二叉搜索树也叫平衡二叉B树 红黑树5个性质 节点分为红色与黑色 根节点是黑色 叶子节点是黑色 不能有两个连续的红色节点 从任意节点到叶子节点上所有路径的黑色节点数目必须相等 红黑树等价变换红黑树等价于4阶B树 红黑树添加失衡如何解决？添加失衡 Parrent节点为黑色时不需要处理 Parrent节点为红色（Double Red） Uncle节点不是red: LL/RR LR/RL Uncle节点是red: 红黑树删除节点失衡如何解决？红黑树 VS AVL树搜索性能添加删除实际应用Java8中的hashMap是使用数组+链表实现的，在解决哈希碰撞时使用了红黑树。","categories":[],"tags":[]},{"title":"二叉树前世今生","slug":"二叉树前世今生","date":"2019-12-30T07:28:54.936Z","updated":"2019-12-30T07:28:54.937Z","comments":true,"path":"2019/12/30/二叉树前世今生/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/","excerpt":"","text":"二叉树今生为什么会有二叉树这种数据结构？ 思考一个问题：如果一个集合中有42亿个元素，让你从这42亿个元素中搜索某一个元素，你需要多少次操作？ 如果使用数组链表的话最多可能需要42亿次比较，而如果使用二叉树我们只需要32次比较即可，这就是二叉树存在的价值。Java中的HashSet使用的就是二叉树 前驱与后继前驱节点 若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode） 若一个节点没有左子树，那么判断该节点和其父节点的关系 2.1 若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。 2.2 若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点 后继节点 若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode） 若一个节点没有右子树，那么判断该节点和其父节点的关系2.1 若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点2.2 若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点 如何判断两个二叉树是否相同？ 递归法 static public bool IsSameTree(TreeNode root1, TreeNode root2) { if (root1 == null && root2 == null) { return true; } if ((root1 == null && root2 != null) || (root1 != null && root2 == null)) { return false; } if (root1.val != root2.val) {//判断每个节点的值是否相等，如果去除此判断，则判断两个二叉树是否结构相等 return false; } return IsSameTree(root1.left, root2.left) && IsSameTree(root1.right, root2.right); } 非递归法 bool BTreeCompare（BTreeNode_t *pRoot1, BTreeNode_t *pRoot2) { if( pRoot1 == NULL && pRoot2 == NULL ) return false; queue que1; queue que2; que1.push(pRoot1); que2.push(pRoot2); int curLevelNodeTotal1 = 0; int curLevelNodeTotal2 = 0; bool flag = true; //作为比较不一致时跳出标识 while( ( !que1.empty()) && ( !que2.empty())) //当两个队列均不为空时，才进行比较 { curLevelNodeTotal1 = que1.size(); //获取树1的当前层节点总数 curLevelNodeTotal2 = que2.size(); //获取树2的当前层节点总数 if( curLevelNodeTotal1 != curLevelNodeTotal2){ flag = false;//当前层节点总数都不一致，不需要比较了，直接跳出 break; } int cnt1 = 0;//遍历本层节点时的计数器 int cnt2 = 0; while( cnt1 < curLevelNodeTotal1 && cnt2 < curLevelNodeTotal2){ ++cnt1; ++cnt2; pRoot1 = que1.front(); que1.pop(); pRoot2 = que2.front(); que2.pop(); //比较当前节点中数据是否一致 if( pRoot1->m_pElemt != pRoot2->m_pElemt ){ flag = false; break; } //判断pRoot1和pRoot2左右节点结构是否相同 if( ( pRoot1->m_pLeft != NULL && pRoot2->m_pLeft == NULL ) || ( pRoot1->m_pLeft == NULL && pRoot2->m_pLeft != NULL ) || ( pRoot1->m_pRight != NULL && pRoot2->m_pRight == NULL ) || ( pRoot1->m_pRight == NULL && pRoot2->m_pRight != NULL ) ){ flag = false; break; } //将左右节点入队 if( pRoot1->m_pLeft != NULL ) que1.push( pRoot1->m_pLeft); if( pRoot1->m_pRight != NULL ) que1.push( pRoot1->m_pRight); if( pRoot2->m_pLeft != NULL ) que2.push( pRoot2->m_pLeft); if( pRoot2->m_pRight != NULL ) que2.push( pRoot2->m_pRight); } if( flag == false ) break; } //如果比较标志为false，则不相同 if( flag == false ){ while( !que1.empty() ) que1.pop(); while( !que2.empty()) que2.pop(); return false; } return true; }","categories":[],"tags":[]},{"title":"iOS图像处理","slug":"iOS图像处理","date":"2019-12-30T07:28:54.924Z","updated":"2019-12-30T07:28:54.924Z","comments":true,"path":"2019/12/30/iOS图像处理/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/30/iOS%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"iOS图像优化技巧图像渲染优化的时机和理由在开始之前，让我们先讨论一下为什么需要对图像进行渲染优化。毕竟，UIImageView 会自动根据 contentmode 属性 规定的行为缩放和裁剪图像。在绝大多数情况下，.scaleAspectFit、.scaleAspectFill 或 .scaleToFill 已经完全满足你的所需。 imageView.contentMode = .scaleAspectFit imageView.image = image 那么，什么时候对图像进行渲染优化才有意义呢？ 当它明显大于 UIImageView 显示尺寸的时候 想要完整渲染这张宽高为 12,000 px 的图片，需要高达 20 MB 的空间。对于当今的硬件来说，你可能不会在意这么少兆字节的占用。但那只是它压缩后的尺寸。要展示它，UIImageView 首先需要把 JPEG 数据解码成位图（bitmap），如果要在一个 UIImageView 上按原样设置这张全尺寸图片，你的应用内存占用将会激增到几百兆，对用户明显没有什么好处（毕竟，屏幕能显示的像素有限）。但只要在设置 UIImageView 的 image 属性之前，将图像渲染的尺寸调整成 UIImageView 的大小，你用到的内存就会少一个数量级： 内存消耗 (MB) 无下采样 220.2 下采样 23.7 这个技巧就是众所周知的下采样（downsampling），在这些情况下，它可以有效地优化你应用的性能表现。如果你想了解更多关于下采样的知识或者其它图形图像的最佳实践，请参照 来自 WWDC 2018 的精彩课程。 而现在，很少有应用程序会尝试一次性加载这么大的图像了，但是也跟我从设计师那里拿到的图片资源不会差太多。（认真的吗？一张颜色渐变的 PNG 图片要 3 MB?） 考虑到这一点，让我们来看看有什么不同的方法，可以让你用来对图像进行优化或者下采样。 不用说，这里所有从 URL 加载的示例图像都是针对本地文件。记住，在应用的主线程同步使用网络请求图像绝不是什么好主意。 图像渲染优化技巧优化图像渲染的方法有很多种，每种都有不同的功能和性能特性。我们在本文看到的这些例子，架构层次跨度上从底层的 Core Graphics、vImage、Image I/O 到上层的 Core Image 和 UIKit 都有。 绘制到 UIGraphicsImageRenderer 上 绘制到 Core Graphics Context 上 使用 Image I/O 创建缩略图像 使用 Core Image 进行 Lanczos 重采样 使用 vImage 优化图片渲染 下面的这些数字是多次迭代加载、优化、渲染之前那张 超大地球图片 的平均时间： 耗时 (seconds) 技巧 #1: UIKit 0.1420 技巧 #2: Core Graphics 1 0.1722 技巧 #3: Image I/O 0.1616 技巧 #4: Core Image 2 2.4983 技巧 #5: vImage 2.3126 1设置不同的 CGInterpolationQuality 值出来的结果是一致的，在性能上的差异可以忽略不计。 2若在 CIContext 创建时设置 kCIContextUseSoftwareRenderer 的值为 true，会导致耗时相比基础结果慢一个数量级。 技巧 #1: 绘制到 UIGraphicsImageRenderer 上图像渲染优化的最上层 API 位于 UIKit 框架中。给定一个 UIImage，你可以绘制到 UIGraphicsImageRenderer 的上下文（context）中以渲染缩小版本的图像： import UIKit // 技巧 #1 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { guard let image = UIImage(contentsOfFile: url.path) else { return nil } let renderer = UIGraphicsImageRenderer(size: size) return renderer.image { (context) in image.draw(in: CGRect(origin: .zero, size: size)) } }UIGraphicsImageRenderer 是一项相对较新的技术，在 iOS 10 中被引入，用以取代旧版本的 UIGraphicsBeginImageContextWithOptions / UIGraphicsEndImageContext API。你通过指定以 point 计量的 size 创建了一个 UIGraphicsImageRenderer。image 方法带有一个闭包参数，返回的是一个经过闭包处理后的位图。最终，原始图像便会在缩小到指定的范围内绘制。 技巧 #2：绘制到 Core Graphics Context 中Core Graphics / Quartz 2D 提供了一系列底层 API 让我们可以进行更多高级的配置。 给定一个 CGImage 作为暂时的位图上下文，使用 draw(_:in:) 方法来绘制缩放后的图像： import UIKit import CoreGraphics // 技巧 #2 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil), let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil) else { return nil } let context = CGContext(data: nil, width: Int(size.width), height: Int(size.height), bitsPerComponent: image.bitsPerComponent, bytesPerRow: image.bytesPerRow, space: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!, bitmapInfo: image.bitmapInfo.rawValue) context?.interpolationQuality = .high context?.draw(image, in: CGRect(origin: .zero, size: size)) guard let scaledImage = context?.makeImage() else { return nil } return UIImage(cgImage: scaledImage) }这个 CGContext 初始化方法接收了几个参数来构造一个上下文，包括了必要的宽高参数，还有在给出的色域范围内每个颜色通道所需要的内存大小。在这个例子中，这些参数都是通过 CGImage 这个对象获取的。下一步，设置 interpolationQuality 属性为 .high 指示上下文在保证一定的精度上填充像素。draw(_:in:) 方法则是在给定的宽高和位置绘制图像，可以让图片在特定的边距下裁剪，也可以适用于一些像是人脸识别之类的图像特性。最后 makeImage() 从上下文获取信息并且渲染到一个 CGImage 值上（之后会用来构造 UIImage 对象）。 技巧 #3：使用 Image I/O 创建缩略图像Image I/O 是一个强大（却鲜有人知）的图像处理框架。抛开 Core Graphics 不说，它可以读写许多不同图像格式，访问图像的元数据，还有执行常规的图像处理操作。这个框架通过先进的缓存机制，提供了平台上最快的图片编码器和解码器，甚至可以增量加载图片。 这个重要的 CGImageSourceCreateThumbnailAtIndex 提供了一个带有许多不同配置选项的 API，比起在 Core Graphics 中等价的处理操作要简洁得多： import ImageIO // 技巧 #3 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { let options: [CFString: Any] = [ kCGImageSourceCreateThumbnailFromImageIfAbsent: true, kCGImageSourceCreateThumbnailWithTransform: true, kCGImageSourceShouldCacheImmediately: true, kCGImageSourceThumbnailMaxPixelSize: max(size.width, size.height) ] guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil), let image = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, options as CFDictionary) else { return nil } return UIImage(cgImage: image) }给定一个 CGImageSource 和一系列配置选项，CGImageSourceCreateThumbnailAtIndex(_:_:_:) 函数创建了一个图像的缩略图。优化尺寸大小的操作是通过 kCGImageSourceThumbnailMaxPixelSize 完成的，它根据图像原始宽高比指定的最大尺寸来缩放图像。通过设定 kCGImageSourceCreateThumbnailFromImageIfAbsent 或 kCGImageSourceCreateThumbnailFromImageAlways 选项，Image I/O 可以自动缓存优化后的结果以便后续调用。 总结 UIKit, Core Graphics, 和 Image I/O 都能很好地用于大部分图片的优化操作。 如果（在 iOS 平台，至少）要选择一个的话，UIGraphicsImageRenderer 是你最佳的选择。 Core Image 在图像优化渲染操作方面性能表现优越。实际上，根据 Apple 官方 Core Image 编程规范中的性能最佳实践单元，你应该使用 Core Graphics 或 Image I/O 对图像进行裁剪和下采样，而不是用 Core Image。 除非你已经在使用 vImage，否则在大多数情况下用到底层的 Accelerate API 所需的额外工作可能是不合理的。 本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 http://swift.gg。","categories":[],"tags":[]},{"title":"Swift备忘录","slug":"Swift备忘录","date":"2019-12-07T04:48:29.505Z","updated":"2020-03-13T20:18:13.194Z","comments":true,"path":"2019/12/07/Swift备忘录/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/07/Swift%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"SwiftTip","text":"SwiftTip ##1、@autoclosure作用：将表达式自动封装成一个闭包 ()-&gt;Void 1.2 ??的底层实现是用的enum 1.3 “闭包和循环引用” weak解决循环引用的正确写法： var name: ()->() = { [weak self] in if let strongSelf = self { print(\"The name is (strongSelf.name)\") } } 2、值类型和引用类型的选择 数组和字典设计为值类型最大的考虑是为了线程安全. 另一个优点，那就是非常高效，因为 “一旦赋值就不太会变化” 这种使用情景在 Cocoa 框架中是占有绝大多数的，这有效减少了内存的分配和回收。 但是在少数情况下，我们显然也可能会在数组或者字典中存储非常多的东西，并且还要对其中的内容进行添加或者删除。” 在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好， 对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary 3、@escaping的作用？ class func animate(withDuration duration: TimeInterval, animations: @escaping () -&amp;gt; Void, completion: ((Bool) -> Void)? = nil) 4、defer的使用注意点defer的作用域以前很单纯地认为 defer 是在函数退出的时候调用，并没有注意其实是当前 scope 退出的时候调用这个事实，造成了这个错误。在 if，guard，for，try 这些语句中使用 defer 时，应该要特别注意这一点。 5、@discardableResult6、ResultResult&lt;T, E: Error&gt; 和 Result 7、Lazy的使用 let data = 1...3 let result = data.lazy.map { (i: Int) -> Int in print(\"准备处理(i)\") return i * 2 } print(\"准备访问结果\") for i in result { print(\"处理后的结果:(i)\") } print(\"done\") 打印结果： 准备访问结果 准备处理1 处理后的结果:2 准备处理2 处理后的结果:4 准备处理3 处理后的结果:6 done 8、Swift反射机制Mirror “通过 Mirror 初始化得到的结果中包含的元素的描述都被集合在 children 属性下，如果你有心可以到 Swift 标准库中查找它的定义，它实际上是一个 Child 的集合，而 Child 则是一对键值的多元组： 示例1 struct Car { let logo: String var wheel: Int let door: Int } let baoM = Car(logo: \"BMW\", wheel: 4, door: 2) let mirror = Mirror(reflecting: baoM) print(\"类型:(String(describing: mirror.displayStyle))\") ///1、通过Mirror的children获取属性信息 print(\"属性个数:(mirror.children.count)\") mirror.children.map { (child) -> Any in print(\"label: (String(describing: child.label)), value: (child.value)\") } ///2、通过Refletion的dump(Any)方法获取属性信息 dump(baoM) 示例2 获取property let homeProperty = Mirror(reflecting: self) homeProperty.children.map { LOG.D(\"home property:($0)\") } 9、iOS初始化核心原则 iOS 的初始化最核心两条的规则： • 必须至少有一个指定初始化器，在指定初始化器里保证所有非可选类型属性都得到正确的初始化（有值） • 便利初始化器必须调用其他初始化器，使得最后肯定会调用指定初始化器 在Swift中千万不要用String的count方法计算文本长度。否则当文本中有emoji时，会计算出错。应当转成NSString再去求length。 10、Swift备忘录001 Array for-in使用 1.for in获取索引 index let array = [\"Apple\", \"Google\", \"Amazon\"] for item in array { print(\"company name is :(item)\") } ///配合array.enumerated()使用 for (index, item) in array.enumerated() { print(\"index:(index), item:(item)\") } 2.array.firstIndex(of:)获取index ///配合array.firstIndex(of:)使用 let googleIndex = array.firstIndex(of: \"Google\") print(\"googleIndex is : (googleIndex ?? 0)\") ///配合array.firstIndex(where:)使用 if let index = array.firstIndex(where: { $0.hasPrefix(\"A\") }) { print(\"array.firstIndex is (index)\") } if let item = array.first(where: { $0.hasPrefix(\"A\")}{ print(\"array.first is :(item)\") } Swift备忘录002 Array.forEach()2.1forEach()和函数式编程结合使用 let array = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"] ///使用forEach array.map { Int($0)! }.forEach { num in print(num) } //不使用forEach let map = array.map { Int($0)! } map.forEach { print($0) } 2.2forEach()遍历optional集合会自动过滤nil let optionalString: [String]? = nil //使用forEach强制解包option，会过滤 optionalString?.forEach { str in print(\"str is (str)\") } ///使用for-in强制解包optional，会crash for str in optionalString! { print(\"str is (str)\") } Swift备忘录003 Array index3.1","categories":[],"tags":[]},{"title":"Swift函数式编程","slug":"Swift函数式编程","date":"2019-12-06T01:36:47.815Z","updated":"2020-03-13T20:17:46.842Z","comments":true,"path":"2019/12/06/Swift函数式编程/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/06/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"Functional Programming in Swift函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。","text":"Functional Programming in Swift函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。 不变性和副作用无论您首先学习哪种编程语言，您可能要学习的最初概念之一就是变量代表数据或状态。如果您退一步考虑一下这个想法，变量似乎很奇怪。 术语“变量”表示随程序运行而变化的数量。从数学角度考虑数量问题，您已将时间作为软件行为的关键参数。通过更改变量，可以创建可变状态。 为了进行演示，请将以下代码添加到playground： var thing = 3 //some stuff thing = 4 func superHero() { print(\"I'm batman\") thing = 5 } print(\"original state = \\(thing)\") superHero() print(\"mutated state = \\(thing)\") 神圣的神秘变化！为什么现在是5？这种变化称为副作用。函数superHero（）更改了一个甚至没有定义自己的变量。 单独或在简单系统中，可变状态不一定是问题。将许多对象连接在一起时（例如在大型的面向对象的系统中）会出现问题。可变状态会使人难以理解变量具有什么值以及该值随时间的变化而产生头痛。 例如，在为多线程系统编写代码时，如果两个或多个线程同时访问同一变量，则它们可能会无序地修改或访问它。这会导致意外的行为。这种意外行为包括竞态条件，死锁和许多其他问题。 试想一下，如果您可以编写状态永远不变的代码。并发系统中发生的所有问题都将消失。像这样工作的系统具有不变的状态，这意味着不允许状态在程序过程中进行更改。 使用不可变数据的主要好处是，使用不可变数据的代码单元没有副作用。代码中的函数不会更改其自身之外的元素，并且在发生函数调用时不会出现怪异的效果。您的程序可以正常运行，因为没有副作用，您可以轻松重现其预期的效果。 本教程从较高的层次介绍了FP，因此在实际情况下考虑这些概念会很有帮助。在这种情况下，假设您正在为游乐园构建应用程序，并且该游乐园的后端服务器通过REST API提供了行程数据。 创建Modelenum RideCategory: String { case family case kids case thrill case scary case relaxing case water } typealias Minutes = Double struct Ride { let name: String let categories: Set&lt;RideCategory> let waitTime: Minutes } Create some data using that modellet parkRides = [ Ride(name: \"R45\", categories: [.family, .thrill, .water], waitTime: 45.0), Ride(name: \"R10\", categories: [.family], waitTime: 10.0), Ride(name: \"R15\", categories: [.kids], waitTime: 15.0), Ride(name: \"R30\", categories: [.scary], waitTime: 30.0), Ride(name: \"R60\", categories: [.family, .thrill], waitTime: 60.0), Ride(name: \"R15-2\", categories: [.family, .kids], waitTime: 15.0), Ride(name: \"R25\", categories: [.family, .water], waitTime: 25.0), Ride(name: \"R0\", categories: [.family, .relaxing], waitTime: 0.0) ] FP: Filter Map ReduceMost languages that support FP will have the functions filter, map &amp; reduce. Map Map是将输入Collection中的每个Element转换为新Element。 使用map遍历一个集合，并对集合中的每个元素应用相同的操作。 map函数返回一个数组，其中包含对每个元素的映射或转换函数的结果。 Map on array:let arrayOfInt = [1,2,3,4,5] 如果我们要对每个元素乘上10呢？我们以前可能要这样 var newArr: [Int] = [] for value in arrayOfInt { newArr.append(value * 10) } print(newArr) 现在有map()后我们可以这样： let mapArr = arrayOfInt.map { $0 * 10 } print(mapArr) Working of map: The map function has a single argument which is a closure (a function) that it calls as it loops over the collection. This closure takes the element from the collection as an argument and returns a result. The map function returns these results in an array. Map on Dictionarylet book = [\"A\": 100, \"B\": 80, \"C\": 90] let mapedBook = book.map { (key, value) in key.capitalized } print(mapedBook) //[\"C\", \"B\", \"A\"] Map on Setlet lengthInmeter: Set = [1,3,5] let km = lengthInmeter.map { meter in meter * 1000 } print(km) // [1000, 5000, 3000] Map同时获取array.Index??let nums = [1,2,3,4,5] let newNums = nums.enumerated().map { (index, num) in return num * 10 } print(\"newNums:\\(newNums)\") FilterFilter函数的作用是过滤集合，返回符合条件的集合。 Filter on Arraylet filterArray = [2,4,6,1,5,7] let newFilterArray = filterArray.filter { num -> Bool in num % 2 == 0 } print(newFilterArray) Filter on Dictionarylet book = [\"A\": 100, \"B\": 80, \"C\": 90] let bookFilter = book.filter { (key, value) in value > 80 } print(bookFilter) 简化 let book = [\"A\": 100, \"B\": 80, \"C\": 90] let bookFilter = book.filter { $1 > 80 } $0是key $1是value Filter on Setlet setNums = [4.9,5.5,8.6] let newSet = setNums.filter { $0 > 5.0 } print(newSet) 重要：返回类型是数组 Reduce Use reduce to combine all items in a collection to create a single new value. 使用reduce可以合并集合中的所有元素来创建一个新的value Apple文档声明reduce() func reduce&lt;Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -> Result) rethrows -> Result reduce函数有两个参数： 第一个参数 initial value用来存储初始值或者结果（每次迭代器的结果） 第二个是带有两个参数的闭包，Result是初始值或迭代器的结果，Element是集合中的下一个元素。 Reduce on Arraylet numbers = [1,2,3,4,5,6] let sum = numbers.reduce(0) { x, y in x + y } print(sum) 简化版本：使用$0代表result let reducedSum = numbers.reduce(0) { $0 + $1 } print(reducedSum) ///等价 let reducedSum = numbers.reduce(0, +) print(reducedSum) 乘法 let produceNum = numbers.reduce(1) { x, y in x * y } print(produceNum) ///等价 let produceNum = numbers.reduce(1, *) print(produceNum) Reduce + 连接字符串let charactors = [\"abc\",\"def\",\"hijk\"] let newCharactor = charactors.reduce(\"\", +) print(newCharactor) // abcdefhijk Reduce on Dictionary let dict = [\"A\": 20, \"B\": 100] // Reduce on value let reducedNum = dict.reduce(5) { result, dic in return result + dic.value } print(\"reduc on value is \\(reducedNum)\") // reduc on value is 125 // Reduce on key let reducedName = dict.reduce(\"Charactor are \") { (result, dic) in return result + dic.key + \" \" } print(\"reduce on key is &lt;\\(reducedName)>\") //reduce on key is &lt;Charactor are A B > 简化 let reducedNameOnDic = dict.reduce(\"Charater are \") { $0 + $1.key + \" \"} Reduce on Set// Reduce on Set let lengthMeters = [3.4,1.6] let reducedMeters = lengthMeters.reduce(0.0) { $0 + $1 } print(\"reduced meters :\\(reducedMeters)\") // 5.0 FlatMapFlatmap is used to flatten a collection of collections . But before flattening the collection, we can apply map to each elements. Apple docs says: Returns an array containing the concatenated results of calling the given transformation with each element of this sequence. Flatmap用于展平集合的集合。 但是在展平集合之前，我们可以将map应用于每个集合元素。 let charaters = [\"abc\",\"def\",\"ghi\"] let newCharaters = charaters.flatMap { $0 } print(newCharaters) //[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"] let codes = [[\"abc\",\"def\",\"ghi\"], [\"jkl\",\"mno\",\"pqr\"],[\"stu\",\"vwx\",\"yz\"] ] let newCodes = codes.flatMap {$0.map { $0 } } print(newCodes) // [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\"] nillet nilArray = [2,3,nil] print(nilArray.flatMap { $0 }) // [2,3] // warning: 'flatMap' is deprecated: Please use compactMap(_:) for the case where closure returns an optional value print(nilArray.compactMap { $0 }) // [2,3]","categories":[],"tags":[]}]}