{"meta":{"title":"明日危机","subtitle":"iOS & Swifter","description":"","author":"KM","url":"https://mingriweiji-github.github.io","root":"/"},"pages":[],"posts":[{"title":"Dyld源码阅读","slug":"Dyld源码阅读","date":"2020-04-01T03:31:34.664Z","updated":"2020-04-01T16:39:26.540Z","comments":true,"path":"2020/04/01/Dyld源码阅读/","link":"","permalink":"https://mingriweiji-github.github.io/2020/04/01/Dyld%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"Dyld源码阅读 Version：dyld-551.4 Lauange：C++ load()：3566行 load()-&gt;loadPhase0()-&gt;loadPhase1()-&gt;loadPhase2()-&gt;loadPhase4()-&gt;loadPhase5()打开或检查已经存在的动态库：dyld3::findInSharedCacheImage load()-&gt;loadPhase2cache()-&gt;loadPhase4()-&gt;loadPhase5()-&gt;loadPhase6() 1、动态库路径iOS越狱手机 在Mac\\iOS中，是使用了/usr/lib/dyld程序来加载动态库 UIKit路径：/system/Library/Frameworks/UIKit.framework 动态库共享缓存：/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64 0x00 load()ImageLoader* load(const char* path, const LoadContext&amp; context, unsigned&amp; cacheIndex) { // try all path permutations and check against existing loaded images ImageLoader* image = loadPhase0(path, orgPath, context, cacheIndex, NULL); if ( image != NULL ) { CRSetCrashLogMessage2(NULL); return image; } // try all path permutations and try open() until first success image = loadPhase0(path, orgPath, context, cacheIndex, &amp;exceptions); if ( image == NULL) image = loadPhase2cache(path, orgPath, context, cacheIndex, &amp;exceptions); #endif CRSetCrashLogMessage2(NULL); } 0x01 loadPhase2()0x02 loadPhase5loadPhase5load（）loadPhase5check（）// open or check existing static ImageLoader* loadPhase5(const char* path, const char* orgPath, const LoadContext&amp; context, unsigned&amp; cacheIndex, std::vector&lt;const char*>* exceptions) { // check for specific dylib overrides for (std::vector&lt;DylibOverride>::iterator it = sDylibOverrides.begin(); it != sDylibOverrides.end(); ++it) { if ( strcmp(it->installName, path) == 0 ) { path = it->override; break; } } if ( exceptions != NULL ) return loadPhase5load(path, orgPath, context, cacheIndex, exceptions); else return loadPhase5check(path, orgPath, context); } 0x03 findInSharedCacheImagestatic bool findInSharedCacheImage(const char* path, bool searchByPath, const struct stat* stat_buf, const macho_header** mh, const char** pathInCache, long* slide) { dyld3::SharedCacheFindDylibResults results; if ( dyld3::findInSharedCacheImage(sSharedCacheLoadInfo, path, &amp;results) ) { *mh = (macho_header*)results.mhInCache; *pathInCache = results.pathInCache; *slide = results.slideInCache; return true; } return false; } bool inSharedCache(const char* path) { return dyld3::pathIsInSharedCacheImage(sSharedCacheLoadInfo, path); } static int imageSorter(const void* l, const void* r) { const ImageLoader* left = *((ImageLoader**)l); const ImageLoader* right= *((ImageLoader**)r); return left->compare(right); } findInSharedCacheImage inSharedCache 0x04 Clang++编译dsc_extractor.cpp生成可执行文件dsc_extractor :$: clang++ -o dsc_extractor dsc_extractor.cpp 抽取动态共享缓存中的Mach-O$: cd xxx/com.apple.dyld $: ./dsc_extractor dyld_shared_cache_arm64 arm64_file dsc_extractor.cpp内容如下: // test program #include &lt;stdio.h> #include &lt;stddef.h> #include &lt;dlfcn.h> typedef int (*extractor_proc)(const char* shared_cache_file_path, const char* extraction_root_path, void (^progress)(unsigned current, unsigned total)); int main(int argc, const char* argv[]) { if ( argc != 3 ) { fprintf(stderr, \"usage: dsc_extractor &lt;path-to-cache-file> &lt;path-to-device-dir>\\n\"); return 1; } //void* handle = dlopen(\"/Volumes/my/src/dyld/build/Debug/dsc_extractor.bundle\", RTLD_LAZY); void* handle = dlopen(\"/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/lib/dsc_extractor.bundle\", RTLD_LAZY); if ( handle == NULL ) { fprintf(stderr, \"dsc_extractor.bundle could not be loaded\\n\"); return 1; } extractor_proc proc = (extractor_proc)dlsym(handle, \"dyld_shared_cache_extract_dylibs_progress\"); if ( proc == NULL ) { fprintf(stderr, \"dsc_extractor.bundle did not have dyld_shared_cache_extract_dylibs_progress symbol\\n\"); return 1; } int result = (*proc)(argv[1], argv[2], ^(unsigned c, unsigned total) { printf(\"%d/%d\\n\", c, total); } ); fprintf(stderr, \"dyld_shared_cache_extract_dylibs_progress() => %d\\n\", result); return 0; } 0x05反汇编 Hopper Disassembler [Xclient下载Hopper Disassembler](https://xclie nt.info/s/hopper-disassembler.html#versions) 反汇编分析Mach-O文件2、Mach-O文件 Mac 内核源码xnu 来源：C/OC/Swift -&gt; .O目标文件-&gt;Mach-O可执行文件 EXTERNAL_HEADERS-&gt;mach-o查看源码 2.1 常见Mach-OMH_OBJECT 目标文件(.o) 静态库文件(.a)-静态库其实就是多个.o的集合 MH_EXECUTE:可执行文件 .app/xxx MH_DYLib:动态库文件 .dylib .framework/xxx MH_DYLIKER动态链接编辑器 /usr/lib/dyld MH_DSYM:存储着二进制文件符号信息 .dSYM/Contents/Resources/DWARF/XXX 2.2 11中mach-o格式 #define MH_OBJECT 0x1 /* relocatable object file */ #define MH_EXECUTE 0x2 /* demand paged executable file */ #define MH_FVMLIB 0x3 /* fixed VM shared library file */ #define MH_CORE 0x4 /* core file */ #define MH_PRELOAD 0x5 /* preloaded executable file */ #define MH_DYLIB 0x6 /* dynamically bound shared library */ #define MH_DYLINKER 0x7 /* dynamic link editor */ #define MH_BUNDLE 0x8 /* dynamically bound bundle file */ #define MH_DYLIB_STUB 0x9 /* shared library stub for static */ /* linking only, no section contents */ #define MH_DSYM 0xa /* companion file with only debug */ /* sections */ #define MH_KEXT_BUNDLE 0xb /* x86_64 kexts */ /* * The layout of the file depends on the filetype. For all but the MH_OBJECT * file type the segments are padded out and aligned on a segment alignment * boundary for efficient demand pageing. The MH_EXECUTE, MH_FVMLIB, MH_DYLIB, * MH_DYLINKER and MH_BUNDLE file types also have the headers included as part * of their first segment. * * The file type MH_OBJECT is a compact format intended as output of the * assembler and input (and possibly output) of the link editor (the .o * format). All sections are in one unnamed segment with no segment padding. * This format is used as an executable format when the file is so small the * segment padding greatly increases its size. * * The file type MH_PRELOAD is an executable format intended for things that * are not executed under the kernel (proms, stand alones, kernels, etc). The * format can be executed under the kernel but may demand paged it and not * preload it before execution. * * A core file is in MH_CORE format and can be any in an arbritray legal * Mach-O file. * * Constants for the filetype field of the mach_header */ Architectures.hpp// // Architectures // struct x86 { typedef Pointer32&lt;LittleEndian> P; }; struct x86_64 { typedef Pointer64&lt;LittleEndian> P; }; struct arm { typedef Pointer32&lt;LittleEndian> P; }; struct arm64 { typedef Pointer64&lt;LittleEndian> P; }; dyld_cache_format.h#define IPHONE_DYLD_SHARED_CACHE_DIR \"/System/Library/Caches/com.apple.dyld/\" #define DYLD_SHARED_CACHE_BASE_NAME \"dyld_shared_cache_\" FileAbstraction.hpptemplate &lt;typename _E> class Pointer32 { public: typedef uint32_t uint_t; typedef _E E; static uint64_t getP(const uint_t&amp; from) INLINE { return _E::get32(from); } static void setP(uint_t&amp; into, uint64_t value) INLINE { _E::set32(into, (uint32_t)value); } // Round to a P-size boundary template &lt;typename T> static T round_up(T value) { return (value+3) &amp; ~(T)3; } template &lt;typename T> static T round_down(T value) { return value &amp; ~(T)3; } }; template &lt;typename _E> class Pointer64 { public: typedef uint64_t uint_t; typedef _E E; static uint64_t getP(const uint_t&amp; from) INLINE { return _E::get64(from); } static void setP(uint_t&amp; into, uint64_t value) INLINE { _E::set64(into, value); } // Round to a P-size boundary template &lt;typename T> static T round_up(T value) { return (value+7) &amp; ~(T)7; } template &lt;typename T> static T round_down(T value) { return value &amp; ~(T)7; } }; 3、符号地址符号地址= 基地址 - 偏移地址 获取基地址//获取基地址 uintptr_t get_load_address(void) { const struct mach_header *exe_header = NULL; for (uint32_t i = 0; i &lt; _dyld_image_count(); i++) { const struct mach_header *header = _dyld_get_image_header(i); if (header->filetype == MH_EXECUTE) { exe_header = header; break; } } //返回值即为加载地址 return (uintptr_t)exe_header; } 获取偏移地址uintptr_t get_slide_address(void) { uintptr_t vmaddr_slide = NULL; for (uint32_t i = 0; i &lt; _dyld_image_count(); i++) { const struct mach_header *header = _dyld_get_image_header(i); if (header->filetype == MH_EXECUTE) { vmaddr_slide = _dyld_get_image_vmaddr_slide(i); break; } } return (uintptr_t)vmaddr_slide; } dSYM文件 编译时添加选项：DWARF with dSYM File，在编译打包完成之后就会生成调试符号文件（Mach-O文件） 文件查找：找到.xcarchive文件→show package contents→…一直到DWARF→工程二进制文件 atos命令有了dSYM文件，就可以使用atos命令查找到具体代码行出现奔溃信息的地方 atos [-o executable] [-l loadAddress] [-arch architecture] [address ...] #-arch 选择框架arm64/arm32/x86_64 4、Crash收集KSCrashSentryCocoa SentryCrashDynamicLinker","categories":[],"tags":[]},{"title":"一颗太阳","slug":"一颗太阳","date":"2020-03-18T06:44:02.192Z","updated":"2020-03-18T06:44:02.192Z","comments":true,"path":"2020/03/18/一颗太阳/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/18/%E4%B8%80%E9%A2%97%E5%A4%AA%E9%98%B3/","excerpt":"","text":"激情岁月 一颗太阳一千颗太阳1967年6月17日","categories":[],"tags":[]},{"title":"排序问题","slug":"排序问题","date":"2020-03-15T04:37:17.863Z","updated":"2020-03-17T01:55:57.693Z","comments":true,"path":"2020/03/15/排序问题/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/15/%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"带着问题去学习，是最有效的学习方法。所以按照惯例，我还是先给你出一个思考题： 问题一：为什么插入排序比冒泡排序更受欢迎？如何分析一个“排序算法”？ 最好情况、最坏情况、平均情况时间复杂度 时间复杂度的系数、常数、低阶 比较次数和交换次数 内存消耗 原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。(冒泡排序、插入排序) 稳定性 经过某种排序算法排序之后，如果两个相同数值的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法； 如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。 1、冒泡排序 冒泡排序只会操作相邻元素的两个数据 每次都是对相邻的两个元素比较大小，前面的元素大于后面的元素，交换前后元素，一轮循环后最后元素就是最大元素 第二轮循环后，倒数第二个元素就是第二大元素 直到所有元素都是有序的停止排序 冒泡排序图示： /// 冒泡排序 func bubbleSort&lt;T>(_ array: [T]) -> [T] where T: Comparable{ var array = array guard array.count > 1 else { return array } for i in 0..&lt;array.count { //提前退出标志 var flag: Bool = false for j in 0..&lt;array.count - i - 1 { if array[j] > array[j + 1] { array.swapAt(j + 1, j) //有数据交换 flag = true } } //没有数据交换-提前退出 if flag == false { break } } return array } 现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。 第一，冒泡排序是原地排序算法吗？冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。 第二，冒泡排序是稳定的排序算法吗？在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。 第三，冒泡排序的时间复杂度是多少？最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。平均时间复杂度也是O(n2) 2、插入排序 插入排序是将数组分成两个部分，已排序和未排序 初始化已排序部分只有一个元素就是数组第一个元素 插入排序的核心思想就是取出未排序部分的元素，在已排序区间中找到合适的插入位置插入，保证已排序区间的数据一直是有序的。 插入排序如下图： ///插入排序 func insertSort&lt;T>(_ elements: [T]) -> [T] where T: Comparable { var array = elements guard array.count > 1 else { return array } for i in 1..&lt;array.count { let value = array[i] var j = i - 1 //查找要插入的位置 for p in (0...j).reversed() { if array[p] > value { array[p+1] = array[p]//移动数据 } else { break } } array[j+1] = value// 插入数据 } return array } 插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。 对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度 = 满有序度-初始有序度。 现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。 第一，插入排序是原地排序算法吗？插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。 第二，插入排序是稳定的排序算法吗？在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。 第三，插入排序的时间复杂度是多少？ 如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。 如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。 还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n2)。 3、选择排序（Selection Sort）选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。 第一，选择排序是原地排序算法吗？选择排序的时间复杂度是O(1)所以是原地排序 第二，选择排序是稳定的排序算法吗？不是稳定排序，对于选择排序来说每次都是从未排序序列中找到最小的插入到已排序序列的末尾处，和前面的元素交换，这样会破坏稳定性 比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。\\ 第三，选择排序的时间复杂度是多少？选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。 总结三种时间复杂度是 O(n2) 的排序算法 这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高，所以我们更倾向于用下一节要讲的时间复杂度为 O(nlogn) 的排序算法。 问题二：如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素?1、归并排序 归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。 归并排序的核心是合并：依次合并N个堆得数据 1、在合并时，您需要两个索引来跟踪两个数组的进度。 2、这是合并后的数组。 它现在是空的，但是你将在下面的步骤中通过添加其他数组中的元素构建它。 3、这个while循环将比较左侧和右侧的元素，并将它们添加到orderedPile，同时确保结果保持有序。 4、如果前一个while循环完成，则意味着leftPile或rightPile中的一个的内容已经完全合并到orderedPile中。此时，您不再需要进行比较。只需依次添加剩下一个数组的其余内容到orderedPile。 归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。 从我刚才的描述，你有没有感觉到，分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。 所以归并排序的核心就是递归写法： 递推公式： merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r)) 终止条件： p &gt;= r 不用再继续分解 有了递推公式，转化成代码就简单多了: func merge(_ leftArray: [Int], _ rightArray: [Int]) -> [Int] { //1 var l = 0, r = 0 //2 var mergeArr: [Int] = [] //3 while l &lt; leftArray.count &amp;&amp; r &lt; rightArray.count { if leftArray[l] > rightArray[r] { mergeArr.append(rightArray[r]) r += 1 } else if leftArray[l] &lt; rightArray[r] { mergeArr.append(leftArray[l]) l += 1 } else { mergeArr.append(leftArray[l]) l += 1 mergeArr.append(rightArray[r]) r += 1 } } //4 while l &lt; leftArray.count { mergeArr.append(leftArray[l]) l += 1 } while r &lt; rightArray.count { mergeArr.append(rightArray[r]) r += 1 } return mergeArr } /* 1、如果数组为空或包含单个元素，则无法将其拆分为更小的部分，返回数组就行。 2、找到中间索引。 3、使用上一步中的中间索引，递归地分割数组的左侧。 4、递归地分割数组的右侧。 5、最后，将所有值合并在一起，确保它始终排序。 */ func mergeSort(_ array: Array&lt;Int>) -> Array&lt;Int> { //1 guard array.count > 1 else { return array } //2 let middle = array.count / 2 //3 let leftPart = mergeSort(Array(array[0..&lt;middle])) //4 let rightPart = mergeSort(Array(array[middle..&lt;array.count])) //5 return merge(leftPart, rightPart) } 2、快速排序快速排序是原地排序，也是递归实现，但快速排序不是稳定排序 归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。 快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。 快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。 我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。 直接递归： 1、设置中间位置元素为轴点元素pivot 2、分区：less equal more 3、递归合并分区 func quickSort&lt;T: Comparable>(_ array: [T]) -> [T]{ let pivot = array[array.count / 2] let less = array.filter { $0 &lt; pivot } let equal = array.filter { $0 == pivot } let more = array.filter { $0 > pivot } return quickSort(less) + equal + quickSort(more) } /* 1、从序列中选择中轴点pivot（假设选择位置为0的元素） 2、利用pivot中轴点把序列分成两个子序列 3、分别对左右子序列递归进行快速排序，直到元素不能分割位置 快速排序的本质是把每一个元素都转换成中轴点。 */ public func quickSortDutch&lt;T: Comparable>(_ a: inout [T], low: Int, high: Int) { if low &lt; high { let pivot = Int.random(in: low...high) let (p, q) = partationDutch(&amp;a, low: low, high: high, pivotIndex: pivot) quickSortDutch(&amp;a, low: low, high: p - 1) quickSortDutch(&amp;a, low: q + 1, high: high) } } Lomuto分区 Vs Hoare分区 Vs 荷兰国旗分区 Lomuto分区法:是用数组最后一个元素作为基准元素对数组分区，区域为[low…p-1] [p+1…high]，然后递归调用quickLomutoSort分别对左右区排序，一直到数组有序 Hoare分区：选择数组的first元素作为基准，数组划分区域为[low…p] [p+1…high]，然后递归调用quickSortHoare分别对左右区排序，一直到数组有序 /* 3 荷兰国旗分区：将前部和后部各排在数组的前边和后边，中部自然就排好了,分区函数返回(p, q) 设置两个标志位begin和end分别指向这个数组的开始和末尾，然后用一个标志位current从头开始进行遍历： 1）若遍历到的current &lt; pivot，于是就和begin位置进行交换，然后current向前进，begin也向前进（表示前边的已经都排好了）。 2）若遍历到current == pivot，则说明它一定属于中部，根据总思路，中部的我们都不动，然后current向前进。 3）若遍历到current > pivot，则说明它一定属于后部，于是就和end位置进行交换， 由于交换完毕后current指向的可能是属于前部的，若此时current前进则会导致该位置不能被交换到前部，所以此时current不前进。 end向后退1。 4) 返回分区（begin, end） */ func partationDutch&lt;T: Comparable>(_ a: inout [T], low: Int, high: Int, pivotIndex: Int) -> (Int, Int) { var begin = low, end = high var current = low, pivot = a[pivotIndex] while current &lt;= end { if a[current] &lt; pivot { a.swapAt(begin, current) begin += 1 current += 1 } else if a[current] == pivot { current += 1 } else { a.swapAt(current, end) end -= 1 } } return (begin, end) } 解答问题二： 快排核心思想就是分治和分区，我们可以利用分区的思想，来解答开这个问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。 我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。 如果 p+1=K，那 A[p]就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1]区间查找。 本文参考：王争-数据结构与算法之美","categories":[],"tags":[]},{"title":"反转问题","slug":"反转问题","date":"2020-03-15T03:35:25.039Z","updated":"2020-03-15T04:25:50.290Z","comments":true,"path":"2020/03/15/反转问题/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/15/%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98/","excerpt":"","text":"字符串反转方法一：递归 原地反转字符串是否代表了空间复杂度为常数？不，原地反转字符串是一种不使用辅助数据结构的算法。 我们使用递归的方法去反转字符串，它是原地反转，但是空间复杂度却不是常数级空间，因为递归过程中使用了堆栈空间。 算法过程 我们实现递归函数 helper，它接受两个参数：left 左指针和 right 右指针。 如果 left&gt;=right，不做任何操作。 否则交换 s[left] 和 s[right] 和调用 helper(left + 1, right - 1)。 首次调用函数我们传递首尾指针反转整个字符串 return helper(0, len(s) - 1)。 public void helper(char[] s, int left, int right) { if (left >= right) return; char tmp = s[left]; s[left++] = s[right]; s[right--] = tmp; helper(s, left, right); } public void reverseString(char[] s) { helper(s, 0, s.length - 1); } 复杂度分析时间复杂度：\\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。 空间复杂度：\\mathcal{O}(N)O(N)，递归过程中使用的堆栈空间。 方法二：双指针法双指针法是使用两个指针，一个左指针 left，右指针 right，开始工作时 left 指向首元素，right 指向尾元素。交换两个指针指向的元素，并向中间移动，直到两个指针相遇。 算法过程 将 left 指向首元素，right 指向尾元素。 当 left&lt;right： 交换 s[left] 和 s[right]。 left++ right++ // 双指针 func reverseStr(_ s: inout [Character]) -> [Character]{ var left = 0, right = s.count - 1 while left &lt; right { (s[left],s[right]) = (s[right],s[left]) left += 1 right -= 1 } return s } 测试用例let str = \"123456abcdef\" var characters = Array(str) print(characters)//[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] print(reverseStr(&amp;characters))//[\"f\", \"e\", \"d\", \"c\", \"b\", \"a\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"] 复杂度分析时间复杂度：\\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。空间复杂度：\\mathcal{O}(1)O(1)，只使用了常数级空间。 反转链表双指针法 定义两个指针pre cur : pre在前 cur 在后 如果cur节点不为空，设置pre.next = cur 实现一次翻转 翻转后pre 、cur同步向前一步 当pre为空终止循环 func reverseList(_ head: ListNode?) -> ListNode? { if head == nil || head?.next == nil { return head } var pre = head, cur: ListNode? while pre != nil { let temp = pre?.next pre?.next = cur cur = pre! pre = temp } return cur } 递归法核心：reversList(head) = reverseList(head.next) func reverseList2(_ head: ListNode?) -> ListNode? { if head == nil || head?.next == nil { return nil } let newHead = reverseList2(head?.next) head?.next?.next = head head?.next = nil return newHead } 反转链表 II题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明:1 ≤ m ≤ n ≤ 链表长度 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL题解思路 第一步：找到待反转节点的前一个节点。第二步：反转m到n这部分。第三步：将反转的起点的next指向反转的后面一部分。第四步：将第一步找到的节点指向反转以后的头节点。 public ListNode reverseBetween(ListNode head, int m, int n) { ListNode res = new ListNode(0); res.next = head; ListNode node = res; //找到需要反转的那一段的上一个节点。 for (int i = 1; i &lt; m; i++) { node = node.next; } //node.next就是需要反转的这段的起点。 ListNode nextHead = node.next; ListNode next = null; ListNode pre = null; //反转m到n这一段 for (int i = m; i &lt;= n; i++) { next = nextHead.next; nextHead.next = pre; pre = nextHead; nextHead = next; } //将反转的起点的next指向next。 node.next.next = next; //需要反转的那一段的上一个节点的next节点指向反转后链表的头结点 node.next = pre; return res.next; }","categories":[],"tags":[]},{"title":"智力题","slug":"智力题","date":"2020-03-15T02:44:43.844Z","updated":"2020-03-15T03:31:45.729Z","comments":true,"path":"2020/03/15/智力题/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/15/%E6%99%BA%E5%8A%9B%E9%A2%98/","excerpt":"","text":"智力题1、有两个水桶， 一个装 3L 的水， 一个可装 5L 的水， 问:如何利用这两个桶， 量出 4L 的水来？解法一加法：操作两次3L的桶，得到1L的水，然后倒入5L的桶里面，此时5L桶里有1L的水，再次用3L的桶倒入5L桶，1L+ 3L = 4L,一共操作3次3L桶 加法解法图示： 解法二减法：5L满水的桶倒入3L的桶，剩余2L，5L桶剩余的2L再次倒入3L桶，此时3L桶还有1L集满，5L桶再次装满后倒出来1L给3L桶里面，5L - 1L = 4L,连续操作3次5L桶 减法解法图示： 2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？首先2的6次方64，2的7次方128 &gt; 100因此我们可以用7个的二进制给100个瓶子编号，7只老鼠分别对应7个二进制位，如果瓶子编号出现1，老鼠喝下瓶子中的毒药，最后统计出被毒死老鼠的二进制数，转换为10进制就是有毒瓶子的编号。 解法图示：","categories":[],"tags":[]},{"title":"Runloop","slug":"Runloop","date":"2020-03-11T13:16:28.012Z","updated":"2020-03-13T17:26:08.484Z","comments":true,"path":"2020/03/11/Runloop/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/11/Runloop/","excerpt":"","text":"Runloop1.讲讲 RunLoop，项目中有用到吗？ 事件循环，在程序运行中循环做一些事情 没有消息mach_msg()切换用户态到内核态线程休眠，有消息内核态切换到用户态 runloop相关： Timer、performSelector GCD、AutoreleasePool 事件响应、收拾识别、网络请求 runloop的应用： 线程包活 解决timer滑动停止问题 监听主线程卡顿 性能优化 2.runloop的6种状态和runloop内部实现逻辑？/* Run Loop Observer Activities */ typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出Loop kCFRunLoopAllActivities = 0x0FFFFFFFU }; source0 : 触摸事件、performSelectorOnThread: source1: 基于Port的线程间通讯，捕获到的系统事件 timers: NSTimer + performSelector:afterDelay: observers: 监听runloop的状态/autoreleasePool的创建和释放、UI的刷新 3.runloop和线程的关系？ 一一对应 保存在一个全局字典中，线程是key, runloop是value 子线程默认没有runloop，在第一次获取runloop时才会创建。 runloop在线程结束时销毁 4.timer 与 runloop 的关系？程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？5.runloop 是怎么响应用户操作的， 具体流程是什么样的？6.说说runLoop的几种状态7.runloop的mode作用是什么？ CFRunLoopModeRef代表RunLoop的运行模式 一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer RunLoop启动时只能选择其中一个Mode，作为currentMode 如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入 不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响 如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出 8.KVO实现原理?哪些情况下使用kvo会崩溃，怎么防护崩溃?9.如何手动关闭KVO?如何手动自己实现KVO说说思路10.通过KVC修改属性会触发KVO么","categories":[],"tags":[]},{"title":"iOS多线程","slug":"iOS多线程","date":"2020-03-11T12:34:15.299Z","updated":"2020-03-26T03:40:12.723Z","comments":true,"path":"2020/03/11/iOS多线程/","link":"","permalink":"https://mingriweiji-github.github.io/2020/03/11/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"深入理解GCDdispatch_async 会把任务添加到队列的一个链表中，添加完后会唤醒队列，根据 vtable 中的函数指针，调用 wakeup 方法。 在 wakeup 方法中，从线程池里取出工作线程(如果没有就新建)，然后在工作线程中取出链表头部指向的 block 并执行。 dispatch_sync 的实现略简单一些，它不涉及线程池(因此一般都在当前线程执行)，而是利用与线程绑定的信号量来实现串行。 分发到不同队列时，代码进入的分支也不一样，比如 dispatch_async 到主队列的任务由 runloop 处理，而分发到其他队列的任务由线程池处理。 在当前串行队列中执行 dispatch_sync 时，由于 dq_running 属性(表示在运行的任务数量) 为 1，所以以下判断成立: if (slowpath(!dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1))) { return _dispatch_barrier_sync_f_slow(dq, ctxt, func); } 在 _dispatch_barrier_sync_f_slow 函数中使用了线程对应的信号量并且调用 wait 方法，从而导致线程死锁。 如果向其它队列同步提交 block，最终进入 _dispatch_barrier_sync_f_invoke，它只是保证了 block 执行的原子性，但没有使用线程对应的信号量。 对于信号量来说，它主要使用 signal 和 wait 这两个接口，底层分别调用了内核提供的方法。 在调用 wait 方法后，先将 value 减一，如果大于零立刻返回，否则陷入等待。signal 方法将信号量加一，如果 value 大于零立刻返回，否则说明唤醒了某一个等待线程，此时由系统决定哪个线程的等待方法可以返回。 dispatch_group 的本质就是一个 value 非常大的信号量，等待 group 完成实际上就是等待 value 恢复初始值。而 notify 的作用是将所有注册的回调组装成一个链表，在 dispatch_async 完成时判断 value 是不是恢复初始值，如果是则调用 dispatch_async 异步执行所有注册的回调。 dispatch_once 通过一个静态变量来标记 block 是否已被执行，同时使用信号量确保只有一个线程能执行，执行完 block 后会唤醒其他所有等待的线程。 dispatch_barrier_async 改变了 block 的 vtable 标记位，当它将要被取出执行时，会等待前面的 block 都执行完，然后在下一次循环中被执行。 dispatch_source 可以用来实现定时器。 所有的 source 会被提交到用户指定的队列，然后提交到 manager 队列中，按照触发时间排好序。 随后找到最近触发的定时器，调用内核的 select 方法等待。 等待结束后，依次唤醒 manager 队列和用户指定队列，最终触发一开始设置的回调 block。 GCD 中的对象用 do_suspend_cnt 来表示是否暂停。队列默认处于启动状态，而 dispatch_source 需要手动启动。 dispatch_after 函数依赖于 dispatch_source 定时器，它只是注册了一个定时器，然后在回调函数中执行 block。 GCD死锁案例分析 NSOperation案例分析 深入理解iOS开发中的锁 自旋锁的目的是为了确保临界区只有一个线程可以访问bool lock = false; // 一开始没有锁上，任何线程都可以申请锁 do { while(test_and_set(&lock); // test_and_set 是一个原子操作 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码 } 显然在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。 如果临界区的执行时间过长，使用自旋锁不是个好主意 信号量 首先会把信号量的值减一，并判断是否大于零。 如果大于零，说明不用等待，所以立刻返回。小于0等待signal唤醒线程 pthread_mutex互斥锁 互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。 pthread_mutexattr_t attr; pthread_mutexattr_init(&attr); pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL); // 定义锁的属性 pthread_mutex_t mutex; pthread_mutex_init(&mutex, &attr) // 创建锁 pthread_mutex_lock(&mutex); // 申请锁 // 临界区 pthread_mutex_unlock(&mutex); // 释放锁 一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。 假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。 然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。 NSLock NSLock 只是在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。 NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。 NSCondition NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。 条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程**，并等待某个数据就绪，随后唤醒线程**，比如常见的生产者-消费者模式。 NSCondition 其实是封装了一个互斥锁和条件变量， 它把前者的 lock 方法和后者的 wait/signal 统一在 NSCondition 对象中，暴露给使用者 它的加解锁过程与 NSLock 几乎一致，理论上来说耗时也应该一样(实际测试也是如此)。在图中显示它耗时略长，我猜测有可能是测试者在每次加解锁的前后还附带了变量的初始化和销毁操作。 NSRecursiveLock 递归锁也是通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器加一，锁的释放过程也是同理。 使用递归锁NSRecursiveLock NSLock *lock = [[NSLock alloc] init]; dispatch_async(dispatch_get_global_queue(0, 0), ^{ static void (^RecursiveMethod)(int); RecursiveMethod = ^(int value) { [lock lock];//递归调用时失败，NSLock不能被同一线程多次获取，多次获取使用NSRecursiveLock if (value > 0) { NSLog(@\"value = %d\", value); sleep(2); RecursiveMethod(value - 1); } [lock unlock]; }; RecursiveMethod(5); }); @synchronized这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。 你调用 sychronized 的每个对象，runtime 都会为其分配一个递归锁并存储在哈希表中。 如果在 sychronized 内部对象被释放或被设为 nil 看起来都 OK。不过这没在文档中说明，所以我不会再生产代码中依赖这条。 注意不要向你的 sychronized block 传入 nil！这将会从代码中移走线程安全。你可以通过在 objc_sync_nil 上加断点来查看是否发生了这样的事情。 1、你理解的多线程？并发和串行，同步和异步 同步和异步的区别: 是否开辟新的线程，同步只能在当前线程执行任务，异步可以再新的线程执行任务 串行和并发的区别:是任务执行的顺序，串行任务只能顺序执行，并发可以多个任务同时执行。 2、iOS多线程有哪些？常用哪个？ NSThread、GCD/NSOperationQueue 常用GCD/NSOperation 3、GCD 的队列类型有哪些？GCD的队列可以分为2大类型 并发队列（Concurrent Dispatch Queue） 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务） 并发功能只有在异步（dispatch_async）函数下才有效 串行队列（Serial Dispatch Queue） 让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务） 4、OperationQueue 和 GCD 的区别？ GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择； 在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)； NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行； 我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样子能比GCD更加有效地掌控我们执行的后台任务； 在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码； 我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。 总的来说，Operation queue 提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。 从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。 5、线程安全是什么？如何处理线程安全的问题？ 我们一般通过线程同步方案如加锁的方式来实现线程的安全 iOS锁的原理 | 深入浅出iOS系统内核-同步机制 os_unfair_lock：iOS10开始os_unfair_lock来替代OSSpinLock, 等待锁的线程会进入休眠不占用CPU资源， 这个os_unfair_lock解决了优先级翻转问题。 OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等一直占用着CPU资源 dispatch_semaphore：信号量为1的semaphore也可以看做是锁 pthread_mutex：跨平台的互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。 使用GCD的串行队列也可以实现锁的功能 NSLock是对metex互斥锁的封装，NSRecurisiveLock也是对metex的递归封装，API和NSLock一直。 NSCondition NSConditionLock @synchorized也是mutex的递归封装，@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作。 6、自旋锁和互斥锁如何选择？自旋锁OSSpinLock：当线程获取锁，其他等待锁的线程会忙等一直占用CPU,自旋锁有优先级翻转的可能性，所以苹果已经弃用自旋锁OSSpinLock改用os_unfair_lock. 互斥锁mutext：阻塞线程并休眠，其他线程才能正常访问，用互斥的方式来保证线程的安全。 递归锁：顾名思义，可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。 什么情况使用自旋锁比较划算？ 预计线程等待锁的时间很短 竞争情况很少发生，加锁的代码（临界区）经常被调用 CPU资源不紧张 多核处理器 什么情况使用互斥锁比较划算？ 预计线程等待锁的时间较长 临界区代码复杂或者循环量大 临界区竞争非常激烈 单核处理器 临界区有IO操作 追问二：使用以上锁需要注意哪些？ 追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！ 7、iOS线程同步方案性能比较性能从高到低排序: os_unfair_lock &gt; OSSpinLock &gt; dispatch_semaphore &gt; pthread_mutex &gt; dispatch_queue(DISPATCH_QUEUE_SERIAL) &gt; NSLock &gt; NSCondition &gt; pthread_mutex(recursive) &gt; NSRecursiveLock &gt; NSConditionLock &gt; @synchronized**8、如何用gcd实现并发执行1和2再执行任务3的方案？ 异步并发执行任务1、任务2 等任务1、任务2都执行完毕后，再回到主线程执行任务3 dispatch_group_notifydispatch_barrier_asyncdispatch_sempher(2) let group = DispatchGroup() let queue = DispatchQueue.init(label: \"handleAPIQueue\") group.enter() queue.async { print(\"任务1完成\") group.leave() } group.enter() queue.async { DispatchQueue.main.asyncAfter(deadline: .now() + 3) { print(\"任务2完成\") group.leave() //注意leave的位置必须在任务完成后 } } //group.leave() //如果leave放在这里的话，notify不会等待任务2完成就会触发 group.enter() queue.async { print(\"任务3完成\") group.leave() } group.notify(queue: queue) { print(\"所有任务都完成了\") } 网络请求应用实例 9、如何实现多度单写？dispatch_barrier_async 这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的 如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果 dispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.queue.concurrent\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(concurrentQueue, ^{ NSLog(@\"async_1\"); }); dispatch_async(concurrentQueue, ^{ NSLog(@\"async_2\"); }); dispatch_async(concurrentQueue, ^{ NSLog(@\"async_3\"); }); dispatch_barrier_async(concurrentQueue, ^{//dispatch_barrier_sync效果相同 NSLog(@\"dispatch_barrier_async\"); }); dispatch_async(concurrentQueue, ^{ NSLog(@\"async_4\"); }); /* 01-OC底层[25009:1007376] async_1 01-OC底层[25009:1007372] async_3 01-OC底层[25009:1007374] async_2 01-OC底层[25009:1007372] dispatch_barrier_async 01-OC底层[25009:1007372] async_4 */ 10、GCD实现暂停和继续注意什么？ dispatch_queue_t conQueue = dispatch_queue_create(\"com.seria.queue\", DISPATCH_QUEUE_CONCURRENT); size_t count = 5; dispatch_apply(5, conQueue, ^(size_t index) { NSLog(@\"numer is %zu\",index); if (index == 2) { // dispatch_suspend(concurrentQueue);// suspend并不能停止当前队列的任务，只能停止后面队列中的任务 } }); dispatch_suspend(conQueue); // dispatch_suspend 不能单独使用，和dispatch_resume配对使用 NSLog(@\"task1---\"); dispatch_async(conQueue, ^{ NSLog(@\"async1\"); }); NSLog(@\"task2---\"); dispatch_resume(conQueue); dispatch_async(conQueue, ^{ NSLog(@\"async2\"); }); NSLog(@\"task3---\"); 11、案例分析使用 Dispatch Source定时器Dispatch Source Timer利用 Dispatch Source 的 DISPATCH_SOURCE_TYPE_TIMER 类型，我们可以创建一个 跨线程的 定时器（我们平时使用的 NSTimer 是基于 Run Loop 的 timer 事件，只能在对应的线程里触发） dispatch_queue_t queue = dispatch_get_main_queue(); //1、创建一个 timer； self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); //2、配置 timer，从现在起，每两秒在主线程触发一次，精度为0s dispatch_source_set_timer(self.timer, DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC, 0 * NSEC_PER_SEC); //3、timer 触发之后的回调 block dispatch_source_set_event_handler(self.timer, ^{ NSLog(@\"%ld\", self.count++); }); //4、启动 timer dispatch_resume(self.time);","categories":[],"tags":[]},{"title":"红黑树前世今生","slug":"红黑树前世今生","date":"2019-12-30T07:28:54.939Z","updated":"2019-12-30T07:28:54.939Z","comments":true,"path":"2019/12/30/红黑树前世今生/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/30/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/","excerpt":"","text":"红黑树前世今生关键词：二叉搜索树、前驱节点、后继节点、B树、红黑树 什么是B树前世B树是一种相对于来说特殊二叉搜索树，多用于数据库和文件搜索系统中。 n阶B树的性质 B树是一种平衡的多路搜索树，拥有平衡二叉树的一些特性，与平衡二叉树的最大区别在于每个节点不再是只能存储一个元素，而且每个节点可以拥有多个子节点而像二叉平衡树只能拥有两个。 B树每个节点最多可以存储超过2个元素，可以拥有超过2个子节点 B树每个子节点的子树高度一致 B树和二叉搜索树一样，左子树&lt;根节点&lt;右子树 根节点元素个数: 1≤ X ≤ n - 1 非根节点元素个数: n/2 - 1 ≤ x ≤ n - 1 (n/2 向上取整) 如果有子节点，子节点个数 y = x + 1, 根节点 2 ≤ y ≤ n非根节点 n / 2 ≤ y ≤ n (n/2 向上取整) 数据库中一般使用的是200-300阶B树 4阶B树元素个数为(2-3-4)，所以4阶B树也叫2-4树或者2-3-4树 5阶B树元素个数为 3-4-5 所以5阶B树叫（3，5）树 6阶B树元素个数3-4-5-6，所以6阶B树叫（3，6）树 7阶B树元素个数为4-5-6-7，所以7阶B树叫（4，7）树 B树 VS 二叉搜索树 B树与二叉搜索树逻辑上等价 n阶B树最多需要log2 N代合并 多代节点合并可以获得超节点 2代合并最多拥有4个子节点 3代合并最多拥有8个子节点 n代合并最多拥有2^n个子节点（至少是2^n阶B树） B树的添加与上溢上溢出（overflow）:添加元素到子节点后，该节点元素个数大于N时，我们称之为上溢出 B树的元素添加的位置一定是叶子节点 B树添加导致上溢 B树上溢最极端的情况是一直分裂到根节点 B树的删除与下溢删除 删除叶子节点的话直接删除 删除的非叶子节点的话：1、先找到前驱或后继节点元素，覆盖需要删除的值，2、把前驱或后继元素删除（说明：一个树的前驱在左子树的最后边，后驱在右子树的最左边。） 非叶子节点前驱或后继元素，必然是在叶子节点中，所以真正删除的元素都是叶子节点 下溢出（underflow）：叶子节点被删除一个元素后，元素个数可能会低于最低限制 （n/2 - 1 向上取整） 下溢出的解决方案是旋转，总体元素是哪个方向失衡往哪个方向转，子树大小顺序不能乱 4阶B树 4阶B树所有节点都能储存的元素个数x: 1 ≤ x ≤ 3 4阶B树非叶子节点的子节点个数：2 ≤ y ≤ 4 为什么需要红黑树?红黑树是在二叉搜索树的基础上对AVL树的改进，二叉搜索树顾名思义是对搜索算法的一种优化，能够大大减少我们元素对比的次数。红黑树在Java中的应用如HashSet(底层是数组单链表和红黑树)、数据库搜索也有应用。 什么是红黑树？红黑树是一种自平衡的二叉搜索树也叫平衡二叉B树 红黑树5个性质 节点分为红色与黑色 根节点是黑色 叶子节点是黑色 不能有两个连续的红色节点 从任意节点到叶子节点上所有路径的黑色节点数目必须相等 红黑树等价变换红黑树等价于4阶B树 红黑树添加失衡如何解决？添加失衡 Parrent节点为黑色时不需要处理 Parrent节点为红色（Double Red） Uncle节点不是red: LL/RR LR/RL Uncle节点是red: 红黑树删除节点失衡如何解决？红黑树 VS AVL树搜索性能添加删除实际应用Java8中的hashMap是使用数组+链表实现的，在解决哈希碰撞时使用了红黑树。","categories":[],"tags":[]},{"title":"二叉树前世今生","slug":"二叉树前世今生","date":"2019-12-30T07:28:54.936Z","updated":"2019-12-30T07:28:54.937Z","comments":true,"path":"2019/12/30/二叉树前世今生/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/","excerpt":"","text":"二叉树今生为什么会有二叉树这种数据结构？ 思考一个问题：如果一个集合中有42亿个元素，让你从这42亿个元素中搜索某一个元素，你需要多少次操作？ 如果使用数组链表的话最多可能需要42亿次比较，而如果使用二叉树我们只需要32次比较即可，这就是二叉树存在的价值。Java中的HashSet使用的就是二叉树 前驱与后继前驱节点 若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode） 若一个节点没有左子树，那么判断该节点和其父节点的关系 2.1 若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。 2.2 若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点 后继节点 若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode） 若一个节点没有右子树，那么判断该节点和其父节点的关系2.1 若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点2.2 若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点 如何判断两个二叉树是否相同？ 递归法 static public bool IsSameTree(TreeNode root1, TreeNode root2) { if (root1 == null && root2 == null) { return true; } if ((root1 == null && root2 != null) || (root1 != null && root2 == null)) { return false; } if (root1.val != root2.val) {//判断每个节点的值是否相等，如果去除此判断，则判断两个二叉树是否结构相等 return false; } return IsSameTree(root1.left, root2.left) && IsSameTree(root1.right, root2.right); } 非递归法 bool BTreeCompare（BTreeNode_t *pRoot1, BTreeNode_t *pRoot2) { if( pRoot1 == NULL && pRoot2 == NULL ) return false; queue que1; queue que2; que1.push(pRoot1); que2.push(pRoot2); int curLevelNodeTotal1 = 0; int curLevelNodeTotal2 = 0; bool flag = true; //作为比较不一致时跳出标识 while( ( !que1.empty()) && ( !que2.empty())) //当两个队列均不为空时，才进行比较 { curLevelNodeTotal1 = que1.size(); //获取树1的当前层节点总数 curLevelNodeTotal2 = que2.size(); //获取树2的当前层节点总数 if( curLevelNodeTotal1 != curLevelNodeTotal2){ flag = false;//当前层节点总数都不一致，不需要比较了，直接跳出 break; } int cnt1 = 0;//遍历本层节点时的计数器 int cnt2 = 0; while( cnt1 < curLevelNodeTotal1 && cnt2 < curLevelNodeTotal2){ ++cnt1; ++cnt2; pRoot1 = que1.front(); que1.pop(); pRoot2 = que2.front(); que2.pop(); //比较当前节点中数据是否一致 if( pRoot1->m_pElemt != pRoot2->m_pElemt ){ flag = false; break; } //判断pRoot1和pRoot2左右节点结构是否相同 if( ( pRoot1->m_pLeft != NULL && pRoot2->m_pLeft == NULL ) || ( pRoot1->m_pLeft == NULL && pRoot2->m_pLeft != NULL ) || ( pRoot1->m_pRight != NULL && pRoot2->m_pRight == NULL ) || ( pRoot1->m_pRight == NULL && pRoot2->m_pRight != NULL ) ){ flag = false; break; } //将左右节点入队 if( pRoot1->m_pLeft != NULL ) que1.push( pRoot1->m_pLeft); if( pRoot1->m_pRight != NULL ) que1.push( pRoot1->m_pRight); if( pRoot2->m_pLeft != NULL ) que2.push( pRoot2->m_pLeft); if( pRoot2->m_pRight != NULL ) que2.push( pRoot2->m_pRight); } if( flag == false ) break; } //如果比较标志为false，则不相同 if( flag == false ){ while( !que1.empty() ) que1.pop(); while( !que2.empty()) que2.pop(); return false; } return true; }","categories":[],"tags":[]},{"title":"iOS图像处理","slug":"iOS图像处理","date":"2019-12-30T07:28:54.924Z","updated":"2020-03-26T08:59:08.699Z","comments":true,"path":"2019/12/30/iOS图像处理/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/30/iOS%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"iOS图像优化技巧 1、如何处理大尺寸图片？ 2、如何处理瀑布流图片占用大量内存的问题？ 3、如何处理多张图片上传和下载问题？ 1、处理大尺寸图片那么，什么时候对图像进行渲染优化才有意义呢？ 当它明显大于 UIImageView 显示尺寸的时候 想要完整渲染这张宽高为 12,000 px 的图片，需要高达 20 MB 的空间。对于当今的硬件来说，你可能不会在意这么少兆字节的占用。但那只是它压缩后的尺寸。要展示它，UIImageView 首先需要把 JPEG 数据解码成位图（bitmap），如果要在一个 UIImageView 上按原样设置这张全尺寸图片，你的应用内存占用将会激增到几百兆，对用户明显没有什么好处（毕竟，屏幕能显示的像素有限）。但只要在设置 UIImageView 的 image 属性之前，将图像渲染的尺寸调整成 UIImageView 的大小，你用到的内存就会少一个数量级： 内存消耗 (MB) 无下采样 220.2 下采样 23.7 这个技巧就是众所周知的下采样（downsampling），在这些情况下，它可以有效地优化你应用的性能表现。如果你想了解更多关于下采样的知识或者其它图形图像的最佳实践，请参照 来自 WWDC 2018 的精彩课程。 而现在，很少有应用程序会尝试一次性加载这么大的图像了，但是也跟我从设计师那里拿到的图片资源不会差太多。（认真的吗？一张颜色渐变的 PNG 图片要 3 MB?） 考虑到这一点，让我们来看看有什么不同的方法，可以让你用来对图像进行优化或者下采样。 不用说，这里所有从 URL 加载的示例图像都是针对本地文件。记住，在应用的主线程同步使用网络请求图像绝不是什么好主意。 图像渲染优化技巧优化图像渲染的方法有很多种，每种都有不同的功能和性能特性。我们在本文看到的这些例子，架构层次跨度上从底层的 Core Graphics、vImage、Image I/O 到上层的 Core Image 和 UIKit 都有。 绘制到 UIGraphicsImageRenderer 上 绘制到 Core Graphics Context 上 使用 Image I/O 创建缩略图像 使用 Core Image 进行 Lanczos 重采样 使用 vImage 优化图片渲染 下面的这些数字是多次迭代加载、优化、渲染之前那张 超大地球图片 的平均时间： 耗时 (seconds) 技巧 #1: UIKit 0.1420 技巧 #2: Core Graphics 1 0.1722 技巧 #3: Image I/O 0.1616 技巧 #4: Core Image 2 2.4983 技巧 #5: vImage 2.3126 1设置不同的 CGInterpolationQuality 值出来的结果是一致的，在性能上的差异可以忽略不计。 2若在 CIContext 创建时设置 kCIContextUseSoftwareRenderer 的值为 true，会导致耗时相比基础结果慢一个数量级。 使用CGContextDrawImage()异步解码图片 dispatch_async(dispatch_get_global_queue(0, 0), ^{ // 1、获取CGImage CGImageRef cgImage = [UIImage imageNamed:@\"img\"].CGImage; // alphaInfo CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage) & kCGBitmapAlphaInfoMask; BOOL hasAlpha = NO; if (alphaInfo == kCGImageAlphaPremultipliedLast || alphaInfo == kCGImageAlphaPremultipliedFirst || alphaInfo == kCGImageAlphaLast || alphaInfo == kCGImageAlphaFirst) { hasAlpha = YES; } // bitmapInfo CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; // size size_t width = CGImageGetWidth(cgImage); size_t height = CGImageGetHeight(cgImage); // 2、获取context CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo); //3、 draw CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage); // get CGImage cgImage = CGBitmapContextCreateImage(context); // into UIImage UIImage *newImage = [UIImage imageWithCGImage:cgImage]; // release CGContextRelease(context); CGImageRelease(cgImage); // back to the main thread dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = newImage; }); }); 技巧 #1: 绘制到 UIGraphicsImageRenderer 上图像渲染优化的最上层 API 位于 UIKit 框架中。给定一个 UIImage，你可以绘制到 UIGraphicsImageRenderer 的上下文（context）中以渲染缩小版本的图像： import UIKit // 技巧 #1 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { guard let image = UIImage(contentsOfFile: url.path) else { return nil } let renderer = UIGraphicsImageRenderer(size: size) return renderer.image { (context) in image.draw(in: CGRect(origin: .zero, size: size)) } }UIGraphicsImageRenderer 是一项相对较新的技术，在 iOS 10 中被引入，用以取代旧版本的 UIGraphicsBeginImageContextWithOptions / UIGraphicsEndImageContext API。你通过指定以 point 计量的 size 创建了一个 UIGraphicsImageRenderer。image 方法带有一个闭包参数，返回的是一个经过闭包处理后的位图。最终，原始图像便会在缩小到指定的范围内绘制。 技巧 #2：绘制到 Core Graphics Context 中Core Graphics / Quartz 2D 提供了一系列底层 API 让我们可以进行更多高级的配置。 给定一个 CGImage 作为暂时的位图上下文，使用 draw(_:in:) 方法来绘制缩放后的图像： import UIKit import CoreGraphics // 技巧 #2 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil), let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil) else { return nil } let context = CGContext(data: nil, width: Int(size.width), height: Int(size.height), bitsPerComponent: image.bitsPerComponent, bytesPerRow: image.bytesPerRow, space: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!, bitmapInfo: image.bitmapInfo.rawValue) context?.interpolationQuality = .high context?.draw(image, in: CGRect(origin: .zero, size: size)) guard let scaledImage = context?.makeImage() else { return nil } return UIImage(cgImage: scaledImage) }这个 CGContext 初始化方法接收了几个参数来构造一个上下文，包括了必要的宽高参数，还有在给出的色域范围内每个颜色通道所需要的内存大小。在这个例子中，这些参数都是通过 CGImage 这个对象获取的。下一步，设置 interpolationQuality 属性为 .high 指示上下文在保证一定的精度上填充像素。draw(_:in:) 方法则是在给定的宽高和位置绘制图像，可以让图片在特定的边距下裁剪，也可以适用于一些像是人脸识别之类的图像特性。最后 makeImage() 从上下文获取信息并且渲染到一个 CGImage 值上（之后会用来构造 UIImage 对象）。 技巧 #3：使用 Image I/O 创建缩略图像处理大分辨率图片时，往往容易出现OOM，原因是-[UIImage drawInRect:]在绘制时，先解码图片，再生成原始分辨率大小的bitmap，这是很耗内存的。 解决方法是使用更低层的ImageIO接口，避免中间bitmap产生： Image I/O 是一个强大（却鲜有人知）的图像处理框架。 它可以读写许多不同图像格式，访问图像的元数据，还有执行常规的图像处理操作。这个框架通过先进的缓存机制，提供了平台上最快的图片编码器和解码器，甚至可以增量加载图片。 这个重要的 CGImageSourceCreateThumbnailAtIndex 提供了一个带有许多不同配置选项的 API，比起在 Core Graphics 中等价的处理操作要简洁得多： import ImageIO // 技巧 #3 func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? { let options: [CFString: Any] = [ kCGImageSourceCreateThumbnailFromImageIfAbsent: true, kCGImageSourceCreateThumbnailWithTransform: true, kCGImageSourceShouldCacheImmediately: true, kCGImageSourceThumbnailMaxPixelSize: max(size.width, size.height) ] guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil), let image = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, options as CFDictionary) else { return nil } return UIImage(cgImage: image) }给定一个 CGImageSource 和一系列配置选项，CGImageSourceCreateThumbnailAtIndex(_:_:_:) 函数创建了一个图像的缩略图。优化尺寸大小的操作是通过 kCGImageSourceThumbnailMaxPixelSize 完成的，它根据图像原始宽高比指定的最大尺寸来缩放图像。通过设定 kCGImageSourceCreateThumbnailFromImageIfAbsent 或 kCGImageSourceCreateThumbnailFromImageAlways 选项，Image I/O 可以自动缓存优化后的结果以便后续调用。 总结 UIKit, Core Graphics, 和 Image I/O 都能很好地用于大部分图片的优化操作。 如果（在 iOS 平台，至少）要选择一个的话，UIGraphicsImageRenderer 是你最佳的选择。 Core Image 在图像优化渲染操作方面性能表现优越。实际上，根据 Apple 官方 Core Image 编程规范中的性能最佳实践单元，你应该使用 Core Graphics 或 Image I/O 对图像进行裁剪和下采样，而不是用 Core Image。 除非你已经在使用 vImage，否则在大多数情况下用到底层的 Accelerate API 所需的额外工作可能是不合理的。 本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 http://swift.gg。 2、同时处理大量图片UIScrollView滚动停止监测通过调查发现 UIScrollView 停止滚动的类型分为三种： 快速滚动，自然停止 快速滚动，手指按压突然停止 慢速上下滑动停止 第1种类型，比较简单，在 UIScrollView 的代理中就可以监听到。 - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; 而第2种类型和第3种类型，就没有方法让我们可以直接监听到了。但是只要是滑动了，就一定会触发 UIScrollView 的下面代理，然后通过 UIScrollView 部分属性的改变，我们就可以监听到滚动停止了，后面会详细介绍方法。 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; 监听UIScrollView停止滚动通过翻阅文档，我们可以看到 UIScrollView 有三个属性: tracking、dragging、decelerating。 // returns YES if user has touched. may not yet have started dragging @property(nonatomic,readonly,getter=isTracking) BOOL tracking; // returns YES if user has started scrolling. this may require some time and or distance to move to initiate dragging @property(nonatomic,readonly,getter=isDragging) BOOL dragging; // returns YES if user isn't dragging (touch up) but scroll view is still moving @property(nonatomic,readonly,getter=isDecelerating) BOOL decelerating; 在滚动和滚动结束时，这三个属性的值都不相同。我们利用这三个属性，完成对 UIScrollView 停止滚动的监听。 停止类型1：scrollViewDidEndDecelerating - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; tracking:0,dragging:0,decelerating:0 停止类型2：scrollViewDidEndDragging &amp; scrollViewDidEndDecelerating - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; tracking:1,dragging:0,decelerating:1 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; tracking:0,dragging:0,decelerating:0停止类型3：scrollViewDidEndDragging - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; tracking:1,dragging:0,decelerating:0通过上面的代码，可以发现，我们只需要对 UIScrollView 的这三个属性进行相应的组合，就可以监听到 UIScrollView 停止滚动的事件了。 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView { [self stoppedScrolling]; } - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { if (!decelerate) { [self stoppedScrolling]; } } - (void)stoppedScrolling { // ... NSLog(@\"停止滚动了！！！\"); } -(void)scrollViewDidScroll:(UIScrollView *)sender { [NSObject cancelPreviousPerformRequestsWithTarget:self]; [self performSelector:@selector(scrollViewDidEndScrollingAnimation:) withObject:nil afterDelay:0.1]; } -(void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView { [NSObject cancelPreviousPerformRequestsWithTarget:self]; } 3、处理多图上传下载问题？UI刷新问题layout的相关方法: layoutSubviews layoutIfNeeded setNeedsLayout setNeedsDisplay drawRect sizeThatFits sizeToFit layoutSubviews这个方法，默认没有做任何事情，需要子类进行重写 。 系统在很多时候会去调用这个方法： 1.初始化不会触发layoutSubviews，但是如果设置了不为CGRectZero的frame的时候就会触发。2.addSubview会触发layoutSubviews3.设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化4.滚动一个UIScrollView会触发layoutSubviews5.旋转Screen会触发父UIView上的layoutSubviews事件6.改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件 You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。 反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。 setNeedsLayout 标记为需要重新布局，不立即刷新，但layoutSubviews一定会被调用 配合layoutIfNeeded立即更新 layoutIfNeeded 如果有需要刷新的标记，立即调用layoutSubviews进行布局","categories":[],"tags":[]},{"title":"Swift备忘录","slug":"Swift备忘录","date":"2019-12-07T04:48:29.505Z","updated":"2020-03-24T16:45:03.066Z","comments":true,"path":"2019/12/07/Swift备忘录/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/07/Swift%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"SwiftTip","text":"SwiftTip Swift访问控制权限Swift的访问权限管理依赖于两个概念：module和文件。module是一个完整的代码单元， 它可以是一个或多个框架（Framework），或者是一个App Bundle，可以被import导入到工程中。 文件指的就是Swift File，它通常属于一个module。 Swift 为代码中的实体提供了5种不同的访问级别:open、public、internal、fileprivate、private。 访问级别 定义 open 这个属性允许在 app 内或 app 外重写和访问。在开发框架的时候，会应用到这个访问修饰符。 public 可以访问自己模块中源文件里的任何实体，别人也可以通过引入该模块来访问源文件里的所有实体。 internal 默认权限可以访问自己module中源文件里的任何实体 fileprivate 只能在当前源文件中使用。 private 只允许实体在定义的类以及相同源文件内的 extension 中访问 Open 为最高级访问级别，private 为最低级访问级别。 class Person { private var name: String? } *如果希望name仅在当前文件中可访问，可以使用private修饰 * class Person { private(set) var name: String? } 如果希望外部可以读取，但不可以修改。这也是为了保证类型的封装和安全，在内部提供可读可写，而外部仅仅可读 这种写法相当于把setter设置为private，而getter仍然是默认的internal class Person { public private(set) var name: String? } 如果既想要外部可读，又想仅内部可写，可以为getter加上public： 声明关键字associatedtype：在协议中，定义一个类型的占位符名称。直到协议被实现，该占位符才会被指定具体的类型。 protocol Entertainment { associatedtype MediaType } class Foo : Entertainment { typealias MediaType = String //可以指定任意类型 } class：通用、灵活的结构体，是程序的基础组成部分。与 struct 类似，不同之处在于： 允许一个类继承另一个类的特性。 类型转换，允许在运行时检查和指定一个类的实际类型。 析构方法允许类的实例释放所有资源。 引用计数允许多个引用指向一个实例。 struct：通用、灵活的结构体，是程序的基础组成部分，并提供了默认初始化方法。与 class 不同，当 struct 在代码中被传递时，是被拷贝的，并不使用引用计数。除此之外，struct 没有下面的这些功能： 使用继承。 运行时的类型转换。 使用析构方法。 struct Person { var name:String var age:Int var gender:String } extension：允许给已有的类、结构体、枚举、协议类型，添加新功能。 NSError：code、domin、userInfo Swift Error分类 domain error Recoverable error Universal error Logic error enum Result&lt;T> { case Success(T) case Failure(NSError) } try!表示强制执行，如果发生异常程序crash try?返回可选项，如果发生异常返回nil否则返回正常结果 enum E: Error { case Negative } func methodThrowsWhenPassingNegative(number: Int) throws -> Int { if number &lt; 0 { throw E.Negative } return number } if let num = try? methodThrowsWhenPassingNegative(100) { print(num.dynamicType) } else { print(\"failed\") } @autoclosure作用：将表达式自动封装成一个闭包()-&gt;Void 1.2 ??的底层实现是用的enum 1.3 “闭包和循环引用” weak解决循环引用的正确写法： var name: ()->() = { [weak self] in if let strongSelf = self { print(\"The name is (strongSelf.name)\") } } 值类型和引用类型的选择 数组和字典设计为值类型最大的考虑是为了线程安全. 另一个优点，那就是非常高效，因为 “一旦赋值就不太会变化” 这种使用情景在 Cocoa 框架中是占有绝大多数的，这有效减少了内存的分配和回收。 但是在少数情况下，我们显然也可能会在数组或者字典中存储非常多的东西，并且还要对其中的内容进行添加或者删除。” 在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好， 对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary @escaping的作用？ class func animate(withDuration duration: TimeInterval, animations: @escaping () -&amp;gt; Void, completion: ((Bool) -> Void)? = nil) defer的使用注意点defer的作用域 以前很单纯地认为 defer 是在函数退出的时候调用，并没有注意其实是当前 scope 退出的时候调用这个事实，造成了这个错误。在 if，guard，for，try 这些语句中使用 defer 时，应该要特别注意这一点。 @discardableResultResultResult&lt;T, E: Error&gt; 和 Result Lazy的使用 let data = 1...3 let result = data.lazy.map { (i: Int) -> Int in print(\"准备处理(i)\") return i * 2 } print(\"准备访问结果\") for i in result { print(\"处理后的结果:(i)\") } print(\"done\") 打印结果： 准备访问结果 准备处理1 处理后的结果:2 准备处理2 处理后的结果:4 准备处理3 处理后的结果:6 done Swift反射机制Mirror “通过 Mirror 初始化得到的结果中包含的元素的描述都被集合在 children 属性下，如果你有心可以到 Swift 标准库中查找它的定义，它实际上是一个 Child 的集合，而 Child 则是一对键值的多元组： 示例1 struct Car { let logo: String var wheel: Int let door: Int } let baoM = Car(logo: \"BMW\", wheel: 4, door: 2) let mirror = Mirror(reflecting: baoM) print(\"类型:(String(describing: mirror.displayStyle))\") ///1、通过Mirror的children获取属性信息 print(\"属性个数:(mirror.children.count)\") mirror.children.map { (child) -> Any in print(\"label: (String(describing: child.label)), value: (child.value)\") } ///2、通过Refletion的dump(Any)方法获取属性信息 dump(baoM) 示例2 获取property let homeProperty = Mirror(reflecting: self) homeProperty.children.map { LOG.D(\"home property:($0)\") } iOS初始化核心原则 iOS 的初始化最核心两条的规则： • 必须至少有一个指定初始化器，在指定初始化器里保证所有非可选类型属性都得到正确的初始化（有值） • 便利初始化器必须调用其他初始化器，使得最后肯定会调用指定初始化器 在Swift中千万不要用String的count方法计算文本长度。否则当文本中有emoji时，会计算出错。应当转成NSString再去求length。 Array for-in使用 1.for in获取索引 index let array = [\"Apple\", \"Google\", \"Amazon\"] for item in array { print(\"company name is :(item)\") } ///配合array.enumerated()使用 for (index, item) in array.enumerated() { print(\"index:(index), item:(item)\") } 2.array.firstIndex(of:)获取index ///配合array.firstIndex(of:)使用 let googleIndex = array.firstIndex(of: \"Google\") print(\"googleIndex is : (googleIndex ?? 0)\") ///配合array.firstIndex(where:)使用 if let index = array.firstIndex(where: { $0.hasPrefix(\"A\") }) { print(\"array.firstIndex is (index)\") } if let item = array.first(where: { $0.hasPrefix(\"A\")}{ print(\"array.first is :(item)\") } Array.forEach()2.1forEach()和函数式编程结合使用 let array = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"] ///使用forEach array.map { Int($0)! }.forEach { num in print(num) } //不使用forEach let map = array.map { Int($0)! } map.forEach { print($0) } 2.2forEach()遍历optional集合会自动过滤nil let optionalString: [String]? = nil //使用forEach强制解包option，会过滤 optionalString?.forEach { str in print(\"str is (str)\") } ///使用for-in强制解包optional，会crash for str in optionalString! { print(\"str is (str)\") } Array index","categories":[],"tags":[]},{"title":"Swift函数式编程","slug":"Swift函数式编程","date":"2019-12-06T01:36:47.815Z","updated":"2020-03-13T20:17:46.842Z","comments":true,"path":"2019/12/06/Swift函数式编程/","link":"","permalink":"https://mingriweiji-github.github.io/2019/12/06/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"Functional Programming in Swift函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。","text":"Functional Programming in Swift函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10 在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。 不变性和副作用无论您首先学习哪种编程语言，您可能要学习的最初概念之一就是变量代表数据或状态。如果您退一步考虑一下这个想法，变量似乎很奇怪。 术语“变量”表示随程序运行而变化的数量。从数学角度考虑数量问题，您已将时间作为软件行为的关键参数。通过更改变量，可以创建可变状态。 为了进行演示，请将以下代码添加到playground： var thing = 3 //some stuff thing = 4 func superHero() { print(\"I'm batman\") thing = 5 } print(\"original state = \\(thing)\") superHero() print(\"mutated state = \\(thing)\") 神圣的神秘变化！为什么现在是5？这种变化称为副作用。函数superHero（）更改了一个甚至没有定义自己的变量。 单独或在简单系统中，可变状态不一定是问题。将许多对象连接在一起时（例如在大型的面向对象的系统中）会出现问题。可变状态会使人难以理解变量具有什么值以及该值随时间的变化而产生头痛。 例如，在为多线程系统编写代码时，如果两个或多个线程同时访问同一变量，则它们可能会无序地修改或访问它。这会导致意外的行为。这种意外行为包括竞态条件，死锁和许多其他问题。 试想一下，如果您可以编写状态永远不变的代码。并发系统中发生的所有问题都将消失。像这样工作的系统具有不变的状态，这意味着不允许状态在程序过程中进行更改。 使用不可变数据的主要好处是，使用不可变数据的代码单元没有副作用。代码中的函数不会更改其自身之外的元素，并且在发生函数调用时不会出现怪异的效果。您的程序可以正常运行，因为没有副作用，您可以轻松重现其预期的效果。 本教程从较高的层次介绍了FP，因此在实际情况下考虑这些概念会很有帮助。在这种情况下，假设您正在为游乐园构建应用程序，并且该游乐园的后端服务器通过REST API提供了行程数据。 创建Modelenum RideCategory: String { case family case kids case thrill case scary case relaxing case water } typealias Minutes = Double struct Ride { let name: String let categories: Set&lt;RideCategory> let waitTime: Minutes } Create some data using that modellet parkRides = [ Ride(name: \"R45\", categories: [.family, .thrill, .water], waitTime: 45.0), Ride(name: \"R10\", categories: [.family], waitTime: 10.0), Ride(name: \"R15\", categories: [.kids], waitTime: 15.0), Ride(name: \"R30\", categories: [.scary], waitTime: 30.0), Ride(name: \"R60\", categories: [.family, .thrill], waitTime: 60.0), Ride(name: \"R15-2\", categories: [.family, .kids], waitTime: 15.0), Ride(name: \"R25\", categories: [.family, .water], waitTime: 25.0), Ride(name: \"R0\", categories: [.family, .relaxing], waitTime: 0.0) ] FP: Filter Map ReduceMost languages that support FP will have the functions filter, map &amp; reduce. Map Map是将输入Collection中的每个Element转换为新Element。 使用map遍历一个集合，并对集合中的每个元素应用相同的操作。 map函数返回一个数组，其中包含对每个元素的映射或转换函数的结果。 Map on array:let arrayOfInt = [1,2,3,4,5] 如果我们要对每个元素乘上10呢？我们以前可能要这样 var newArr: [Int] = [] for value in arrayOfInt { newArr.append(value * 10) } print(newArr) 现在有map()后我们可以这样： let mapArr = arrayOfInt.map { $0 * 10 } print(mapArr) Working of map: The map function has a single argument which is a closure (a function) that it calls as it loops over the collection. This closure takes the element from the collection as an argument and returns a result. The map function returns these results in an array. Map on Dictionarylet book = [\"A\": 100, \"B\": 80, \"C\": 90] let mapedBook = book.map { (key, value) in key.capitalized } print(mapedBook) //[\"C\", \"B\", \"A\"] Map on Setlet lengthInmeter: Set = [1,3,5] let km = lengthInmeter.map { meter in meter * 1000 } print(km) // [1000, 5000, 3000] Map同时获取array.Index??let nums = [1,2,3,4,5] let newNums = nums.enumerated().map { (index, num) in return num * 10 } print(\"newNums:\\(newNums)\") FilterFilter函数的作用是过滤集合，返回符合条件的集合。 Filter on Arraylet filterArray = [2,4,6,1,5,7] let newFilterArray = filterArray.filter { num -> Bool in num % 2 == 0 } print(newFilterArray) Filter on Dictionarylet book = [\"A\": 100, \"B\": 80, \"C\": 90] let bookFilter = book.filter { (key, value) in value > 80 } print(bookFilter) 简化 let book = [\"A\": 100, \"B\": 80, \"C\": 90] let bookFilter = book.filter { $1 > 80 } $0是key $1是value Filter on Setlet setNums = [4.9,5.5,8.6] let newSet = setNums.filter { $0 > 5.0 } print(newSet) 重要：返回类型是数组 Reduce Use reduce to combine all items in a collection to create a single new value. 使用reduce可以合并集合中的所有元素来创建一个新的value Apple文档声明reduce() func reduce&lt;Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -> Result) rethrows -> Result reduce函数有两个参数： 第一个参数 initial value用来存储初始值或者结果（每次迭代器的结果） 第二个是带有两个参数的闭包，Result是初始值或迭代器的结果，Element是集合中的下一个元素。 Reduce on Arraylet numbers = [1,2,3,4,5,6] let sum = numbers.reduce(0) { x, y in x + y } print(sum) 简化版本：使用$0代表result let reducedSum = numbers.reduce(0) { $0 + $1 } print(reducedSum) ///等价 let reducedSum = numbers.reduce(0, +) print(reducedSum) 乘法 let produceNum = numbers.reduce(1) { x, y in x * y } print(produceNum) ///等价 let produceNum = numbers.reduce(1, *) print(produceNum) Reduce + 连接字符串let charactors = [\"abc\",\"def\",\"hijk\"] let newCharactor = charactors.reduce(\"\", +) print(newCharactor) // abcdefhijk Reduce on Dictionary let dict = [\"A\": 20, \"B\": 100] // Reduce on value let reducedNum = dict.reduce(5) { result, dic in return result + dic.value } print(\"reduc on value is \\(reducedNum)\") // reduc on value is 125 // Reduce on key let reducedName = dict.reduce(\"Charactor are \") { (result, dic) in return result + dic.key + \" \" } print(\"reduce on key is &lt;\\(reducedName)>\") //reduce on key is &lt;Charactor are A B > 简化 let reducedNameOnDic = dict.reduce(\"Charater are \") { $0 + $1.key + \" \"} Reduce on Set// Reduce on Set let lengthMeters = [3.4,1.6] let reducedMeters = lengthMeters.reduce(0.0) { $0 + $1 } print(\"reduced meters :\\(reducedMeters)\") // 5.0 FlatMapFlatmap is used to flatten a collection of collections . But before flattening the collection, we can apply map to each elements. Apple docs says: Returns an array containing the concatenated results of calling the given transformation with each element of this sequence. Flatmap用于展平集合的集合。 但是在展平集合之前，我们可以将map应用于每个集合元素。 let charaters = [\"abc\",\"def\",\"ghi\"] let newCharaters = charaters.flatMap { $0 } print(newCharaters) //[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"] let codes = [[\"abc\",\"def\",\"ghi\"], [\"jkl\",\"mno\",\"pqr\"],[\"stu\",\"vwx\",\"yz\"] ] let newCodes = codes.flatMap {$0.map { $0 } } print(newCodes) // [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\"] nillet nilArray = [2,3,nil] print(nilArray.flatMap { $0 }) // [2,3] // warning: 'flatMap' is deprecated: Please use compactMap(_:) for the case where closure returns an optional value print(nilArray.compactMap { $0 }) // [2,3]","categories":[],"tags":[]}]}