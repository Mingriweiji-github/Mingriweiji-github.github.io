<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020数据结构</title>
      <link href="/2020/03/16/2020%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/03/16/2020%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg" alt="数组和链表对比"></p><h4 id="思考题：-1-如何分别用链表和数组实现LRU缓冲淘汰策略？"><a href="#思考题：-1-如何分别用链表和数组实现LRU缓冲淘汰策略？" class="headerlink" title="思考题： 1.如何分别用链表和数组实现LRU缓冲淘汰策略？"></a>思考题： 1.如何分别用链表和数组实现LRU缓冲淘汰策略？</h4><p><strong>1）什么是缓存？</strong></p><ul><li>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。<blockquote><p>什么是C CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。</p></blockquote></li></ul><p><strong>2）为什么使用缓存？即缓存的特点</strong></p><ul><li>缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。</li></ul><p><strong>3）什么是缓存淘汰策略？</strong></p><ul><li>指的是当缓存被用满时清理数据的优先顺序。</li></ul><p><strong>4）有哪些缓存淘汰策略？</strong></p><ul><li>先进先出策略FIFO（First In，First Out）</li><li>最少使用策略LFU（Least Frenquently Used）</li><li>最近最少使用策略LRU（Least Recently Used）。</li></ul><p><strong>5）链表实现LRU缓存淘汰策略</strong></p><p>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ul><li><ol><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li></ol></li><li><ol start="2"><li>如果此数据没有在缓存链表中，又可以分为两种情况：</li></ol><ul><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ul></li></ul><p><strong>6）数组实现LRU缓存淘汰策略</strong></p><p><strong>方式一</strong></p><ul><li>首位置保存最新访问数据，末尾位置优先清理</li><li>当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；</li><li>当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。</li><li>缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。</li></ul><p><strong>方式二</strong></p><ul><li><p>首位置优先清理，末尾位置保存最新访问数据</p></li><li><p>当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前最有一个元素时间复杂度为O(1)；</p></li><li><p>当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。</p></li><li><p>缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。）</p></li></ul><h4 id="2-如何通过单链表实现“判断某个字符串是否为回文字符串”？"><a href="#2-如何通过单链表实现“判断某个字符串是否为回文字符串”？" class="headerlink" title="2.如何通过单链表实现“判断某个字符串是否为回文字符串”？"></a>2.如何通过单链表实现“判断某个字符串是否为回文字符串”？</h4><h4 id="方法一：半栈法"><a href="#方法一：半栈法" class="headerlink" title="方法一：半栈法"></a>方法一：半栈法</h4><ul><li>１．用快慢两个指针遍历，同时用栈copy慢指针指向的data。</li><li>２．完成后，慢指针指向中间节点，耗时为N/2.</li><li>３．最后用pop栈中的data和慢指针指向的data比较，耗时也是N/2.</li><li>所以时间复杂度为：Ｏ(N)，空间复杂度因栈额外存储了一半的data，故为O(N/2)</li></ul><h4 id="方法二：全栈法"><a href="#方法二：全栈法" class="headerlink" title="方法二：全栈法"></a>方法二：全栈法</h4><ul><li>1）前提：字符串以单个字符的形式存储在单链表中。</li><li>2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。</li><li>3）将链表中的字符倒序存储一份在另一个链表中。</li><li>4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是回文字串，否则，不是。</li></ul><h4 id="方法三：硬干法"><a href="#方法三：硬干法" class="headerlink" title="方法三：硬干法"></a>方法三：硬干法</h4><ul><li><ol><li>一个指针从头取data，另一个指针遍历到底取data，比较二者</li></ol></li><li>２．删除尾部节点，重复１．</li><li>时间复杂度高达　O(N^2)，空间复杂度却最低Ｏ(1)　　　</li></ul><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h2 id="1、栈和队列"><a href="#1、栈和队列" class="headerlink" title="1、栈和队列"></a>1、栈和队列</h2><h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/submissions/" target="_blank" rel="noopener">20. 有效的括号</a></h4><pre class=" language-Swift"><code class="language-Swift">func isValid(_ s: String) -> Bool {var stack: [String] = []let dic: [String: String] = [")": "(", "}": "{", "]": "["]for c in s {let key = String(c)if !dic.keys.contains(key) {stack.append(key)} else if stack.count == 0 || dic[key] != stack.removeLast() {return false}}return stack.count == 0}</code></pre><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/" target="_blank" rel="noopener">用栈实现队列</a></h4><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. <a href="https://leetcode-cn.com/problems/implement-stack-using-queues/solution/" target="_blank" rel="noopener">用队列实现栈</a></h4><h2 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、<a href="https://leetcode-cn.com/tag/linked-list/" target="_blank" rel="noopener">链表</a></h2><pre class=" language-Java"><code class="language-Java">public class ListNode {int val;ListNode next;ListNode(int x) { val = x; }}</code></pre><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="1：-删除链表中的节点"><a href="#1：-删除链表中的节点" class="headerlink" title="1： 删除链表中的节点"></a>1： <a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">删除链表中的节点</a></h4><pre class=" language-Java"><code class="language-Java">class Solution {public void deleteNode(ListNode node) {node.val = node.next.val;node.next = node.next.next;}}</code></pre><h4 id="2：反转链表"><a href="#2：反转链表" class="headerlink" title="2：反转链表"></a>2：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></h4><blockquote><p>题目描述：反转一个单链表。</p></blockquote><p>Solution1: 递归法</p><p><img src="http://q2yey8eca.bkt.clouddn.com/%E9%80%92%E5%BD%92%E7%BF%BB%E8%BD%AC.png" alt="链表翻转"></p><pre class=" language-Java"><code class="language-Java">public ListNode reverseList(ListNode head) {      if(head == null) return head;      if(head.next == null) return head;      ListNode newHead = reverseList(head.next);      head.next.next = head;      head.next = null;      return newHead;}</code></pre><p>Solotion2: 非递归-双指针（<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/）" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/）</a></p><blockquote><p> 正确示例</p></blockquote><pre class=" language-Java"><code class="language-Java">public ListNode reverseList(ListNode head) {if(head == null) return head;if(head.next == null) return head;ListNode newHead = null;while (head != null) {ListNode temp = head.next;head.next = newHead;newHead = head;head = temp;}return newHead;}</code></pre><h4 id="3：反转链表-II"><a href="#3：反转链表-II" class="headerlink" title="3：反转链表 II"></a>3：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">反转链表 II</a></h4><blockquote><p>题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p></blockquote><blockquote><p>说明:</p></blockquote><p>1 ≤ m ≤ n ≤ 链表长度。</p><h4 id="4：环形链表"><a href="#4：环形链表" class="headerlink" title="4：环形链表"></a>4：<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a></h4><blockquote><p>第一步：找到快慢指针相遇的节点，如果找不到，证明没有环，返回null</p></blockquote><p>第二步：head节出发与slow节点出发，相遇的节点为环的入口节点</p><pre class=" language-Java"><code class="language-Java">public boolean hasCycle(ListNode head) {if (head == null || head.next == null) { return false; }ListNode fast = head.next;ListNode slow = head;while (fast.next != null && fast.next.next != null) {slow = slow.next;fast = fast.next.next;if (fast == slow) {return true;}}return fast == slow;}</code></pre><h4 id="5：环形链表II-寻找环的入口节点"><a href="#5：环形链表II-寻找环的入口节点" class="headerlink" title="5：环形链表II-寻找环的入口节点"></a>5：环形链表II-寻找环的入口节点</h4><blockquote><p>问题描述：给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p></blockquote><blockquote><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p></blockquote><blockquote><p>说明：不允许修改给定的链表。</p></blockquote><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/" target="_blank" rel="noopener">官方解读Gif</a></p><p><img src="http://q2yey8eca.bkt.clouddn.com/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.gif" alt="环形链表入口"></p><h4 id="6：703-数据流中的第K大元素"><a href="#6：703-数据流中的第K大元素" class="headerlink" title="6：703. 数据流中的第K大元素"></a>6：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/solution/" target="_blank" rel="noopener">703. 数据流中的第K大元素</a></h4><pre class=" language-Java"><code class="language-Java">public class KthLargest {private PriorityQueue<Integer> queue;private int limit;public KthLargest(int k, int[] nums) {limit = k;queue = new PriorityQueue<>(k);for (int num : nums) {add(num);}}public int add(int val) {if (queue.size() < limit) {queue.add(val);} else if (val > queue.peek()) {queue.poll();queue.add(val);}return queue.peek();}}</code></pre><h2 id="3、优先队列"><a href="#3、优先队列" class="headerlink" title="3、优先队列"></a>3、优先队列</h2><ol><li><p>Heap (Binary, Binomial, Fibonacci)</p></li><li><p>Binary Search Tree</p></li></ol><p><img src="https://imgkr.cn-bj.ufileos.com/c3688989-5aaa-49cd-ba04-eb46bf8d2cbf.png" alt="Mini Heap"></p><p><img src="https://imgkr.cn-bj.ufileos.com/4e377821-42a4-4517-8179-234b3d68e0f9.png" alt="Max Heap"></p><p>Heap Wiki</p><p>• <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heap_(data_structure)</a></p><h4 id="239、滑动窗口最大值"><a href="#239、滑动窗口最大值" class="headerlink" title="239、滑动窗口最大值"></a>239、<a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a></h4><h2 id="4、哈希表-与双指针法"><a href="#4、哈希表-与双指针法" class="headerlink" title="4、哈希表 与双指针法"></a>4、哈希表 与双指针法</h2><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h4><p>1.1<a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/" target="_blank" rel="noopener">暴力循环</a></p><p><a href="https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/" target="_blank" rel="noopener">1.2一次哈希思路</a><br>标签：哈希映射</p><ul><li>这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n2)</li><li>由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度</li><li>遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值</li><li>如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止</li><li>如果最终都没有结果则抛出异常</li><li>时间复杂度：O(n)</li></ul><h4 id="15-三数之和-硅谷面试"><a href="#15-三数之和-硅谷面试" class="headerlink" title="15. 三数之和  (硅谷面试)"></a>15. <a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a>  (硅谷面试)</h4><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><blockquote><p>注意：答案中不可以包含重复的三元组。</p></blockquote><p>解题思路：</p><ul><li>1、可以三重loops循环时间复杂度是O(<em>n3</em>)</li><li>2、可以两层循环得到a+b,然后在Set集合中查找符合-(a+b)的值是否存在，时间复杂度是O(<em>n</em>2)</li><li>3、先排序 后查找：时间复杂度为O(<em>n</em>2)，先排序后得到元素a, 元素b从数组下标1开始，元素c从数组下标array.length开始，检查（a + b + c）的值：<ul><li>如果（a + b + c）&gt; 0, c–</li><li>如果 （a + b + c）&lt; 0, b++</li><li>如果（a + b + c） == 0， 得到结果</li><li>整个过程时间复杂度是O(N * N)</li></ul></li></ul><p><a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/" target="_blank" rel="noopener">解题思路3</a> </p><pre class=" language-Java"><code class="language-Java">    public static List<List<Integer>> threeSum(int[] nums) {        List<List<Integer>> ans = new ArrayList();        int len = nums.length;        if(nums == null || len < 3) return ans;        Arrays.sort(nums); // 排序        for (int i = 0; i < len ; i++) {            if(nums[i] > 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环            if(i > 0 && nums[i] == nums[i-1]) continue; // 去重            int L = i+1;            int R = len-1;            while(L < R){                int sum = nums[i] + nums[L] + nums[R];                if(sum == 0){                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));                    while (L<R && nums[L] == nums[L+1]) L++; // 去重                    while (L<R && nums[R] == nums[R-1]) R--; // 去重                    L++;                    R--;                }                else if (sum < 0) L++;                else if (sum > 0) R--;            }        }                return ans;    }作者：guanpengchn链接：https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/</code></pre><h4 id="求最小公倍数LCM"><a href="#求最小公倍数LCM" class="headerlink" title="求最小公倍数LCM"></a>求最小公倍数LCM</h4><p>GCD：最大公约数(Greatest Common Divisor)。指两个或多个整数共有约数中最大的一个。</p><p>LCM：最小公倍数(Least Common Multiple)。两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。</p><p>最小公倍数与最大公约数的关系：** </p><pre><code>LCM(A,B)×GCD(A,B)=A×B</code></pre><p>其中LCM是最小公倍数，GCD是最大公约数。</p><pre class=" language-Swift"><code class="language-Swift">//MARK:求最小公倍数 func lcm(_ a:Int,_ b:Int) -> Int {  //求最大公约数      let num:Int = gcd(a,b)  return a * b / num}</code></pre><p>所以求最小公倍数的问题可以转化为求最大公约数。</p><h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h4><h4 id="拓展：K数之和"><a href="#拓展：K数之和" class="headerlink" title="拓展：K数之和"></a>拓展：<a href="https://leetcode-cn.com/problems/4sum/solution/kshu-zhi-he-de-tong-yong-mo-ban-by-mrxiong/" target="_blank" rel="noopener">K数之和</a></h4><h4 id="242、有效的字母异位词"><a href="#242、有效的字母异位词" class="headerlink" title="242、有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242、有效的字母异位词</a></h4><h2 id="5、二叉树"><a href="#5、二叉树" class="headerlink" title="5、二叉树"></a>5、二叉树</h2><h3 id="10道常见题目"><a href="#10道常见题目" class="headerlink" title="10道常见题目"></a>10道常见题目</h3><ul><li><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历：（递归+迭代）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历：（递归+迭代）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历：（递归+迭代）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层次遍历：（迭代）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">二叉树的层次遍历II</a></p></li><li><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度：（递归+迭代）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noopener">二叉树最大宽度</a></p></li><li><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></p></li><li><p><a href="https://leetcode-cn.com/problems/invert-binary-tree" target="_blank" rel="noopener">翻转一颗二叉树</a></p></li></ul><ul><li><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">从中序与后序遍历序列构造二叉树</a></p></li><li><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序与中序遍历序列构造二叉树</a></p></li><li><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" target="_blank" rel="noopener">从前序和后序遍历构造二叉树</a></p></li><li><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表:  （迭代+递归 )</a></p></li><li><p>思考：已知前序、中序遍历结果求后序遍历</p></li><li><p>思考：已知中序、后序遍历结果求前序遍历</p></li><li><p><a href="https://juejin.im/post/5c46b19ee51d45653e3c9ae3#heading-13" target="_blank" rel="noopener">Objective-C版本</a></p></li></ul><h2 id="DFS与BFS概念"><a href="#DFS与BFS概念" class="headerlink" title="DFS与BFS概念"></a>DFS与BFS概念</h2><ul><li><p>DFS 深度优先搜索：以深度为优先级，从根节点开始一直到达叶子结点，再返回根到达另一个分支。可以细分为先序遍历，中序遍历和后序遍历。</p></li><li><p>BFS 广度优先搜索：按照高度顺序一层一层地访问，高层的结点会比低层的结点先被访问到。相当于层次遍历。</p></li></ul><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><h4 id="1、前序遍历"><a href="#1、前序遍历" class="headerlink" title="1、前序遍历"></a>1、前序遍历</h4><p>前序遍历递归法：左子树-根节点-右子树</p><pre class=" language-Swift"><code class="language-Swift">func preorderTraversal(_ root: TreeNode?) -> [Int] {    guard let root = root else { return[]}    var res: [Int] = []    res.append(root.val)    res += preorderTraversal(root.left)    res += preorderTraversal(root.right)    return res}</code></pre><h4 id="2、中序遍历"><a href="#2、中序遍历" class="headerlink" title="2、中序遍历"></a>2、中序遍历</h4><p>中序遍历递归法：左子树-根节点-右子树</p><pre class=" language-Swift"><code class="language-Swift">func inorderTraversal(_ root: TreeNode?) -> [Int] {        guard let root = root else  {             return []        }        var res: [Int] = []        res += inorderTraversal(root.left)        res.append(root.val)        res += inorderTraversal(root.right)        return res}</code></pre><h4 id="3、后序遍历"><a href="#3、后序遍历" class="headerlink" title="3、后序遍历"></a>3、后序遍历</h4><p>后序遍历递归法：左子树-右子树-根节点</p><pre class=" language-Swift"><code class="language-Swift">func postorderTraversal(_ root: TreeNode?) -> [Int] {    guard let root = root else { return [] }    var result: [Int] = []    if let left = root.left {        result += postorderTraversal(left)    }    if let right = root.right {        result += postorderTraversal(right)    }    result.append(root.val)    return result}</code></pre><h4 id="4-1、二叉树的层次遍历"><a href="#4-1、二叉树的层次遍历" class="headerlink" title="4.1、二叉树的层次遍历"></a>4.1、<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层次遍历</a></h4><p><img src="https://img-blog.csdn.net/20180226001828381" alt="该图是借用的网上的，侵权删"></p><p>图片来自网络，侵权删</p><p>实现思路：使用队列<br>1.将根节点入队<br>2.循环执行以下操作，直到队列为空</p><blockquote><ul><li>将队头节点A出队，进行访问</li><li>将A的左子节点入队</li><li>将A的右子节点入队</li></ul></blockquote><pre class=" language-Swift"><code class="language-Swift">func levelOrder(_ root: TreeNode?) -> [[Int]] {      guard let root = root else { return []}      var result: [[Int]] = []      var queue: [TreeNode] = []      queue.append(root)      while !queue.isEmpty {          //创建存储当前level的数组          var level: [Int] = []          for _ in 0..<queue.count {              //remove队列头结点，并且把该头结点的left和right加入到队列中，循环到队列为空              let node = queue.removeFirst()              level.append(node.val)              if let left = node.left { queue.append(left) }              if let right = node.right { queue.append(right)}          }          result.append(level)      }      return result}</code></pre><h4 id="4-2、二叉树的层次遍历-II"><a href="#4-2、二叉树的层次遍历-II" class="headerlink" title="4.2、二叉树的层次遍历 II"></a>4.2、<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">二叉树的层次遍历 II</a></h4><p>从下到上依次返回每一层的结果，解决方案依然是使用队列的先进先出，node入队列的通知，node的左子树、右子树依次入队列，然后用一个temp数组来保存每一层的数值，插入到结果results数组下标位置为0的位置。</p><p>代码如下：</p><pre class=" language-Swift"><code class="language-Swift">func levelOrderBottom(_ root: TreeNode?) -> [[Int]] {    guard let root = root else { return [] }    var results: [[Int]] = []    var queue: [TreeNode] = [root]    while !queue.isEmpty {        var levelItems: [Int] = []        for _ in 0..<queue.count {            let node = queue.removeFirst()            levelItems.append(node.val)            if let left = node.left { queue.append(left) }            if let right = node.right { queue.append(right) }        }        results.insert(levelItems, at: 0)    }    return results}</code></pre><p><strong>自底向上返回层次遍历的值与普通的层次遍历的唯一区别在于每一层的结果levelItems是插入到数组下标为0的位置上，利用swift中数组插入方法insert(levelItems,at: 0)即可。</strong></p><h4 id="4-2、迭代法解决前中后序"><a href="#4-2、迭代法解决前中后序" class="headerlink" title="4.2、迭代法解决前中后序"></a>4.2、迭代法解决前中后序</h4><p><strong>递归和非递归的区别，无非是一个人为保存现场，一个代码底层自动保存现场。</strong></p><h4 id="前序遍历迭代法"><a href="#前序遍历迭代法" class="headerlink" title="前序遍历迭代法"></a>前序遍历迭代法</h4><ul><li>利用栈实现<br>1.将root入栈<br>2.循环执行以下操作，直到栈为空<ul><li>弹出栈顶节点top，进行访问</li><li>将top.right入栈</li><li>将top.left入栈</li></ul></li></ul><h4 id="中序遍历迭代法"><a href="#中序遍历迭代法" class="headerlink" title="中序遍历迭代法"></a>中序遍历迭代法</h4><p>利用栈实现<br>1.设置node=root<br>2.循环执行以下操作<br>✓如果node!=null<br>✓将node入栈<br>✓设置node=node.left<br>✓如果node==null<br>✓如果栈为空，结束遍历<br>✓如果栈不为空，弹出栈顶元素并赋值给node</p><p>​     ➢对node进行访问<br>​    ➢设置node=node.right</p><h4 id="后序遍历迭代法"><a href="#后序遍历迭代法" class="headerlink" title="后序遍历迭代法"></a>后序遍历迭代法</h4><p>◼利用栈实现<br>1.将root入栈<br>2.循环执行以下操作，直到栈为空</p><ul><li><p>如果栈顶节点是叶子节点或者上一次访问的节点是栈顶节点的子节点</p><p>✓弹出栈顶节点，进行访问</p><p>否则<br>✓将栈顶节点的right、left按顺序入栈</p></li></ul><hr><h4 id="5、-二叉树的最大深度"><a href="#5、-二叉树的最大深度" class="headerlink" title="5、 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">5、 二叉树的最大深度</a></h4><p>首先要明白什么是最大深度：二叉树最大深度是指根节点到最远的叶子节点最长路径上的节点数目</p><p>解法一：要求二叉树的最大深度按照递归思想也就是求max(leftHeight, rightHeight) + 1</p><pre class=" language-Swift"><code class="language-Swift">//1、递归法：max(leftHeight, rightHeight) + 1func maxDepth(_ root: TreeNode?) -> Int {    if let root = root {        var leftHeight = 0, rightHeight = 0        if let left = root.left { leftHeight = maxDepth(left) }        if let right = root.right { rightHeight = maxDepth(right) }        return max(leftHeight, rightHeight) + 1    }    return 0}</code></pre><p>解放二：使用队列，分层遍历DFS，记录层数即可</p><pre class=" language-Swift"><code class="language-Swift">  //2、利用队列-和分层遍历类似  //只不过分层遍历是头结点出队列时，将头队列的值保存起来，这里求最大深度是depth += 1  func maxDepth(_ root: TreeNode?) -> Int {  guard let root = root else { return 0 }  var depth = 0  var queue: [TreeNode] = [root]  while !queue.isEmpty {      depth += 1      let size = queue.count      for _ in 0..<size {          let node = queue.removeFirst()          if let left = node.left { queue.append(left) }          if let right = node.right { queue.append(right) }      }  }  return depth</code></pre><h4 id="6、-二叉树最大宽度"><a href="#6、-二叉树最大宽度" class="headerlink" title="6、 二叉树最大宽度"></a><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noopener">6、 二叉树最大宽度</a></h4><p>解题思路：求二叉树最大宽度，可以使用分层遍历</p><ul><li><p>使用队列queue来记录每一层入队的结点current</p></li><li><p>使用数组list来记录当前层所有结点的索引index </p><ul><li>将current的左节点入队列同时将其左孩子结点的索引 2 * index放到list中记录</li><li>同理current的右孩子结点right入队列queue的同时将右结点索引2 * index + 1放到list数组中记录，这样每一层的索引都被list数组记录</li></ul></li><li><p>最后用maxLen记录当前层最大深度= list.last! - list.first! + 1</p></li></ul><p>代码实现：</p><pre class=" language-Swift"><code class="language-Swift">func widthOfBinaryTree(_ root: TreeNode?) -> Int {        guard let root = root else { return 0}        var queue: [TreeNode] = [root]        var list: [Int] = [1]        var maxLen = 1        while !queue.isEmpty {            let size = queue.count            for _ in 0..<size {                let node = queue.removeFirst()                let index = list.removeFirst()                if let left = node.left {                     queue.append(left)                    list.append(2 &* index)                }                if let right = node.right {                    queue.append(right)                    list.append(2 &* index &+ 1)                }            }            if list.count >= 2 { //注意临界条件是大于等于2，因为count为1宽度也是1                maxLen = max(maxLen, list.last! &- list.first! &+ 1)            }        }    return maxLen}作者：mingriweiji-github链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/fen-ceng-bian-li-shi-yong-dui-lie-qlai-ji-lu-mei-y/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><p>代码实现：</p><pre class=" language-Swift"><code class="language-Swift">guard let root = root else { return 0 }    var queue: [(TreeNode, Int)] = []    queue.append((root, 1))    var maxLen = 1    while !queue.isEmpty {        let count = queue.count        for _ in 0 ..< count {            let curr = queue.removeFirst()             let index = curr.1            if let left = curr.0.left {                queue.append((left, index &* 2))            }            if let right = curr.0.right {                queue.append((right, index &* 2 + 1))            }        }        if !queue.isEmpty {            maxLen = max(maxLen, queue.last!.1 &- queue.first!.1 &+ 1)                        }    }    return maxLen}</code></pre><h4 id="7、-验证二叉搜索树"><a href="#7、-验证二叉搜索树" class="headerlink" title="7、 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">7、 验证二叉搜索树</a></h4><p>1、递归法</p><p>递归法解题的关键在于：<strong>maxLeft &lt; root.val &lt; minRight</strong></p><ul><li>1、临界条件:root==null </li><li>2、递归左子树，找到最大值max和根节点root.val进行比较，如果左子树的max大于等于根节点的值，返回false</li><li>3、递归右子树，找到右子树的最小值min和根节点root.val比较，如果右子树的min小于等于根节点，返回false</li></ul><pre class=" language-Java"><code class="language-Java">    public boolean helper(TreeNode root, Integer min, Integer max) {        if (root == null) return true;        if (min != null && min > root.val) return false;        if (max != null && max < root.val) return true;        return helper(root.left,min,root.val) && helper(root.right,root.val,max);    }    public boolean isValidBST(TreeNode root) {        return helper(root,null,null);    }</code></pre><p>上面的help()方法不能通过测试用例[1,1]这种重复元素的数组，判断条件错误，修改如下：</p><p>Java版本</p><pre class=" language-Java"><code class="language-Java">public boolean helper(TreeNode root, Integer min, Integer max) {        if (root == null) return true;        if (min != null && min >= root.val) return false;        if (max != null && max <= root.val) return true;        return helper(root.left,root.val,max) && helper(root.right,min,root.val);}</code></pre><p>Swift版本:注意可选项解包，和判断条件是left.max &gt;= root.val, right.min &lt;= root.val</p><pre class=" language-Swift"><code class="language-Swift">        func isValidBST(_ root: TreeNode?) -> Bool {        guard let root = root else { return true }        return helper(root,nil,nil)    }    func helper(_ root: TreeNode?, _ min: Int?, _ max: Int?) -> Bool {        guard let root = root else { return true }      //左节点需要小于根节点值        if let min = min,        min <= root.val {            return false        }      //右节点需要大于根节点        if let max = max,        max >= root.val {            return false        }        return helper(root.left, root.val,max) && helper(root.right, min, root.val)    }</code></pre><h4 id="8、对称二叉树"><a href="#8、对称二叉树" class="headerlink" title="8、对称二叉树"></a>8、<a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></h4><p>解题思路：给定一个二叉树，看它是否镜像对称关键是1、左右子树的值相等 2、左子树的left和右子树的right是镜像对称，利用递归思想容易解决。</p><p>24ms代码实现如下:</p><pre class=" language-Swift"><code class="language-Swift">  func isSymmetric(_ root: TreeNode?) -> Bool {      return isMirror(root,root)  }  func isMirror(_ p: TreeNode?, _ q: TreeNode?) -> Bool{      //注意临界条件判断，先判断p、q均为空的情况      if p == nil && q == nil {          return true      }      if p == nil || q == nil {          return false      }               return (p!.val == q!.val) && isMirror(p!.left, q!.right) && isMirror(p!.right, q!.left)  }</code></pre><p>20ms代码实现如下：</p><pre class=" language-Swift"><code class="language-Swift"> func isSymmetric(_ root: TreeNode?) -> Bool {      guard let root = root else { return true }      return isMirror(root.left, root.right)  }  func isMirror(_ p: TreeNode?, _ q: TreeNode?) -> Bool {      if p == nil, q == nil {          return true      }      if let p = p, let q = q, p.val == q.val {          return isMirror(p.left, q.right) && isMirror(p.right, q.left)      }      return false  }</code></pre><p>第二遍：</p><p>执行用时 :16 ms, 在所有 swift 提交中击败了94.96%的用户</p><p>内存消耗 :19.9 MB, 在所有 swift 提交中击败了5.00%的用户</p><pre class=" language-Swift"><code class="language-Swift">func isSymmetric(_ root: TreeNode?) -> Bool {    guard let root = root else { return true }    return isMirror(root.left, root.right)}func isMirror(_ p: TreeNode?, _ q: TreeNode?) -> Bool {    if p == nil && q == nil { return true }    if let p = p,let q = q, p.val == q.val {        return isMirror(p.left, q.right) && isMirror(p.right, q.left)    }    return false}</code></pre><h4 id="9、翻转一颗二叉树"><a href="#9、翻转一颗二叉树" class="headerlink" title="9、翻转一颗二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree" target="_blank" rel="noopener">9、翻转一颗二叉树</a></h4><p>迭代就要遍历二叉树，利用分层遍历用队列交换每个结点的左右子树。</p><p>8ms迭代法：</p><pre class=" language-Swift"><code class="language-Swift">func invertTree(_ root: TreeNode?) -> TreeNode? {        //迭代法翻转二叉树,交换每一个结点的左右子树，我们用队列储存没有交换过的左右子树的结点，拿到current结点后，交换左右结点，然后再将该节点的左右结点加入到队列中。直到队列为空截止。        guard let root = root else { return nil }        var queue: [TreeNode] = [root]        while !queue.isEmpty {            var node = queue.removeFirst()            let temp = node.left            node.left = node.right            node.right = temp            if let left = node.left { queue.append(left) }            if let right = node.right { queue.append(right) }        }        return root    }</code></pre><p>16ms递归法：</p><pre class=" language-Swift"><code class="language-Swift">func invertTree(_ root: TreeNode?) -> TreeNode? {        guard let root = root else { return nil }        let temp = root.left        root.left = root.right        root.right = temp        invertTree(root.left)        invertTree(root.right)        return root    }</code></pre><p>8ms递归法：同上面的区别是没有解包，解包耗时8ms?</p><pre class=" language-Swift"><code class="language-Swift">func invertTree(_ root: TreeNode?) -> TreeNode? {    if root == nil { return nil }    let temp = root?.left    root?.left = root?.right    root?.right = temp    invertTree(root?.left)    invertTree(root?.right)    return root}</code></pre><p>第二遍：分层遍历后不要把当前节点放入队列中，我们要的是翻转二叉树，不需要记录当前节点node</p><img src="http://q2yey8eca.bkt.clouddn.com/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png" style="zoom:60%;" /><h2 id="6、二叉树搜索树"><a href="#6、二叉树搜索树" class="headerlink" title="6、二叉树搜索树"></a>6、二叉树搜索树</h2><h3 id="10道常见题目-1"><a href="#10道常见题目-1" class="headerlink" title="10道常见题目"></a>10道常见题目</h3><ul><li><h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title=" 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener"> 验证二叉搜索树</a></h4></li><li><h4 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树中的插入操作</a></h4></li><li><h4 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树中的搜索</a></h4></li><li><h4 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">删除二叉搜索树中的节点</a></h4></li><li><h4 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">二叉搜索树的最小绝对差</a></h4></li><li><h4 id="二叉搜索树结点最小距离"><a href="#二叉搜索树结点最小距离" class="headerlink" title="二叉搜索树结点最小距离"></a><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">二叉搜索树结点最小距离</a></h4></li><li><h4 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树 *"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">将有序数组转换为二叉搜索树</a> *</h4></li><li><h4 id="二叉搜索树的范围和"><a href="#二叉搜索树的范围和" class="headerlink" title="二叉搜索树的范围和 *"></a><a href="https://leetcode-cn.com/problems/range-sum-of-bst/" target="_blank" rel="noopener">二叉搜索树的范围和</a> *</h4></li><li><h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先 *"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a> *</h4></li><li><h4 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素 **"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">二叉搜索树中第K小的元素</a> **</h4></li><li><h4 id="二叉搜索树迭代器"><a href="#二叉搜索树迭代器" class="headerlink" title="二叉搜索树迭代器 **"></a><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">二叉搜索树迭代器</a> **</h4></li><li><h4 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">恢复二叉搜索树</a></h4></li><li><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">平衡二叉树</a></h4></li></ul><h2 id="7、合并"><a href="#7、合并" class="headerlink" title="7、合并"></a>7、合并</h2><h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h4><p>递归法</p><pre class=" language-Swift"><code class="language-Swift">    func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {        if l1 == nil { return l2 }        if l2 == nil { return l1 }        if l1!.val < l2!.val {            l1?.next = mergeTwoLists(l1?.next, l2)            return l1        } else {            l2?.next = mergeTwoLists(l1, l2?.next)            return l2        }    }</code></pre><p>迭代法</p><pre class=" language-Swift"><code class="language-Swift">func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {    var l1 = l1    var l2 = l2    let head = ListNode(-1)    var cur = head    while (l1 != nil && l2 != nil) {        //cur.next 记录当前的head        if l1!.val <= l2!.val {            cur.next = l1            l1 = l1?.next        } else {            cur.next = l2            l2 = l2?.next        }        //cur后移        cur = cur.next!    }    //处理链表为空    cur.next = l1 == nil ? l2 : l1    return head.next}</code></pre><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><p><a href="https://mp.weixin.qq.com/s/0nubI8XPcUJYAaEk-Eomrg" target="_blank" rel="noopener">动画| 什么是二分搜索树？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/h_mO28pmE_uNbHA5GVmWPA" target="_blank" rel="noopener">动画| 二叉树有几种存储方式？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/tFJqwKa-adXW0kXGxldisg" target="_blank" rel="noopener">动画| 二叉树在实际生活中的应用？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/XqxOp5jXqDg6fez6GphLCA" target="_blank" rel="noopener">红黑树</a></p></li></ul><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li><p><a href="https://mp.weixin.qq.com/s/DFLD41tFVtlXVYgg2QJcsQ" target="_blank" rel="noopener">什么是递归？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/G7hlvXeW_qNDPOwnIFteug" target="_blank" rel="noopener">什么是分支？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Q0w59YQmZN7tWxSXPR1vrA" target="_blank" rel="noopener">Hash算法原理及应用</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/Rh0O3ifxOtmHocr4NNNSYw" target="_blank" rel="noopener">动画 | 什么是快速排序？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/WOpU112IcvRed078mQ8ovA" target="_blank" rel="noopener">动画：面试官问我插入排序和冒泡排序哪个更牛逼？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/-9mD9LC4OrN5dl5DQSHyNA" target="_blank" rel="noopener">动画: 快速排序 | 如何求第 K 大元素？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/nXo4A-_NX_JKmTAbbTYVRg" target="_blank" rel="noopener">动画| 什么是堆排序？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/u397yZKJzuyTuzQDCcE7mw" target="_blank" rel="noopener">动画| 什么是希尔排序</a></p></li></ul><h2 id="算法题目推荐"><a href="#算法题目推荐" class="headerlink" title="算法题目推荐"></a>算法题目推荐</h2><ul><li><a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy" target="_blank" rel="noopener">初级算法</a></li><li><a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-medium/" target="_blank" rel="noopener">中级算法</a></li><li><a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-hard/" target="_blank" rel="noopener">高级算法</a></li></ul><h1 id="0-数组"><a href="#0-数组" class="headerlink" title="0 数组"></a>0 数组</h1><pre class=" language-Swift"><code class="language-Swift">// 88 合并两个有序数组：https://leetcode-cn.com/problems/merge-sorted-array/func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {     var p1 = m - 1, p2 = n - 1     var cur = m + n - 1     while (p2 >= 0) {         if (p1 >= 0 && nums1[p1] >= nums2[p2]) {             nums1[cur] = nums1[p1]             cur -= 1; p1 -= 1         } else {             nums1[cur] = nums2[p2]             cur -= 1; p2 -= 2         }     } }</code></pre><h4 id="面试题-16-16-部分排序"><a href="#面试题-16-16-部分排序" class="headerlink" title="面试题 16.16. 部分排序"></a><a href="https://leetcode-cn.com/problems/sub-sort-lcci/" target="_blank" rel="noopener">面试题 16.16. 部分排序</a></h4><pre class=" language-Swift"><code class="language-Swift">func subSort(_ array: [Int]) -> [Int] {        //1 从左往右扫描，应该越来越大，出现比max小的，记录下来        //2 从右往左扫描，应该越来越小，出现比min小的，记录下来        //临界条件（array.count < 2）        if array.count < 2 {            return [-1, -1]        }        var max = array[0], R = -1        for i in 0..<array.count {            let v = array[i]            if v >= max {                max = v            } else {                R = i            }        }              //如果有序         if R == -1 { return [-1, -1] }        var min = array[array.count - 1], L = -1        for i in (0...(array.count - 2)).reversed() {            let v = array[i]            if v <= min {                min = v            } else {                L = i            }        }        return [L, R]    }</code></pre><pre class=" language-Swift"><code class="language-Swift">/* 75. 颜色分类 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 */func setColors(_ nums: inout [Int]) {    //1、遇到0 和 left交换，left++ cur++    //2、遇到1 cur++    //3、遇到2 和 right交换，right-- cur++  :更正交换后right--但是cur不能++，因为right的位置需要重新判断    //循环条件cur<=right    var cur = 0, left = 0, right = nums.count - 1    while cur <= right {        let curNum = nums[cur]        if curNum == 0 {            swapNum(&nums, cur, left)            cur += 1            left += 1        } else if curNum == 1 {            cur += 1        } else {            swapNum(&nums, cur, right)            //注意：遇到2和right交换值以后，right--需要重新判断cur的值，所以cur不能++            //cur += 1            right -= 1        }    }}func swapNum(_ nums: inout [Int], _ i: Int, _ j: Int) {    let temp = nums[i]    nums[i] = nums[j]    nums[j] = temp}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序问题</title>
      <link href="/2020/03/15/%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/15/%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>带着问题去学习，是最有效的学习方法。所以按照惯例，我还是先给你出一个思考题：</p><h3 id="为什么插入排序比冒泡排序更受欢迎？"><a href="#为什么插入排序比冒泡排序更受欢迎？" class="headerlink" title="为什么插入排序比冒泡排序更受欢迎？"></a>为什么插入排序比冒泡排序更受欢迎？</h3><h2 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h2><hr><ul><li><p>最好情况、最坏情况、平均情况时间复杂度</p></li><li><p>时间复杂度的系数、常数、低阶</p></li><li><p>比较次数和交换次数</p></li></ul><h3 id="2、内存消耗"><a href="#2、内存消耗" class="headerlink" title="2、内存消耗"></a>2、内存消耗</h3><hr><p>原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。(冒泡排序、插入排序)</p><h3 id="3、稳定性"><a href="#3、稳定性" class="headerlink" title="3、稳定性"></a>3、稳定性</h3><ul><li>经过某种排序算法排序之后，如果两个相同数值的前后顺序没有改变，那我们就把这种排序算法叫作<strong>稳定的排序算法</strong>；</li><li>如果前后顺序发生变化，那对应的排序算法就叫作不稳定的<strong>排序算法</strong>。</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul><li>冒泡排序只会操作相邻元素的两个数据</li><li>每次都是对相邻的两个元素比较大小，前面的元素大于后面的元素，交换前后元素，一轮循环后最后元素就是最大元素</li><li>第二轮循环后，倒数第二个元素就是第二大元素</li><li>直到所有元素都是有序的停止排序</li></ul><p><strong>冒泡排序图示：</strong><br><img src="https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg" alt=""></p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">/// 冒泡排序</span><span class="token keyword">func</span> bubbleSort<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> array<span class="token punctuation">:</span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token keyword">where</span> T<span class="token punctuation">:</span> <span class="token builtin">Comparable</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> array <span class="token operator">=</span> array    <span class="token keyword">guard</span> array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> array    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//提前退出标志</span>        <span class="token keyword">var</span> flag<span class="token punctuation">:</span> <span class="token builtin">Bool</span> <span class="token operator">=</span> <span class="token boolean">false</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>                array<span class="token punctuation">.</span><span class="token function">swapAt</span><span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//有数据交换</span>                flag <span class="token operator">=</span> <span class="token boolean">true</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//没有数据交换-提前退出</span>        <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> array<span class="token punctuation">}</span></code></pre><p>现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。</p><h4 id="第一，冒泡排序是原地排序算法吗？"><a href="#第一，冒泡排序是原地排序算法吗？" class="headerlink" title="第一，冒泡排序是原地排序算法吗？"></a>第一，冒泡排序是原地排序算法吗？</h4><p><strong>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</strong></p><h4 id="第二，冒泡排序是稳定的排序算法吗？"><a href="#第二，冒泡排序是稳定的排序算法吗？" class="headerlink" title="第二，冒泡排序是稳定的排序算法吗？"></a>第二，冒泡排序是稳定的排序算法吗？</h4><p><strong>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</strong></p><h4 id="第三，冒泡排序的时间复杂度是多少？"><a href="#第三，冒泡排序的时间复杂度是多少？" class="headerlink" title="第三，冒泡排序的时间复杂度是多少？"></a>第三，冒泡排序的时间复杂度是多少？</h4><p><strong>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。平均时间复杂度也是O(n2)</strong></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul><li>插入排序是将数组分成两个部分，已排序和未排序</li><li>初始化已排序部分只有一个元素就是数组第一个元素</li><li><strong>插入排序的核心思想就是取出未排序部分的元素，在已排序区间中找到合适的插入位置插入，保证已排序区间的数据一直是有序的。</strong></li></ul><h4 id="插入排序如下图："><a href="#插入排序如下图：" class="headerlink" title="插入排序如下图："></a>插入排序如下图：</h4><p><img src="https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg" alt=""></p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">///插入排序</span><span class="token keyword">func</span> insertSort<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> elements<span class="token punctuation">:</span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token keyword">where</span> T<span class="token punctuation">:</span> <span class="token builtin">Comparable</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> array <span class="token operator">=</span> elements    <span class="token keyword">guard</span> array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> array    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> value <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">var</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true">//查找要插入的位置</span>        <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> array<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">></span> value <span class="token punctuation">{</span>                array<span class="token punctuation">[</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token comment" spellcheck="true">//移动数据</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token comment" spellcheck="true">// 插入数据</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> array<span class="token punctuation">}</span></code></pre><blockquote><p>插入排序也包含两种操作，一种是<strong>元素的比较</strong>，一种是<strong>元素的移动</strong>。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p></blockquote><blockquote><p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，<strong>移动操作的次数总是固定的，就等于逆序度 = 满有序度-初始有序度</strong>。</p></blockquote><p>现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。</p><h4 id="第一，插入排序是原地排序算法吗？"><a href="#第一，插入排序是原地排序算法吗？" class="headerlink" title="第一，插入排序是原地排序算法吗？"></a>第一，插入排序是原地排序算法吗？</h4><p><strong>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。</strong></p><h4 id="第二，插入排序是稳定的排序算法吗？"><a href="#第二，插入排序是稳定的排序算法吗？" class="headerlink" title="第二，插入排序是稳定的排序算法吗？"></a>第二，插入排序是稳定的排序算法吗？</h4><p><strong>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</strong></p><h4 id="第三，插入排序的时间复杂度是多少？"><a href="#第三，插入排序的时间复杂度是多少？" class="headerlink" title="第三，插入排序的时间复杂度是多少？"></a>第三，插入排序的时间复杂度是多少？</h4><ul><li>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。</li><li>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。</li><li>还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n2)。</li></ul><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p><img src="https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg" alt=""></p><h4 id="第一，选择排序是原地排序算法吗？"><a href="#第一，选择排序是原地排序算法吗？" class="headerlink" title="第一，选择排序是原地排序算法吗？"></a>第一，选择排序是原地排序算法吗？</h4><p>选择排序的时间复杂度是O(1)所以是原地排序</p><h4 id="第二，选择排序是稳定的排序算法吗？"><a href="#第二，选择排序是稳定的排序算法吗？" class="headerlink" title="第二，选择排序是稳定的排序算法吗？"></a>第二，选择排序是稳定的排序算法吗？</h4><p><strong>不是稳定排序，对于选择排序来说每次都是从未排序序列中找到最小的插入到已排序序列的末尾处，和前面的元素交换，这样会破坏稳定性</strong></p><blockquote><p>比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。\</p></blockquote><h4 id="第三，选择排序的时间复杂度是多少？"><a href="#第三，选择排序的时间复杂度是多少？" class="headerlink" title="第三，选择排序的时间复杂度是多少？"></a>第三，选择排序的时间复杂度是多少？</h4><p><strong>选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。</strong></p><h2 id="总结三种时间复杂度是-O-n2-的排序算法"><a href="#总结三种时间复杂度是-O-n2-的排序算法" class="headerlink" title="总结三种时间复杂度是 O(n2) 的排序算法"></a>总结三种时间复杂度是 O(n2) 的排序算法</h2><blockquote><p>这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高，所以我们更倾向于用下一节要讲的时间复杂度为 O(nlogn) 的排序算法。</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg" alt=""></h2><h4 id="思考一个问题：如何在-O-n-的时间复杂度内查找一个无序数组中的第-K-大元素？"><a href="#思考一个问题：如何在-O-n-的时间复杂度内查找一个无序数组中的第-K-大元素？" class="headerlink" title="思考一个问题：如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？"></a>思考一个问题：如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？</h4><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反转问题</title>
      <link href="/2020/03/15/%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/15/%E5%8F%8D%E8%BD%AC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><blockquote><p>原地反转字符串是否代表了空间复杂度为常数？<br>不，原地反转字符串是一种不使用辅助数据结构的算法。</p></blockquote><blockquote><p>我们使用递归的方法去反转字符串，它是原地反转，但是空间复杂度却不是常数级空间，因为递归过程中使用了堆栈空间。</p></blockquote><h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><ul><li><p>我们实现递归函数 helper，它接受两个参数：left 左指针和 right 右指针。</p></li><li><p>如果 left&gt;=right，不做任何操作。</p></li><li><p>否则交换 s[left] 和 s[right] 和调用 helper(left + 1, right - 1)。</p></li><li><p>首次调用函数我们传递首尾指针反转整个字符串 return helper(0, len(s) - 1)。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> tmp <span class="token operator">=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>  s<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>  s<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token function">helper</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverseString</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">helper</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度：\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。</strong></p><p><strong>空间复杂度：\mathcal{O}(N)O(N)，递归过程中使用的堆栈空间。</strong></p><h3 id="方法二：双指针法"><a href="#方法二：双指针法" class="headerlink" title="方法二：双指针法"></a>方法二：双指针法</h3><p><strong>双指针法是使用两个指针，一个左指针 left，右指针 right，开始工作时 left 指向首元素，right 指向尾元素。交换两个指针指向的元素，并向中间移动，直到两个指针相遇。</strong></p><h4 id="算法过程-1"><a href="#算法过程-1" class="headerlink" title="算法过程"></a>算法过程</h4><ul><li>将 left 指向首元素，right 指向尾元素。</li><li>当 left&lt;right：</li><li>交换 s[left] 和 s[right]。</li><li>left++</li><li>right++</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// 双指针</span><span class="token keyword">func</span> <span class="token function">reverseStr</span><span class="token punctuation">(</span><span class="token number">_</span> s<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token punctuation">[</span><span class="token builtin">Character</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Character</span><span class="token punctuation">]</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> <span class="token keyword">left</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">right</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> <span class="token keyword">left</span> <span class="token operator">&lt;</span> <span class="token keyword">right</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token keyword">left</span><span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span><span class="token keyword">right</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token keyword">right</span><span class="token punctuation">]</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span><span class="token keyword">left</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">left</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">right</span> <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">}</span></code></pre><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">"123456abcdef"</span><span class="token keyword">var</span> characters <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>characters<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//["1", "2", "3", "4", "5", "6", "a", "b", "c", "d", "e", "f"]</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">reverseStr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>characters<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//["f", "e", "d", "c", "b", "a", "6", "5", "4", "3", "2", "1"]</span></code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间复杂度：\mathcal{O}(N)O(N)。执行了 N/2N/2 次的交换。</strong><br><strong>空间复杂度：\mathcal{O}(1)O(1)，只使用了常数级空间。</strong></p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><ul><li>定义两个指针pre cur : pre在前 cur 在后</li><li>如果cur节点不为空，设置pre.next = cur 实现一次翻转</li><li>翻转后pre 、cur同步向前一步</li><li>当pre为空终止循环</li></ul><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token number">_</span> head<span class="token punctuation">:</span> <span class="token builtin">ListNode</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">ListNode</span><span class="token operator">?</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> head <span class="token operator">==</span> <span class="token constant">nil</span> <span class="token operator">||</span> head<span class="token operator">?</span><span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token constant">nil</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> head <span class="token punctuation">}</span>    <span class="token keyword">var</span> pre <span class="token operator">=</span> head<span class="token punctuation">,</span> cur<span class="token punctuation">:</span> <span class="token builtin">ListNode</span><span class="token operator">?</span>    <span class="token keyword">while</span> pre <span class="token operator">!=</span> <span class="token constant">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> temp <span class="token operator">=</span> pre<span class="token operator">?</span><span class="token punctuation">.</span>next        pre<span class="token operator">?</span><span class="token punctuation">.</span>next <span class="token operator">=</span> cur        cur <span class="token operator">=</span> pre<span class="token operator">!</span>        pre <span class="token operator">=</span> temp    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cur<span class="token punctuation">}</span></code></pre><pre class=" language-swift"><code class="language-swift"> 递归法核心：<span class="token function">reversList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">reverseList2</span><span class="token punctuation">(</span><span class="token number">_</span> head<span class="token punctuation">:</span> <span class="token builtin">ListNode</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">ListNode</span><span class="token operator">?</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> head <span class="token operator">==</span> <span class="token constant">nil</span> <span class="token operator">||</span> head<span class="token operator">?</span><span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token constant">nil</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token constant">nil</span> <span class="token punctuation">}</span>    <span class="token keyword">let</span> newHead <span class="token operator">=</span> <span class="token function">reverseList2</span><span class="token punctuation">(</span>head<span class="token operator">?</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span>    head<span class="token operator">?</span><span class="token punctuation">.</span>next<span class="token operator">?</span><span class="token punctuation">.</span>next <span class="token operator">=</span> head    head<span class="token operator">?</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">nil</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">}</span></code></pre><h2 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h2><h4 id="题目描述：反转从位置-m-到-n-的链表。请使用一趟扫描完成反转。说明-1-≤-m-≤-n-≤-链表长度"><a href="#题目描述：反转从位置-m-到-n-的链表。请使用一趟扫描完成反转。说明-1-≤-m-≤-n-≤-链表长度" class="headerlink" title="题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明:1 ≤ m ≤ n ≤ 链表长度"></a>题目描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明:1 ≤ m ≤ n ≤ 链表长度</h4><ul><li>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</li><li>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL<h4 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h4></li></ul><p>第一步：找到待反转节点的前一个节点。<br>第二步：反转m到n这部分。<br>第三步：将反转的起点的next指向反转的后面一部分。<br>第四步：将第一步找到的节点指向反转以后的头节点。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode node <span class="token operator">=</span> res<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找到需要反转的那一段的上一个节点。</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//node.next就是需要反转的这段的起点。</span>        ListNode nextHead <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        ListNode next <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//反转m到n这一段</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            next <span class="token operator">=</span> nextHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            nextHead<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> nextHead<span class="token punctuation">;</span>            nextHead <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//将反转的起点的next指向next。</span>        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//需要反转的那一段的上一个节点的next节点指向反转后链表的头结点</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>智力题</title>
      <link href="/2020/03/15/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
      <url>/2020/03/15/%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h1><h2 id="1、有两个水桶，-一个装-3L-的水，-一个可装-5L-的水，-问-如何利用这两个桶，-量出-4L-的水来？"><a href="#1、有两个水桶，-一个装-3L-的水，-一个可装-5L-的水，-问-如何利用这两个桶，-量出-4L-的水来？" class="headerlink" title="1、有两个水桶， 一个装 3L 的水， 一个可装 5L 的水， 问:如何利用这两个桶， 量出 4L 的水来？"></a>1、有两个水桶， 一个装 3L 的水， 一个可装 5L 的水， 问:如何利用这两个桶， 量出 4L 的水来？</h2><p>解法一加法：操作两次3L的桶，得到1L的水，然后倒入5L的桶里面，此时5L桶里有1L的水，再次用3L的桶倒入5L桶，1L+ 3L = 4L,一共操作3次3L桶</p><p><strong>加法解法图示：</strong><br><img src="https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/plus.jpg" alt=""></p><p>解法二减法：5L满水的桶倒入3L的桶，剩余2L，5L桶剩余的2L再次倒入3L桶，此时3L桶还有1L集满，5L桶再次装满后倒出来1L给3L桶里面，5L - 1L = 4L,连续操作3次5L桶</p><p><strong>减法解法图示：</strong><br><img src="https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/%E5%87%8F%E6%B3%95.jpg" alt=""></p><h2 id="2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？"><a href="#2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？" class="headerlink" title="2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？"></a>2、100个瓶子，里面有1瓶毒药，只有7只老鼠，老鼠吃了之后一星期会死亡，怎么测试？</h2><p><strong>首先2的6次方64，2的7次方128 &gt; 100<br>因此我们可以用7个的二进制给100个瓶子编号，7只老鼠分别对应7个二进制位，如果瓶子编号出现1，老鼠喝下瓶子中的毒药，最后统计出被毒死老鼠的二进制数，转换为10进制就是有毒瓶子的编号。</strong></p><p><strong>解法图示：</strong></p><p><img src="https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/%E8%80%81%E9%BC%A0%E9%97%AE%E9%A2%98.JPG" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Runloop</title>
      <link href="/2020/03/11/Runloop/"/>
      <url>/2020/03/11/Runloop/</url>
      
        <content type="html"><![CDATA[<h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><h2 id="1-讲讲-RunLoop，项目中有用到吗？"><a href="#1-讲讲-RunLoop，项目中有用到吗？" class="headerlink" title="1.讲讲 RunLoop，项目中有用到吗？"></a>1.讲讲 RunLoop，项目中有用到吗？</h2><ul><li>事件循环，在程序运行中循环做一些事情</li><li>没有消息mach_msg()切换用户态到内核态线程休眠，有消息内核态切换到用户态</li></ul><h3 id="runloop相关："><a href="#runloop相关：" class="headerlink" title="runloop相关："></a>runloop相关：</h3><ul><li>Timer、performSelector</li><li>GCD、AutoreleasePool</li><li>事件响应、收拾识别、网络请求</li></ul><h3 id="runloop的应用："><a href="#runloop的应用：" class="headerlink" title="runloop的应用："></a>runloop的应用：</h3><ul><li>线程包活</li><li>解决timer滑动停止问题</li><li>监听主线程卡顿</li><li>性能优化</li></ul><h2 id="2-runloop的6种状态和runloop内部实现逻辑？"><a href="#2-runloop的6种状态和runloop内部实现逻辑？" class="headerlink" title="2.runloop的6种状态和runloop内部实现逻辑？"></a>2.runloop的6种状态和runloop内部实现逻辑？</h2><pre><code>/* Run Loop Observer Activities */typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {    kCFRunLoopEntry = (1UL &lt;&lt; 0),           // 即将进入Loop    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),    //即将处理Timer    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),   //即将处理Source    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),   //即将进入休眠    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),    //刚从休眠中唤醒    kCFRunLoopExit = (1UL &lt;&lt; 7),            //即将退出Loop    kCFRunLoopAllActivities = 0x0FFFFFFFU};</code></pre><ul><li><strong>source0 : 触摸事件、performSelectorOnThread:</strong></li><li><strong>source1: 基于Port的线程间通讯，捕获到的系统事件</strong></li><li><strong>timers: NSTimer + performSelector:afterDelay:</strong></li><li><strong>observers: 监听runloop的状态/autoreleasePool的创建和释放、UI的刷新</strong></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/3/5/170a9f4968fe6f59?w=1012&h=858&f=png&s=146946" alt="img"></p><h2 id="3-runloop和线程的关系？"><a href="#3-runloop和线程的关系？" class="headerlink" title="3.runloop和线程的关系？"></a>3.runloop和线程的关系？</h2><ul><li>一一对应</li><li>保存在一个全局字典中，线程是key, runloop是value</li><li>子线程默认没有runloop，在第一次获取runloop时才会创建。</li><li>runloop在线程结束时销毁</li></ul><h2 id="4-timer-与-runloop-的关系？"><a href="#4-timer-与-runloop-的关系？" class="headerlink" title="4.timer 与 runloop 的关系？"></a>4.timer 与 runloop 的关系？</h2><h2 id="程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？"><a href="#程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？" class="headerlink" title="程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？"></a>程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？</h2><h2 id="5-runloop-是怎么响应用户操作的，-具体流程是什么样的？"><a href="#5-runloop-是怎么响应用户操作的，-具体流程是什么样的？" class="headerlink" title="5.runloop 是怎么响应用户操作的， 具体流程是什么样的？"></a>5.runloop 是怎么响应用户操作的， 具体流程是什么样的？</h2><h2 id="6-说说runLoop的几种状态"><a href="#6-说说runLoop的几种状态" class="headerlink" title="6.说说runLoop的几种状态"></a>6.说说runLoop的几种状态</h2><h2 id="7-runloop的mode作用是什么？"><a href="#7-runloop的mode作用是什么？" class="headerlink" title="7.runloop的mode作用是什么？"></a>7.runloop的mode作用是什么？</h2><ul><li><p>CFRunLoopModeRef代表<strong>RunLoop的运行模式</strong></p></li><li><p>一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer</p></li><li><p>RunLoop启动时只能选择其中一个Mode，作为<strong>currentMode</strong></p></li><li><p>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入</p></li><li><p><strong>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</strong></p></li><li><p><strong>如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出</strong></p></li></ul><h2 id="8-KVO实现原理-哪些情况下使用kvo会崩溃，怎么防护崩溃"><a href="#8-KVO实现原理-哪些情况下使用kvo会崩溃，怎么防护崩溃" class="headerlink" title="8.KVO实现原理?哪些情况下使用kvo会崩溃，怎么防护崩溃?"></a>8.KVO实现原理?哪些情况下使用kvo会崩溃，怎么防护崩溃?</h2><h2 id="9-如何手动关闭KVO-如何手动自己实现KVO说说思路"><a href="#9-如何手动关闭KVO-如何手动自己实现KVO说说思路" class="headerlink" title="9.如何手动关闭KVO?如何手动自己实现KVO说说思路"></a>9.如何手动关闭KVO?如何手动自己实现KVO说说思路</h2><h2 id="10-通过KVC修改属性会触发KVO么"><a href="#10-通过KVC修改属性会触发KVO么" class="headerlink" title="10.通过KVC修改属性会触发KVO么"></a>10.通过KVC修改属性会触发KVO么</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2020/03/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/03/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1、你理解的多线程？并发和串行，同步和异步"><a href="#1、你理解的多线程？并发和串行，同步和异步" class="headerlink" title="1、你理解的多线程？并发和串行，同步和异步"></a>1、<strong>你理解的多线程？并发和串行，同步和异步</strong></h2><ul><li>同步和异步的区别: 是否开辟新的线程，同步只能在当前线程执行任务，异步可以再新的线程执行任务</li><li>串行和并发的区别是任务执行的顺序，串行任务只能顺序执行，并发可以多个任务同时执行。</li></ul><h2 id="2、iOS多线程有哪些？常用哪个？"><a href="#2、iOS多线程有哪些？常用哪个？" class="headerlink" title="2、iOS多线程有哪些？常用哪个？"></a>2、iOS多线程有哪些？常用哪个？</h2><ul><li>NSThread、GCD/NSOperationQueue</li><li>常用GCD/NSOperation</li></ul><p><img src="https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/20200314043637.png" alt="pthread NSThread GCD NSoperatio"></p><h2 id="GCD-的队列类型有哪些？"><a href="#GCD-的队列类型有哪些？" class="headerlink" title="GCD 的队列类型有哪些？"></a><strong>GCD 的队列类型有哪些？</strong></h2><h2 id="OperationQueue-和-GCD-的区别？"><a href="#OperationQueue-和-GCD-的区别？" class="headerlink" title="OperationQueue 和 GCD 的区别？"></a><strong>OperationQueue 和 GCD 的区别？</strong></h2><ol><li>GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择；</li><li>在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)；</li><li>NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行；</li><li>我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样子能比GCD更加有效地掌控我们执行的后台任务；</li><li>在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码；</li><li>我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。</li></ol><p><strong>总的来说，Operation queue 提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。</strong></p><p><strong>从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。</strong></p><h2 id="如何用gcd实现以下功能？"><a href="#如何用gcd实现以下功能？" class="headerlink" title="如何用gcd实现以下功能？"></a><strong>如何用gcd实现以下功能？</strong></h2><ul><li><strong>异步并发执行任务1、任务2</strong> </li><li><strong>等任务1、任务2都执行完毕后，再回到主线程执行任务3</strong></li></ul><h2 id="线程安全是什么？如何处理线程安全的问题？"><a href="#线程安全是什么？如何处理线程安全的问题？" class="headerlink" title="线程安全是什么？如何处理线程安全的问题？"></a><strong>线程安全是什么？如何处理线程安全的问题？</strong></h2><blockquote><p>我们一般通过线程同步方案如加锁的方式来实现线程的安全</p><p><a href="https://bestswifter.com/ios-lock/" target="_blank" rel="noopener">iOS锁的原理</a> |   <a href="https://www.jianshu.com/p/e56c3d28e77d" target="_blank" rel="noopener">深入浅出iOS系统内核-同步机制</a></p></blockquote><ul><li><strong>os_unfair_lock：iOS10开始os_unfair_lock来替代OSSpinLock, 等待锁的线程会进入休眠不占用CPU资源， 这个os_unfair_lock解决了优先级翻转问题。</strong></li><li><strong>OSSpinLock: 自旋锁，线程忙等一直占用CUP资源，不安全因为可能出现优先级翻转的可能</strong></li><li><strong>dispatch_semaphore：信号量为1的semaphore也可以看做是锁</strong></li><li><strong>pthread_mutex：mutex是互斥锁，等待锁的线程处于休眠状态，pthread_mutex是递归锁，可以递归调用。</strong></li><li><strong>使用GCD的串行队列也可以实现锁的功能</strong></li><li><strong>NSLock是对metex互斥锁的封装，NSRecurisiveLock也是对metex的递归封装，API和NSLock一直。</strong></li><li>NSCondition</li><li>NSConditionLock</li><li><strong>@synchorized也是mutex的递归封装，@synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作。</strong></li></ul><h2 id="自旋锁和互斥锁如何选择？"><a href="#自旋锁和互斥锁如何选择？" class="headerlink" title="自旋锁和互斥锁如何选择？"></a><strong>自旋锁和互斥锁如何选择？</strong></h2><p><strong>自旋锁OSSpinLock：当线程获取锁，其他等待锁的线程会忙等一直占用CPU,自旋锁有优先级翻转的可能性，所以苹果已经弃用自旋锁OSSpinLock改用os_unfair_lock.</strong></p><p><strong>互斥锁mutext：阻塞线程并休眠，其他线程才能正常访问，用互斥的方式来保证线程的安全。</strong></p><p><strong>递归锁：顾名思义，可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。</strong></p><ul><li><strong>什么情况使用自旋锁比较划算？</strong> <ul><li>预计线程等待锁的时间很短 </li><li>加锁的代码（临界区）经常被调用，但竞争情况很少发生 </li><li>CPU资源不紧张 多核处理器</li></ul></li><li><strong>什么情况使用互斥锁比较划算？</strong> <ul><li>预计线程等待锁的时间较长 </li><li>单核处理器 临界区有IO操作 </li><li>临界区代码复杂或者循环量大 </li><li>临界区竞争非常激烈 </li></ul></li></ul><ul><li><strong>追问二：使用以上锁需要注意哪些？</strong> </li><li><strong>追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！</strong></li></ul><h2 id="iOS线程同步方案性能比较"><a href="#iOS线程同步方案性能比较" class="headerlink" title="iOS线程同步方案性能比较"></a>iOS线程同步方案<strong>性能</strong>比较</h2><p><strong>性能从高到低排序:</strong></p><pre><code>os_unfair_lock &gt; OSSpinLock &gt; dispatch_semaphore &gt; pthread_mutex &gt; dispatch_queue(DISPATCH_QUEUE_SERIAL) &gt; NSLock &gt; NSCondition &gt; pthread_mutex(recursive) &gt; NSRecursiveLock &gt; NSConditionLock &gt; @synchronized</code></pre><h2 id="如何实现多度单写？"><a href="#如何实现多度单写？" class="headerlink" title="如何实现多度单写？"></a><code>如何实现多度单写？</code></h2><p><strong>dispatch_barrier_async</strong></p><ul><li>这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的 </li><li>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果</li></ul><p><strong><code>pthread_rwlock</code>读写锁-等待锁的线程进入休眠</strong></p><p><img src="https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/1.png" alt="pthread_rwlock"></p><p>‌</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树前世今生</title>
      <link href="/2019/12/30/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2019/12/30/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树前世今生"><a href="#红黑树前世今生" class="headerlink" title="红黑树前世今生"></a>红黑树前世今生</h1><p>关键词：二叉搜索树、前驱节点、后继节点、B树、红黑树</p><h2 id="什么是B树"><a href="#什么是B树" class="headerlink" title="什么是B树"></a>什么是B树</h2><h3 id="前世"><a href="#前世" class="headerlink" title="前世"></a>前世</h3><p>B树是一种相对于来说特殊二叉搜索树，多用于数据库和文件搜索系统中。</p><h3 id="n阶B树的性质"><a href="#n阶B树的性质" class="headerlink" title="n阶B树的性质"></a>n阶B树的性质</h3><blockquote><p>B树是一种平衡的多路搜索树，拥有平衡二叉树的一些特性，与平衡二叉树的最大区别在于每个节点不再是只能存储一个元素，而且每个节点可以拥有多个子节点而像二叉平衡树只能拥有两个。</p></blockquote><ol><li>B树每个节点最多可以存储超过2个元素，可以拥有超过2个子节点</li><li>B树每个子节点的子树高度一致</li><li>B树和二叉搜索树一样，左子树&lt;根节点&lt;右子树</li><li>根节点元素个数:   1≤ X ≤ n - 1</li><li>非根节点元素个数:  n/2 - 1 ≤ x ≤ n - 1 (n/2 向上取整)</li><li>如果有子节点，子节点个数 y = x + 1,</li><li>根节点 2 ≤ y ≤ n<br><strong>非根节点 n / 2 ≤ y ≤ n</strong> (n/2 向上取整)</li></ol><blockquote><p>数据库中一般使用的是200-300阶B树</p><p>4阶B树元素个数为(2-3-4)，所以4阶B树也叫2-4树或者2-3-4树</p><p>5阶B树元素个数为 3-4-5 所以5阶B树叫（3，5）树</p><p>6阶B树元素个数3-4-5-6，所以6阶B树叫（3，6）树</p><p>7阶B树元素个数为4-5-6-7，所以7阶B树叫（4，7）树</p></blockquote><h3 id="B树-VS-二叉搜索树"><a href="#B树-VS-二叉搜索树" class="headerlink" title="B树 VS 二叉搜索树"></a>B树 VS 二叉搜索树</h3><ol><li>B树与二叉搜索树逻辑上等价</li><li>n阶B树最多需要log2 N代合并</li><li>多代节点合并可以获得超节点<ul><li>2代合并最多拥有4个子节点</li><li>3代合并最多拥有8个子节点</li><li>n代合并最多拥有2^n个子节点（至少是2^n阶B树）</li></ul></li></ol><h3 id="B树的添加与上溢"><a href="#B树的添加与上溢" class="headerlink" title="B树的添加与上溢"></a>B树的添加与上溢</h3><p><strong>上溢出（overflow）:添加元素到子节点后，该节点元素个数大于N时，我们称之为上溢出</strong></p><p>B树的元素添加的位置一定是叶子节点</p><p>B树添加导致上溢</p><p>B树上溢最极端的情况是一直分裂到根节点</p><h3 id="B树的删除与下溢"><a href="#B树的删除与下溢" class="headerlink" title="B树的删除与下溢"></a>B树的删除与下溢</h3><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li><p>删除叶子节点的话直接删除</p><p><img src="B%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.assets/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-15%20%E4%B8%8A%E5%8D%889.49.17.png" alt="屏幕快照 2019-12-15 上午9.49.17"></p></li><li><p>删除的非叶子节点的话：1、先找到前驱或后继节点元素，覆盖需要删除的值，2、把前驱或后继元素删除（说明：一个树的前驱在左子树的最后边，后驱在右子树的最左边。）</p></li></ul><p><img src="B%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.assets/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-15%20%E4%B8%8A%E5%8D%889.48.06.png" alt="屏幕快照 2019-12-15 上午9.48.06"></p><ul><li>非叶子节点前驱或后继元素，必然是在叶子节点中，所以真正删除的元素都是叶子节点</li></ul><p><img src="B%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.assets/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-12-15%20%E4%B8%8A%E5%8D%889.50.50.png" alt="屏幕快照 2019-12-15 上午9.50.50"></p><p><strong>下溢出（underflow）：叶子节点被删除一个元素后，元素个数可能会低于最低限制 （n/2 - 1 向上取整）</strong></p><p><strong>下溢出的解决方案是旋转</strong>，总体元素是哪个方向失衡往哪个方向转，子树大小顺序不能乱</p><h2 id="4阶B树"><a href="#4阶B树" class="headerlink" title="4阶B树"></a>4阶B树</h2><ul><li>4阶B树所有节点都能储存的元素个数x: 1 ≤ x ≤ 3</li><li>4阶B树非叶子节点的子节点个数：2 ≤ y ≤ 4</li></ul><h2 id="为什么需要红黑树"><a href="#为什么需要红黑树" class="headerlink" title="为什么需要红黑树?"></a>为什么需要红黑树?</h2><p>红黑树是在二叉搜索树的基础上对AVL树的改进，二叉搜索树顾名思义是对搜索算法的一种优化，能够大大减少我们元素对比的次数。红黑树在Java中的应用如HashSet(底层是数组单链表和红黑树)、数据库搜索也有应用。</p><h2 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h2><p><strong>红黑树是一种自平衡的二叉搜索树也叫平衡二叉B树</strong></p><h3 id="红黑树5个性质"><a href="#红黑树5个性质" class="headerlink" title="红黑树5个性质"></a>红黑树5个性质</h3><ol><li>节点分为红色与黑色</li><li>根节点是黑色</li><li>叶子节点是黑色</li><li><strong>不能有两个连续的红色节点</strong></li><li>从任意节点到叶子节点上所有路径的<strong>黑色节点数目必须相等</strong></li></ol><h3 id="红黑树等价变换"><a href="#红黑树等价变换" class="headerlink" title="红黑树等价变换"></a>红黑树等价变换</h3><p>红黑树等价于4阶B树</p><h3 id="红黑树添加失衡如何解决？"><a href="#红黑树添加失衡如何解决？" class="headerlink" title="红黑树添加失衡如何解决？"></a>红黑树添加失衡如何解决？</h3><h4 id="添加失衡"><a href="#添加失衡" class="headerlink" title="添加失衡"></a>添加失衡</h4><ul><li>Parrent节点为黑色时不需要处理</li><li>Parrent节点为红色（Double Red）</li><li>Uncle节点不是red:  <strong>LL/RR    LR/RL</strong></li><li>Uncle节点是red:  </li></ul><h3 id="红黑树删除节点失衡如何解决？"><a href="#红黑树删除节点失衡如何解决？" class="headerlink" title="红黑树删除节点失衡如何解决？"></a>红黑树删除节点失衡如何解决？</h3><h2 id="红黑树-VS-AVL树"><a href="#红黑树-VS-AVL树" class="headerlink" title="红黑树 VS AVL树"></a>红黑树 VS AVL树</h2><h3 id="搜索性能"><a href="#搜索性能" class="headerlink" title="搜索性能"></a>搜索性能</h3><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>Java8中的hashMap是使用数组+链表实现的，在解决哈希碰撞时使用了红黑树。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树前世今生</title>
      <link href="/2019/12/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2019/12/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树今生"><a href="#二叉树今生" class="headerlink" title="二叉树今生"></a>二叉树今生</h1><p>为什么会有二叉树这种数据结构？</p><p>思考一个问题：如果一个集合中有42亿个元素，让你从这42亿个元素中搜索某一个元素，你需要多少次操作？</p><p><strong>如果使用数组链表的话最多可能需要42亿次比较，而如果使用二叉树我们只需要32次比较即可，这就是二叉树存在的价值。Java中的HashSet使用的就是二叉树</strong></p><h2 id="前驱与后继"><a href="#前驱与后继" class="headerlink" title="前驱与后继"></a>前驱与后继</h2><h3 id="前驱节点"><a href="#前驱节点" class="headerlink" title="前驱节点"></a>前驱节点</h3><ol><li><p>若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode）</p></li><li><p>若一个节点没有左子树，那么判断该节点和其父节点的关系 </p><p>2.1 若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。 </p><p>2.2 若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点</p></li></ol><h3 id="后继节点"><a href="#后继节点" class="headerlink" title="后继节点"></a>后继节点</h3><ol><li>若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode）</li><li>若一个节点没有右子树，那么判断该节点和其父节点的关系<br>2.1 若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点<br>2.2 若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子（可参考例子2的前驱结点是1），那么Q就是该节点的后继节点</li></ol><p>如何判断两个二叉树是否相同？</p><p><strong>递归法</strong></p><pre class=" language-Java"><code class="language-Java">static public bool IsSameTree(TreeNode root1, TreeNode root2) {    if (root1 == null && root2 == null) {        return true;    }    if ((root1 == null && root2 != null) || (root1 != null && root2 == null)) {        return false;    }    if (root1.val != root2.val) {//判断每个节点的值是否相等，如果去除此判断，则判断两个二叉树是否结构相等        return false;    }    return IsSameTree(root1.left, root2.left) && IsSameTree(root1.right, root2.right);}</code></pre><p><strong>非递归法</strong></p><pre class=" language-Java"><code class="language-Java">bool  BTreeCompare（BTreeNode_t *pRoot1, BTreeNode_t *pRoot2)  {      if( pRoot1 == NULL && pRoot2 == NULL )          return false;      queue <BTreeNode_t *> que1;      queue <BTreeNode_t *> que2;      que1.push(pRoot1);      que2.push(pRoot2);      int curLevelNodeTotal1 = 0;      int curLevelNodeTotal2 = 0;      bool flag = true; //作为比较不一致时跳出标识      while( ( !que1.empty()) && ( !que2.empty())) //当两个队列均不为空时，才进行比较      {          curLevelNodeTotal1 = que1.size();  //获取树1的当前层节点总数          curLevelNodeTotal2 = que2.size(); //获取树2的当前层节点总数          if( curLevelNodeTotal1 != curLevelNodeTotal2){              flag = false;//当前层节点总数都不一致，不需要比较了，直接跳出              break;          }          int cnt1 = 0;//遍历本层节点时的计数器          int cnt2 = 0;          while( cnt1 < curLevelNodeTotal1  && cnt2 < curLevelNodeTotal2){              ++cnt1;              ++cnt2;              pRoot1 = que1.front();              que1.pop();              pRoot2 = que2.front();              que2.pop();              //比较当前节点中数据是否一致              if( pRoot1->m_pElemt != pRoot2->m_pElemt ){                  flag = false;                  break;              }              //判断pRoot1和pRoot2左右节点结构是否相同              if( ( pRoot1->m_pLeft != NULL && pRoot2->m_pLeft == NULL )    ||                  ( pRoot1->m_pLeft == NULL && pRoot2->m_pLeft != NULL )    ||                  ( pRoot1->m_pRight != NULL && pRoot2->m_pRight == NULL )    ||                  ( pRoot1->m_pRight == NULL && pRoot2->m_pRight != NULL )              ){                  flag = false;                  break;              }              //将左右节点入队              if( pRoot1->m_pLeft != NULL )                  que1.push( pRoot1->m_pLeft);              if( pRoot1->m_pRight != NULL )                  que1.push( pRoot1->m_pRight);              if( pRoot2->m_pLeft != NULL )                  que2.push( pRoot2->m_pLeft);              if( pRoot2->m_pRight != NULL )                  que2.push( pRoot2->m_pRight);          }          if( flag == false )              break;      }      //如果比较标志为false，则不相同      if( flag == false ){          while( !que1.empty() )              que1.pop();          while( !que2.empty())              que2.pop();          return false;      }      return true;  }</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS图像处理</title>
      <link href="/2019/12/30/iOS%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2019/12/30/iOS%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS图像优化技巧"><a href="#iOS图像优化技巧" class="headerlink" title="iOS图像优化技巧"></a><a href="https://swift.gg/2019/11/01/image-resizing/" target="_blank" rel="noopener">iOS图像优化技巧</a></h1><h4 id="iOS内存分配"><a href="#iOS内存分配" class="headerlink" title="iOS内存分配"></a><a href="https://juejin.im/post/5a5e13c45188257327399e19#heading-0" target="_blank" rel="noopener">iOS内存分配</a></h4><h4 id="图像渲染优化的时机和理由"><a href="#图像渲染优化的时机和理由" class="headerlink" title="图像渲染优化的时机和理由"></a><a href="https://swift.gg/2019/11/01/image-resizing/" target="_blank" rel="noopener">图像渲染优化的时机和理由</a></h4><p>在开始之前，让我们先讨论一下<em>为什么</em>需要对图像进行渲染优化。毕竟，<code>UIImageView</code> 会自动根据 <a href="https://developer.apple.com/documentation/uikit/uiview/1622619-contentmode" target="_blank" rel="noopener"><code>contentmode</code> 属性</a> 规定的行为缩放和裁剪图像。在绝大多数情况下，<code>.scaleAspectFit</code>、<code>.scaleAspectFill</code> 或 <code>.scaleToFill</code> 已经完全满足你的所需。</p><pre><code>imageView.contentMode = .scaleAspectFitimageView.image = image</code></pre><hr><p>那么，什么时候对图像进行渲染优化才有意义呢？</p><p><strong>当它明显大于</strong> <strong><code>UIImageView</code></strong> <strong>显示尺寸的时候</strong></p><p>想要完整渲染这张宽高为 12,000 px 的图片，需要高达 20 MB 的空间。对于当今的硬件来说，你可能不会在意这么少兆字节的占用。但那只是它压缩后的尺寸。要展示它，<code>UIImageView</code> 首先需要把 JPEG 数据解码成位图（bitmap），如果要在一个 <code>UIImageView</code> 上按原样设置这张全尺寸图片，你的应用内存占用将会激增到<strong>几百兆</strong>，对用户明显没有什么好处（毕竟，屏幕能显示的像素有限）。但只要在设置 <code>UIImageView</code> 的 <code>image</code> 属性之前，将图像渲染的尺寸调整成 <code>UIImageView</code> 的大小，你用到的内存就会少一个数量级：</p><table><thead><tr><th align="left"></th><th align="left">内存消耗 <em>(MB)</em></th></tr></thead><tbody><tr><td align="left">无下采样</td><td align="left">220.2</td></tr><tr><td align="left">下采样</td><td align="left">23.7</td></tr></tbody></table><p>这个技巧就是众所周知的<em>下采样（downsampling）</em>，在这些情况下，它可以有效地优化你应用的性能表现。如果你想了解更多关于下采样的知识或者其它图形图像的最佳实践，请参照 <a href="https://developer.apple.com/videos/play/wwdc2018/219/" target="_blank" rel="noopener">来自 WWDC 2018 的精彩课程</a>。</p><p>而现在，很少有应用程序会尝试一次性加载这么大的图像了，但是也跟我从设计师那里拿到的图片资源不会差<em>太</em>多。<em>（认真的吗？一张颜色渐变的</em> <em>PNG</em> <em>图片要</em> <em>3</em> <em>MB?）</em> 考虑到这一点，让我们来看看有什么不同的方法，可以让你用来对图像进行优化或者下采样。</p><blockquote><p>不用说，这里所有从 URL 加载的示例图像都是针对<strong>本地</strong>文件。记住，在应用的主线程同步使用网络请求图像<strong>绝不</strong>是什么好主意。</p></blockquote><hr><h2 id="图像渲染优化技巧"><a href="#图像渲染优化技巧" class="headerlink" title="图像渲染优化技巧"></a>图像渲染优化技巧</h2><p>优化图像渲染的方法有很多种，每种都有不同的功能和性能特性。我们在本文看到的这些例子，架构层次跨度上从底层的 Core Graphics、vImage、Image I/O 到上层的 Core Image 和 UIKit 都有。</p><ol><li><a href="https://swift.gg/2019/11/01/image-resizing/#technique-1-drawing-to-a-uigraphicsimagerenderer" target="_blank" rel="noopener">绘制到 UIGraphicsImageRenderer 上</a></li><li><a href="https://swift.gg/2019/11/01/image-resizing/#technique-2-drawing-to-a-core-graphics-context" target="_blank" rel="noopener">绘制到 Core Graphics Context 上</a></li><li><a href="https://swift.gg/2019/11/01/image-resizing/#technique-3-creating-a-thumbnail-with-image-io" target="_blank" rel="noopener">使用 Image I/O 创建缩略图像</a></li><li><a href="https://swift.gg/2019/11/01/image-resizing/#technique-4-lanczos-resampling-with-core-image" target="_blank" rel="noopener">使用 Core Image 进行 Lanczos 重采样</a></li><li><a href="https://swift.gg/2019/11/01/image-resizing/#technique-5-image-scaling-with-vimage" target="_blank" rel="noopener">使用 vImage 优化图片渲染</a></li></ol><p>下面的这些数字是多次迭代加载、优化、渲染之前那张 <a href="https://visibleearth.nasa.gov/view.php?id=78314" target="_blank" rel="noopener">超大地球图片</a> 的平均时间：</p><table><thead><tr><th align="left"></th><th align="left">耗时 <em>(seconds)</em></th></tr></thead><tbody><tr><td align="left">技巧 #1: <code>UIKit</code></td><td align="left">0.1420</td></tr><tr><td align="left">技巧 #2: <code>Core Graphics</code> 1</td><td align="left">0.1722</td></tr><tr><td align="left">技巧 #3: <code>Image I/O</code></td><td align="left">0.1616</td></tr><tr><td align="left">技巧 #4: <code>Core Image</code> 2</td><td align="left">2.4983</td></tr><tr><td align="left">技巧 #5: <code>vImage</code></td><td align="left">2.3126</td></tr></tbody></table><p>1<br>设置不同的 <code>CGInterpolationQuality</code> 值出来的结果是一致的，在性能上的差异可以忽略不计。</p><p>2<br>若在 <code>CIContext</code> 创建时设置 <code>kCIContextUseSoftwareRenderer</code> 的值为 <code>true</code>，会导致耗时相比基础结果慢一个数量级。</p><h3 id="技巧-1-绘制到-UIGraphicsImageRenderer-上"><a href="#技巧-1-绘制到-UIGraphicsImageRenderer-上" class="headerlink" title="技巧 #1: 绘制到 UIGraphicsImageRenderer 上"></a>技巧 #1: 绘制到 UIGraphicsImageRenderer 上</h3><p>图像渲染优化的最上层 API 位于 UIKit 框架中。给定一个 <code>UIImage</code>，你可以绘制到 <code>UIGraphicsImageRenderer</code> 的上下文（context）中以渲染缩小版本的图像：</p><pre><code>import UIKit// 技巧 #1func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? {    guard let image = UIImage(contentsOfFile: url.path) else {        return nil    }    let renderer = UIGraphicsImageRenderer(size: size)    return renderer.image { (context) in        image.draw(in: CGRect(origin: .zero, size: size))    }}</code></pre><p><a href="https://developer.apple.com/documentation/uikit/uigraphicsimagerenderer" target="_blank" rel="noopener"><code>UIGraphicsImageRenderer</code></a> 是一项相对较新的技术，在 iOS 10 中被引入，用以取代旧版本的 <code>UIGraphicsBeginImageContextWithOptions</code> / <code>UIGraphicsEndImageContext</code> API。你通过指定以 <code>point</code> 计量的 <code>size</code> 创建了一个 <code>UIGraphicsImageRenderer</code>。<code>image</code> 方法带有一个闭包参数，返回的是一个经过闭包处理后的位图。最终，原始图像便会在缩小到指定的范围内绘制。</p><h3 id="技巧-2：绘制到-Core-Graphics-Context-中"><a href="#技巧-2：绘制到-Core-Graphics-Context-中" class="headerlink" title="技巧 #2：绘制到 Core Graphics Context 中"></a>技巧 #2：绘制到 Core Graphics Context 中</h3><p>Core Graphics / Quartz 2D 提供了一系列底层 API 让我们可以进行更多高级的配置。</p><p>给定一个 <code>CGImage</code> 作为暂时的位图上下文，使用 <code>draw(_:in:)</code> 方法来绘制缩放后的图像：</p><pre><code>import UIKitimport CoreGraphics// 技巧 #2func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? {    guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),        let image = CGImageSourceCreateImageAtIndex(imageSource, 0, nil)    else {        return nil    }    let context = CGContext(data: nil,                            width: Int(size.width),                            height: Int(size.height),                            bitsPerComponent: image.bitsPerComponent,                            bytesPerRow: image.bytesPerRow,                            space: image.colorSpace ?? CGColorSpace(name: CGColorSpace.sRGB)!,                            bitmapInfo: image.bitmapInfo.rawValue)    context?.interpolationQuality = .high    context?.draw(image, in: CGRect(origin: .zero, size: size))    guard let scaledImage = context?.makeImage() else { return nil }    return UIImage(cgImage: scaledImage)}</code></pre><p>这个 <code>CGContext</code> 初始化方法接收了几个参数来构造一个上下文，包括了必要的宽高参数，还有在给出的色域范围内每个颜色通道所需要的内存大小。在这个例子中，这些参数都是通过 <code>CGImage</code> 这个对象获取的。下一步，设置 <code>interpolationQuality</code> 属性为 <code>.high</code> 指示上下文在保证一定的精度上填充像素。<code>draw(_:in:)</code> 方法则是在给定的宽高和位置绘制图像，可以让图片在特定的边距下裁剪，也可以适用于一些像是人脸识别之类的图像特性。最后 <code>makeImage()</code> 从上下文获取信息并且渲染到一个 <code>CGImage</code> 值上（之后会用来构造 <code>UIImage</code> 对象）。</p><h3 id="技巧-3：使用-Image-I-O-创建缩略图像"><a href="#技巧-3：使用-Image-I-O-创建缩略图像" class="headerlink" title="技巧 #3：使用 Image I/O 创建缩略图像"></a>技巧 #3：使用 Image I/O 创建缩略图像</h3><p>Image I/O 是一个强大（却鲜有人知）的图像处理框架。抛开 Core Graphics 不说，它可以读写许多不同图像格式，访问图像的元数据，还有执行常规的图像处理操作。这个框架通过先进的缓存机制，提供了平台上最快的图片编码器和解码器，甚至可以增量加载图片。</p><p>这个重要的 <code>CGImageSourceCreateThumbnailAtIndex</code> 提供了一个带有许多不同配置选项的 API，比起在 Core Graphics 中等价的处理操作要简洁得多：</p><pre><code>import ImageIO// 技巧 #3func resizedImage(at url: URL, for size: CGSize) -&gt; UIImage? {    let options: [CFString: Any] = [        kCGImageSourceCreateThumbnailFromImageIfAbsent: true,        kCGImageSourceCreateThumbnailWithTransform: true,        kCGImageSourceShouldCacheImmediately: true,        kCGImageSourceThumbnailMaxPixelSize: max(size.width, size.height)    ]    guard let imageSource = CGImageSourceCreateWithURL(url as NSURL, nil),        let image = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, options as CFDictionary)    else {        return nil    }    return UIImage(cgImage: image)}</code></pre><p>给定一个 <code>CGImageSource</code> 和一系列配置选项，<code>CGImageSourceCreateThumbnailAtIndex(_:_:_:)</code> 函数创建了一个图像的缩略图。优化尺寸大小的操作是通过 <code>kCGImageSourceThumbnailMaxPixelSize</code> 完成的，它根据图像原始宽高比指定的最大尺寸来缩放图像。通过设定 <code>kCGImageSourceCreateThumbnailFromImageIfAbsent</code> 或 <code>kCGImageSourceCreateThumbnailFromImageAlways</code> 选项，Image I/O 可以自动缓存优化后的结果以便后续调用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>UIKit</strong>, <strong>Core</strong> <strong>Graphics</strong>, 和 <strong>Image</strong> <strong>I/O</strong> 都能很好地用于大部分图片的优化操作。</li><li>如果（在 iOS 平台，至少）要选择一个的话，<code>UIGraphicsImageRenderer</code> 是你最佳的选择。</li><li><strong>Core</strong> <strong>Image</strong> 在图像优化渲染操作方面性能表现优越。实际上，根据 Apple 官方 <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/Conceptual/CoreImaging/ci_performance/ci_performance.html#//apple_ref/doc/uid/TP30001185-CH10-SW1" target="_blank" rel="noopener"><em>Core</em> <em>Image</em> <em>编程规范中的性能最佳实践单元</em></a>，你应该使用 Core Graphics 或 Image I/O 对图像进行裁剪和下采样，而不是用 Core Image。</li><li>除非你已经在使用 <strong><code>vImage</code></strong>，否则在大多数情况下用到底层的 Accelerate API 所需的额外工作可能是不合理的。</li></ul><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg/" target="_blank" rel="noopener">http://swift.gg</a>。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift备忘录</title>
      <link href="/2019/12/07/Swift%E5%A4%87%E5%BF%98%E5%BD%95/"/>
      <url>/2019/12/07/Swift%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="SwiftTip"><a href="#SwiftTip" class="headerlink" title="SwiftTip"></a>SwiftTip</h1><a id="more"></a><p>##1、@autoclosure作用：将表达式自动封装成一个闭包</p><p>()-&gt;Void</p><p>1.2 ??的底层实现是用的enum</p><p>1.3 “闭包和循环引用”</p><p><strong>weak解决循环引用的正确写法：</strong></p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token keyword">weak</span> <span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token keyword">in</span><span class="token keyword">if</span> <span class="token keyword">let</span> strongSelf <span class="token operator">=</span> <span class="token keyword">self</span> <span class="token punctuation">{</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The name is (strongSelf.name)"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="2、值类型和引用类型的选择"><a href="#2、值类型和引用类型的选择" class="headerlink" title="2、值类型和引用类型的选择"></a>2、值类型和引用类型的选择</h2><ul><li><p>数组和字典设计为值类型最大的考虑是为了线程安全.</p></li><li><p>另一个优点，那就是非常高效，因为 “一旦赋值就不太会变化” 这种使用情景在 Cocoa 框架中是占有绝大多数的，这有效减少了内存的分配和回收。</p></li></ul><p>但是在少数情况下，我们显然也可能会在数组或者字典中存储非常多的东西，并且还要对其中的内容进行添加或者删除。”</p><ul><li><p>在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好，</p></li><li><p>对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary</p></li></ul><h2 id="3、-escaping的作用？"><a href="#3、-escaping的作用？" class="headerlink" title="3、@escaping的作用？"></a>3、@escaping的作用？</h2><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">func</span> <span class="token function">animate</span><span class="token punctuation">(</span>withDuration duration<span class="token punctuation">:</span> <span class="token builtin">TimeInterval</span><span class="token punctuation">,</span> animations<span class="token punctuation">:</span> @<span class="token function">escaping</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> <span class="token builtin">Void</span><span class="token punctuation">,</span> completion<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">Bool</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token constant">nil</span><span class="token punctuation">)</span></code></pre><img src="/Users/mac/Downloads/图像 2019-12-5，下午6.41.jpg" alt="图像 2019-12-5，下午6.41" style="zoom:50%;" /><h2 id="4、defer的使用注意点"><a href="#4、defer的使用注意点" class="headerlink" title="4、defer的使用注意点"></a>4、defer的使用注意点</h2><h4 id="defer的作用域"><a href="#defer的作用域" class="headerlink" title="defer的作用域"></a>defer的作用域</h4><p><strong>以前很单纯地认为 defer 是在函数退出的时候调用，并没有注意其实是当前 scope 退出的时候调用这个事实，造成了这个错误。在 if，guard，for，try 这些语句中使用 defer 时，应该要特别注意这一点。</strong></p><img src="/Users/mac/Downloads/图像 2019-12-5，下午6.41-1.jpg" alt="图像 2019-12-5，下午6.41-1" style="zoom:150%;" /><h2 id="5、-discardableResult"><a href="#5、-discardableResult" class="headerlink" title="5、@discardableResult"></a>5、@discardableResult</h2><h2 id="6、Result"><a href="#6、Result" class="headerlink" title="6、Result"></a>6、Result<T></h2><p><a href="https://onevcat.com/2018/10/swift-result-error/" target="_blank" rel="noopener">Result&lt;T, E: Error&gt; 和 Result<T></a></p><h2 id="7、Lazy的使用"><a href="#7、Lazy的使用" class="headerlink" title="7、Lazy的使用"></a>7、Lazy的使用</h2><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token keyword">let</span> result <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token keyword">lazy</span><span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token keyword">in</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"准备处理(i)"</span><span class="token punctuation">)</span><span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"准备访问结果"</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> result <span class="token punctuation">{</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"处理后的结果:(i)"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span></code></pre><p>打印结果：</p><blockquote><p>准备访问结果</p></blockquote><p>准备处理1</p><p>处理后的结果:2</p><p>准备处理2</p><p>处理后的结果:4</p><p>准备处理3</p><p>处理后的结果:6</p><p>done</p><h2 id="8、Swift反射机制Mirror"><a href="#8、Swift反射机制Mirror" class="headerlink" title="8、Swift反射机制Mirror"></a>8、Swift反射机制Mirror</h2><blockquote><p>“通过 Mirror 初始化得到的结果中包含的元素的描述都被集合在 children 属性下，如果你有心可以到 Swift 标准库中查找它的定义，它实际上是一个 Child 的集合，而 Child 则是一对键值的多元组：</p></blockquote><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Car</span> <span class="token punctuation">{</span><span class="token keyword">let</span> logo<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token keyword">var</span> wheel<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token keyword">let</span> door<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">}</span><span class="token keyword">let</span> baoM <span class="token operator">=</span> <span class="token function">Car</span><span class="token punctuation">(</span>logo<span class="token punctuation">:</span> <span class="token string">"BMW"</span><span class="token punctuation">,</span> wheel<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> door<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">let</span> mirror <span class="token operator">=</span> <span class="token function">Mirror</span><span class="token punctuation">(</span>reflecting<span class="token punctuation">:</span> baoM<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"类型:(String(describing: mirror.displayStyle))"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">///1、通过Mirror的children获取属性信息</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"属性个数:(mirror.children.count)"</span><span class="token punctuation">)</span>mirror<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Any</span> <span class="token keyword">in</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"label: (String(describing: child.label)), value: (child.value)"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">///2、通过Refletion的dump(Any)方法获取属性信息</span><span class="token function">dump</span><span class="token punctuation">(</span>baoM<span class="token punctuation">)</span></code></pre><h3 id="示例2-获取property"><a href="#示例2-获取property" class="headerlink" title="示例2 获取property"></a>示例2 获取property</h3><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> homeProperty <span class="token operator">=</span> <span class="token function">Mirror</span><span class="token punctuation">(</span>reflecting<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">)</span>homeProperty<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span><span class="token constant">LOG</span><span class="token punctuation">.</span><span class="token function">D</span><span class="token punctuation">(</span><span class="token string">"home property:($0)"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="9、iOS初始化核心原则"><a href="#9、iOS初始化核心原则" class="headerlink" title="9、iOS初始化核心原则"></a>9、iOS初始化核心原则</h2><blockquote><p>iOS 的初始化最核心两条的规则：</p></blockquote><blockquote><p>• 必须至少有一个指定初始化器，在指定初始化器里保证所有非可选类型属性都得到正确的初始化（有值）</p></blockquote><blockquote><p>• 便利初始化器必须调用其他初始化器，使得最后肯定会调用指定初始化器</p></blockquote><p>在Swift中千万不要用String的count方法计算文本长度。否则当文本中有emoji时，会计算出错。应当转成NSString再去求length。</p><h2 id="10、"><a href="#10、" class="headerlink" title="10、"></a>10、</h2><h2 id="Swift备忘录001-Array-for-in使用"><a href="#Swift备忘录001-Array-for-in使用" class="headerlink" title="Swift备忘录001 Array for-in使用"></a>Swift备忘录001 Array for-in使用</h2><img src="/Users/mac/Library/Application Support/typora-user-images/image-20191205151814435.png" alt="image-20191205151814435" style="zoom:50%;" /><h4 id="1-for-in获取索引-index"><a href="#1-for-in获取索引-index" class="headerlink" title="1.for in获取索引 index"></a>1.for in获取索引 index</h4><pre class=" language-swift"><code class="language-swift">                <span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Google"</span><span class="token punctuation">,</span> <span class="token string">"Amazon"</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> item <span class="token keyword">in</span> array <span class="token punctuation">{</span>          <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"company name is :(item)"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">///配合array.enumerated()使用</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> item<span class="token punctuation">)</span> <span class="token keyword">in</span> array<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"index:(index), item:(item)"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span></code></pre><h4 id="2-array-firstIndex-of-获取index"><a href="#2-array-firstIndex-of-获取index" class="headerlink" title="2.array.firstIndex(of:)获取index"></a>2.array.firstIndex(of:)获取index</h4><pre class=" language-swift"><code class="language-swift">                <span class="token comment" spellcheck="true">///配合array.firstIndex(of:)使用</span>        <span class="token keyword">let</span> googleIndex <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">firstIndex</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> <span class="token string">"Google"</span><span class="token punctuation">)</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"googleIndex is : (googleIndex ?? 0)"</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">///配合array.firstIndex(where:)使用</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> index <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">firstIndex</span><span class="token punctuation">(</span><span class="token keyword">where</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> $<span class="token number">0</span><span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"array.firstIndex is (index)"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> item <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token keyword">where</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> $<span class="token number">0</span><span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"array.first is :(item)"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span></code></pre><h2 id="Swift备忘录002-Array-forEach"><a href="#Swift备忘录002-Array-forEach" class="headerlink" title="Swift备忘录002 Array.forEach()"></a>Swift备忘录002 Array.forEach()</h2><h4 id="2-1forEach-和函数式编程结合使用"><a href="#2-1forEach-和函数式编程结合使用" class="headerlink" title="2.1forEach()和函数式编程结合使用"></a>2.1forEach()和函数式编程结合使用</h4><pre class=" language-swift"><code class="language-swift">                <span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"5"</span><span class="token punctuation">,</span> <span class="token string">"6"</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">///使用forEach</span>        array<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token function">Int</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">!</span> <span class="token punctuation">}</span><span class="token punctuation">.</span>forEach <span class="token punctuation">{</span> num <span class="token keyword">in</span>            <span class="token function">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//不使用forEach</span>        <span class="token keyword">let</span> <span class="token builtin">map</span> <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token function">Int</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">!</span> <span class="token punctuation">}</span>        <span class="token builtin">map</span><span class="token punctuation">.</span>forEach <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span></code></pre><h4 id="2-2forEach-遍历optional集合会自动过滤nil"><a href="#2-2forEach-遍历optional集合会自动过滤nil" class="headerlink" title="2.2forEach()遍历optional集合会自动过滤nil"></a>2.2forEach()遍历optional集合会自动过滤nil</h4><pre class=" language-swift"><code class="language-swift">                <span class="token keyword">let</span> optionalString<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token constant">nil</span>        <span class="token comment" spellcheck="true">//使用forEach强制解包option，会过滤</span>        optionalString<span class="token operator">?</span><span class="token punctuation">.</span>forEach <span class="token punctuation">{</span> str <span class="token keyword">in</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"str is (str)"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">///使用for-in强制解包optional，会crash</span>        <span class="token keyword">for</span> str <span class="token keyword">in</span> optionalString<span class="token operator">!</span> <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"str is (str)"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span></code></pre><h2 id="Swift备忘录003-Array-index"><a href="#Swift备忘录003-Array-index" class="headerlink" title="Swift备忘录003 Array index"></a>Swift备忘录003 Array index</h2><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift函数式编程</title>
      <link href="/2019/12/06/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/12/06/Swift%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Functional-Programming-in-Swift"><a href="#Functional-Programming-in-Swift" class="headerlink" title="Functional Programming in Swift"></a>Functional Programming in Swift</h1><p>函数式编程介绍。版本：swift 4.2, iOS 12, Xcode 10</p><p>在本部分中，您将介绍FP中的一些关键概念。许多讨论FP的论文都将不变状态和缺乏副作用视为FP的最重要方面，因此您将从这里开始。</p><a id="more"></a><h2 id="不变性和副作用"><a href="#不变性和副作用" class="headerlink" title="不变性和副作用"></a>不变性和副作用</h2><p>无论您首先学习哪种编程语言，您可能要学习的最初概念之一就是变量代表数据或状态。如果您退一步考虑一下这个想法，变量似乎很奇怪。</p><p>术语“变量”表示随程序运行而变化的数量。从数学角度考虑数量问题，您已将时间作为软件行为的关键参数。通过更改变量，可以创建可变状态。</p><p>为了进行演示，请将以下代码添加到playground：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> thing <span class="token operator">=</span> <span class="token number">3</span><span class="token comment" spellcheck="true">//some stuff</span>thing <span class="token operator">=</span> <span class="token number">4</span><span class="token keyword">func</span> <span class="token function">superHero</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"I'm batman"</span><span class="token punctuation">)</span>  thing <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"original state = <span class="token interpolation"><span class="token delimiter variable">\(</span>thing<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token function">superHero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"mutated state = <span class="token interpolation"><span class="token delimiter variable">\(</span>thing<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span></code></pre><p>神圣的神秘变化！为什么现在是5？这种变化称为副作用。函数superHero（）更改了一个甚至没有定义自己的变量。</p><p>单独或在简单系统中，可变状态不一定是问题。将许多对象连接在一起时（例如在大型的面向对象的系统中）会出现问题。可变状态会使人难以理解变量具有什么值以及该值随时间的变化而产生头痛。</p><p>例如，在为多线程系统编写代码时，如果两个或多个线程<strong>同时访问同一变量</strong>，则它们可能会<strong>无序地修改或访问它</strong>。这会导致意外的行为。<strong>这种意外行为包括竞态条件，死锁和许多其他问题。</strong></p><p>试想一下，如果您可以编写状态永远不变的代码。并发系统中发生的所有问题都将消失。像这样工作的系统具有<strong>不变的状态</strong>，这意味着不允许状态在程序过程中进行更改。</p><p>使用不可变数据的主要好处是，使用不可变数据的代码单元没有副作用。代码中的函数不会更改其自身之外的元素，并且在发生函数调用时不会出现怪异的效果。您的程序可以正常运行，因为没有副作用，您可以轻松重现其预期的效果。</p><p>本教程从较高的层次介绍了FP，因此在实际情况下考虑这些概念会很有帮助。在这种情况下，假设您正在为游乐园构建应用程序，并且该游乐园的后端服务器通过REST API提供了行程数据。</p><h2 id="创建Model"><a href="#创建Model" class="headerlink" title="创建Model"></a>创建Model</h2><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">RideCategory</span><span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>  <span class="token keyword">case</span> family  <span class="token keyword">case</span> kids  <span class="token keyword">case</span> thrill  <span class="token keyword">case</span> scary  <span class="token keyword">case</span> relaxing  <span class="token keyword">case</span> water<span class="token punctuation">}</span><span class="token keyword">typealias</span> <span class="token builtin">Minutes</span> <span class="token operator">=</span> <span class="token builtin">Double</span><span class="token keyword">struct</span> <span class="token builtin">Ride</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>  <span class="token keyword">let</span> categories<span class="token punctuation">:</span> <span class="token builtin">Set</span><span class="token operator">&lt;</span><span class="token builtin">RideCategory</span><span class="token operator">></span>  <span class="token keyword">let</span> waitTime<span class="token punctuation">:</span> <span class="token builtin">Minutes</span><span class="token punctuation">}</span></code></pre><h2 id="Create-some-data-using-that-model"><a href="#Create-some-data-using-that-model" class="headerlink" title="Create some data using that model"></a>Create some data using that model</h2><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> parkRides <span class="token operator">=</span> <span class="token punctuation">[</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R45"</span><span class="token punctuation">,</span>               categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>family<span class="token punctuation">,</span> <span class="token punctuation">.</span>thrill<span class="token punctuation">,</span> <span class="token punctuation">.</span>water<span class="token punctuation">]</span><span class="token punctuation">,</span>               waitTime<span class="token punctuation">:</span> <span class="token number">45.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R10"</span><span class="token punctuation">,</span> categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>family<span class="token punctuation">]</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">:</span> <span class="token number">10.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R15"</span><span class="token punctuation">,</span> categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>kids<span class="token punctuation">]</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">:</span> <span class="token number">15.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R30"</span><span class="token punctuation">,</span> categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>scary<span class="token punctuation">]</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">:</span> <span class="token number">30.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R60"</span><span class="token punctuation">,</span>               categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>family<span class="token punctuation">,</span> <span class="token punctuation">.</span>thrill<span class="token punctuation">]</span><span class="token punctuation">,</span>               waitTime<span class="token punctuation">:</span> <span class="token number">60.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R15-2"</span><span class="token punctuation">,</span> categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>family<span class="token punctuation">,</span> <span class="token punctuation">.</span>kids<span class="token punctuation">]</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">:</span> <span class="token number">15.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R25"</span><span class="token punctuation">,</span> categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>family<span class="token punctuation">,</span> <span class="token punctuation">.</span>water<span class="token punctuation">]</span><span class="token punctuation">,</span> waitTime<span class="token punctuation">:</span> <span class="token number">25.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          <span class="token function">Ride</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"R0"</span><span class="token punctuation">,</span>               categories<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span>family<span class="token punctuation">,</span> <span class="token punctuation">.</span>relaxing<span class="token punctuation">]</span><span class="token punctuation">,</span>               waitTime<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">)</span>        <span class="token punctuation">]</span></code></pre><h2 id="FP-Filter-Map-Reduce"><a href="#FP-Filter-Map-Reduce" class="headerlink" title="FP: Filter Map Reduce"></a>FP: Filter Map Reduce</h2><p><strong>Most languages that support FP will have the functions filter, map &amp; reduce.</strong></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><blockquote><p>Map是将输入Collection中的每个Element转换为新Element。</p><p>使用map遍历一个集合，并对集合中的每个元素应用相同的操作。</p><p> map函数返回一个数组，其中包含对每个元素的映射或转换函数的结果。</p></blockquote><h4 id="Map-on-array"><a href="#Map-on-array" class="headerlink" title="Map on array:"></a>Map on array:</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> arrayOfInt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span></code></pre><p>如果我们要对每个元素乘上10呢？我们以前可能要这样</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> newArr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> value <span class="token keyword">in</span> arrayOfInt <span class="token punctuation">{</span>    newArr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>value <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span></code></pre><p>现在有map()后我们可以这样：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> mapArr <span class="token operator">=</span> arrayOfInt<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>mapArr<span class="token punctuation">)</span></code></pre><blockquote><p>Working of map: The map function has a single argument which is a closure (a function) that it calls as it loops over the collection. This closure takes the element from the collection as an argument and returns a result. The map function returns these results in an array.</p></blockquote><h4 id="Map-on-Dictionary"><a href="#Map-on-Dictionary" class="headerlink" title="Map on Dictionary"></a>Map on Dictionary</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> book <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">]</span><span class="token keyword">let</span> mapedBook <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span>    key<span class="token punctuation">.</span>capitalized<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>mapedBook<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//["C", "B", "A"]</span></code></pre><h4 id="Map-on-Set"><a href="#Map-on-Set" class="headerlink" title="Map on Set"></a>Map on Set</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> lengthInmeter<span class="token punctuation">:</span> <span class="token builtin">Set</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token keyword">let</span> km  <span class="token operator">=</span> lengthInmeter<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> meter <span class="token keyword">in</span> meter <span class="token operator">*</span> <span class="token number">1000</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>km<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [1000, 5000, 3000]</span></code></pre><h4 id="Map同时获取array-Index"><a href="#Map同时获取array-Index" class="headerlink" title="Map同时获取array.Index??"></a>Map同时获取array.Index??</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token keyword">let</span> newNums <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token keyword">in</span>    <span class="token keyword">return</span> num <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"newNums:<span class="token interpolation"><span class="token delimiter variable">\(</span>newNums<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span></code></pre><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter函数的作用是过滤集合，返回符合条件的集合。</p><h4 id="Filter-on-Array"><a href="#Filter-on-Array" class="headerlink" title="Filter on Array"></a>Filter on Array</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> filterArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token keyword">let</span> newFilterArray <span class="token operator">=</span> filterArray<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span> num <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token keyword">in</span>    num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>newFilterArray<span class="token punctuation">)</span></code></pre><h4 id="Filter-on-Dictionary"><a href="#Filter-on-Dictionary" class="headerlink" title="Filter on Dictionary"></a>Filter on Dictionary</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> book <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">]</span><span class="token keyword">let</span> bookFilter <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span>    value <span class="token operator">></span> <span class="token number">80</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>bookFilter<span class="token punctuation">)</span></code></pre><p><strong>简化</strong></p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> book <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">]</span><span class="token keyword">let</span> bookFilter <span class="token operator">=</span> book<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span>    $<span class="token number">1</span> <span class="token operator">></span> <span class="token number">80</span><span class="token punctuation">}</span></code></pre><blockquote><p>$0是key</p><p>$1是value</p></blockquote><h4 id="Filter-on-Set"><a href="#Filter-on-Set" class="headerlink" title="Filter on Set"></a>Filter on Set</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> setNums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4.9</span><span class="token punctuation">,</span><span class="token number">5.5</span><span class="token punctuation">,</span><span class="token number">8.6</span><span class="token punctuation">]</span><span class="token keyword">let</span> newSet <span class="token operator">=</span> setNums<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span>    $<span class="token number">0</span> <span class="token operator">></span> <span class="token number">5.0</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>newSet<span class="token punctuation">)</span></code></pre><p><strong>重要：返回类型是数组</strong></p><h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><blockquote><p>Use <code>reduce</code> to combine all items in a collection to create a single new value.</p></blockquote><blockquote><p>使用<em>reduce</em>可以合并集合中的所有元素来创建一个新的value</p></blockquote><p>Apple文档声明reduce()</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token builtin">reduce</span><span class="token operator">&lt;</span><span class="token builtin">Result</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> initialResult<span class="token punctuation">:</span> <span class="token builtin">Result</span><span class="token punctuation">,</span> <span class="token number">_</span> nextPartialResult<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">Result</span><span class="token punctuation">,</span> <span class="token builtin">Element</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Result</span><span class="token punctuation">)</span> <span class="token keyword">rethrows</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Result</span></code></pre><p><strong>reduce</strong>函数有两个参数：</p><ul><li>第一个参数 <strong>initial value</strong>用来存储初始值或者结果（每次迭代器的结果）</li><li>第二个是带有两个参数的闭包，Result是初始值或迭代器的结果，Element是集合中的下一个元素。</li></ul><h4 id="Reduce-on-Array"><a href="#Reduce-on-Array" class="headerlink" title="Reduce on Array"></a>Reduce on Array</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token keyword">let</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token keyword">in</span>    x <span class="token operator">+</span> y<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span></code></pre><p>简化版本：使用$0代表result</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> reducedSum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">+</span> $<span class="token number">1</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>reducedSum<span class="token punctuation">)</span><span class="token comment" spellcheck="true">///等价</span><span class="token keyword">let</span> reducedSum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>reducedSum<span class="token punctuation">)</span></code></pre><p>乘法</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> produceNum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token keyword">in</span>    x <span class="token operator">*</span> y<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>produceNum<span class="token punctuation">)</span><span class="token comment" spellcheck="true">///等价</span><span class="token keyword">let</span> produceNum <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>produceNum<span class="token punctuation">)</span></code></pre><h4 id="Reduce-连接字符串"><a href="#Reduce-连接字符串" class="headerlink" title="Reduce + 连接字符串"></a>Reduce + 连接字符串</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> charactors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span><span class="token string">"def"</span><span class="token punctuation">,</span><span class="token string">"hijk"</span><span class="token punctuation">]</span><span class="token keyword">let</span> newCharactor <span class="token operator">=</span> charactors<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>newCharactor<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// abcdefhijk</span></code></pre><h4 id="Reduce-on-Dictionary"><a href="#Reduce-on-Dictionary" class="headerlink" title="Reduce on Dictionary"></a>Reduce on Dictionary</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> dict <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// Reduce on value</span><span class="token keyword">let</span> reducedNum <span class="token operator">=</span> dict<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> result<span class="token punctuation">,</span> dic <span class="token keyword">in</span>    <span class="token keyword">return</span> result <span class="token operator">+</span> dic<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"reduc on value is <span class="token interpolation"><span class="token delimiter variable">\(</span>reducedNum<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// reduc on value is 125</span><span class="token comment" spellcheck="true">// Reduce on key</span><span class="token keyword">let</span> reducedName <span class="token operator">=</span> dict<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token string">"Charactor are "</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>result<span class="token punctuation">,</span> dic<span class="token punctuation">)</span> <span class="token keyword">in</span>    <span class="token keyword">return</span> result <span class="token operator">+</span> dic<span class="token punctuation">.</span>key <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"reduce on key is &lt;<span class="token interpolation"><span class="token delimiter variable">\(</span>reducedName<span class="token delimiter variable">)</span></span>>"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//reduce on key is &lt;Charactor are A B ></span></code></pre><p>简化</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> reducedNameOnDic <span class="token operator">=</span> dict<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token string">"Charater are "</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">+</span> $<span class="token number">1</span><span class="token punctuation">.</span>key <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">}</span></code></pre><h4 id="Reduce-on-Set"><a href="#Reduce-on-Set" class="headerlink" title="Reduce on Set"></a>Reduce on Set</h4><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// Reduce on Set</span><span class="token keyword">let</span> lengthMeters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3.4</span><span class="token punctuation">,</span><span class="token number">1.6</span><span class="token punctuation">]</span><span class="token keyword">let</span> reducedMeters <span class="token operator">=</span> lengthMeters<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    $<span class="token number">0</span> <span class="token operator">+</span> $<span class="token number">1</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"reduced meters :<span class="token interpolation"><span class="token delimiter variable">\(</span>reducedMeters<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 5.0</span></code></pre><h2 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h2><p>Flatmap is used to flatten a collection of collections . But before flattening the collection, we can apply map to each elements.</p><blockquote><p><strong>Apple docs says</strong>: Returns an array containing the concatenated results of calling the given transformation with each element of this sequence.</p></blockquote><p>Flatmap用于展平集合的集合。 但是在展平集合之前，我们可以将map应用于每个集合元素。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> charaters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span><span class="token string">"def"</span><span class="token punctuation">,</span><span class="token string">"ghi"</span><span class="token punctuation">]</span><span class="token keyword">let</span> newCharaters <span class="token operator">=</span> charaters<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>newCharaters<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//["a", "b", "c", "d", "e", "f", "g", "h", "i"]</span><span class="token keyword">let</span> codes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span><span class="token string">"def"</span><span class="token punctuation">,</span><span class="token string">"ghi"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"jkl"</span><span class="token punctuation">,</span><span class="token string">"mno"</span><span class="token punctuation">,</span><span class="token string">"pqr"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"stu"</span><span class="token punctuation">,</span><span class="token string">"vwx"</span><span class="token punctuation">,</span><span class="token string">"yz"</span><span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token keyword">let</span> newCodes <span class="token operator">=</span> codes<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span>$<span class="token number">0</span><span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>newCodes<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// ["abc", "def", "ghi", "jkl", "mno", "pqr", "stu", "vwx", "yz"]</span></code></pre><h4 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h4><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> nilArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token constant">nil</span><span class="token punctuation">]</span><span class="token function">print</span><span class="token punctuation">(</span>nilArray<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [2,3]</span><span class="token comment" spellcheck="true">// warning: 'flatMap' is deprecated: Please use compactMap(_:) for the case where closure returns an optional value</span><span class="token function">print</span><span class="token punctuation">(</span>nilArray<span class="token punctuation">.</span>compactMap <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [2,3]</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
